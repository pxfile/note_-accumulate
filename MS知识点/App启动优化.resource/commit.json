{"compress":true,"commitItems":[["009a1939-5d90-458a-98fb-0e68d513ea9b",1520243003137,"",[[1520242948534,["gengmei_pxf@gengmei123.local",[[1,0,"启动优化\n===\n\n\n"]],[0,0],[11,11]]],[1520243000943,["gengmei_pxf@gengmei123.local",[[1,0,"App"]],[0,0],[3,3]]],[1520243065786,["gengmei_pxf@gengmei123.local",[[1,13,"1 \n\n## 应用的启动方式\n\n通常来说，启动方式分为两种：冷启动和热启动。\n\n1、冷启动：当启动应用时，后台没有该应用的进程，这时系统会重新创建一个新的进程分配给该应用，这个启动方式就是冷启动。\n\n2、热启动：当启动应用时，后台已有该应用的进程（例：按back键、home键，应用虽然会退出，但是该应用的进程是依然会保留在后台，可进入任务列表查看），所以在已有进程的情况下，这种启动会从已有的进程中来启动应用，这个方式叫热启动。\n\n2 \n\n## App的启动过程\n\n## 本文所指的优化针对冷启动。简单解释一下App的启动过程：\n\n*   1.点击Launcher，启动程序,通知ActivityManagerService\n\n*   2.ActivityManagerService通知zygote进程孵化出应用进程，分配内存空间等\n\n*   3.执行该应用ActivityThread的main()方法\n\n*   4.应用程序通知ActivityManagerService它已经启动，ActivityManagerService保存一个该应用的代理对象,ActivityManagerService通过它可以控制应用进程\n\n*   5.ActivityManagerService通知应用进程创建入口的Activity实例，执行它的生命周期\n\n启动过程中Application和入口Activity的生命周期方法按如下顺序调用：\n\n*   1.Application 构造方法\n\n*   2.attachBaseContext()\n\n*   3.onCreate()\n\n*   4.入口Activity的对象构造\n\n*   5.setTheme() 设置主题等信息\n\n*   6.入口Activity的onCreate()\n\n*   7.入口Activity的onStart()\n\n*   8.入口Activity的onResume()\n\n*   9.入口Activity的onAttachToWindow()\n\n*   10.入口Activity的onWindowFocusChanged()"]],[13,13],[914,914]]],[1520243072871,["gengmei_pxf@gengmei123.local",[[-1,14," "],[-1,231," "],[1,232," "]],[15,15],[14,14]]],[1520243073284,["gengmei_pxf@gengmei123.local",[[-1,13,"1"]],[14,14],[13,13]]],[1520243073510,["gengmei_pxf@gengmei123.local",[[-1,14,"\n"]],[13,13],[12,12]]],[1520243074117,["gengmei_pxf@gengmei123.local",[[-1,13,"\n"]],[12,12],[11,11]]],[1520243076694,["gengmei_pxf@gengmei123.local",[[-1,226,"2 "]],[228,228],[226,226]]],[1520243076877,["gengmei_pxf@gengmei123.local",[[-1,227,"\n"]],[226,226],[225,225]]],[1520243077413,["gengmei_pxf@gengmei123.local",[[-1,226,"\n"]],[225,225],[224,224]]],[1520243085237,["gengmei_pxf@gengmei123.local",[[1,907,"\n"]],[906,906],[907,907]]],[1520243085581,["gengmei_pxf@gengmei123.local",[[1,908,"\n"]],[907,907],[908,908]]],[1520243094472,["gengmei_pxf@gengmei123.local",[[1,908,"## 启动时间统计"]],[908,908],[917,917]]],[1520243104365,["gengmei_pxf@gengmei123.local",[[1,918,"\n"]],[917,917],[918,918]]],[1520243105452,["gengmei_pxf@gengmei123.local",[[1,919,"\n"]],[918,918],[919,919]]],[1520243109663,["gengmei_pxf@gengmei123.local",[[-1,919,"\n"],[1,920,"* 【】"]],[919,919],[923,923]]],[1520243110476,["gengmei_pxf@gengmei123.local",[[-1,921,"【】"]],[923,923],[921,921]]],[1520243111574,["gengmei_pxf@gengmei123.local",[[1,921,"[]()"]],[921,921],[925,925]]],[1520243142797,["gengmei_pxf@gengmei123.local",[[1,922,"统计启动时长-标准"]],[922,922],[931,931]]],[1520243159650,["gengmei_pxf@gengmei123.local",[[1,933,"https://pxfile.github.io/2018/03/04/android-%E7%BB%9F%E8%AE%A1%E5%90%AF%E5%8A%A8%E6%97%B6%E9%95%BF-%E6%A0%87%E5%87%86/\n\n"]],[933,933],[1053,1053]]],[1520243159971,["gengmei_pxf@gengmei123.local",[[1,1054,"\n"]],[1053,1053],[1054,1054]]],[1520243243154,[null,[[1,1051,")"],[-1,1053,")"]],[1051,1051],[1053,1053]]],[1520243243154,[null,[[-1,1051,")"],[1,1054,")"]],[1053,1053],[1051,1051]]],[1520243193408,["gengmei_pxf@gengmei123.local",[[1,1054,"把SplashActivity改成SplashFragment,应用程序的入口仍然是MainActivity,在MainActivity中先展示SplashFragment\n\n当SplashFragment显示完毕后再将它remove，同时在SplashFragment的2S的友好时间内进行网络数据缓存，在窗口加载完毕后，我们加载activity_main的布局，考虑到这个布局有可能比较复杂，耽误View的解析时间，采用ViewStub的形式进行懒加载。\n\n这样一开始只要加载SplashFragment所展示的布局就Ok了。\n\n代码： \nMainActivity.java\n\n![](http://www.10tiao.com/img.do?url=http%3A//mmbiz.qpic.cn/mmbiz_jpg/MOu2ZNAwZwONVq0CkCGePV0DbibArTP4XLS5V5cqe0viapTRlQVN5JTcVZOBwZZy6NrDNkSJXjwnrlTdwOwELAEQ/0%3Fwx_fmt%3Djpeg)\n\nSplashFragment .java\n\n![](http://www.10tiao.com/img.do?url=http%3A//mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwONVq0CkCGePV0DbibArTP4XC4myKXoxtRQqFWMYrbOBiaNrsTVMD4WfQDFhdOo22gtEHI3E2ibZzPqA/0%3Fwx_fmt%3Dpng)\n\nactivity_mian.xml\n\n![](http://www.10tiao.com/img.do?url=http%3A//mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwONVq0CkCGePV0DbibArTP4XzGe9BYEmIERLxwZFhsdQym3vEUicGyxF1JicydtghyTwdsicfEJFBKcKA/0%3Fwx_fmt%3Dpng)\n\nfragment.xml\n\n![](http://www.10tiao.com/img.do?url=http%3A//mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwONVq0CkCGePV0DbibArTP4Xv103lxCv271tW6Eb3gzHuMgps21JQJiaZT38VGyNYMOH9sequ4ETdTQ/0%3Fwx_fmt%3Dpng)\n\n采用以上方式后，可以发现启动速度得到很大的改观。\n\n5\n\n## 启动优化一些思路\n\n*   1、避免启动页UI的过度绘制，减少UI重复绘制时间，打开设置中的GPU过度绘制开关，界面整体呈现浅色，特别复杂的界面，红色区域也不应该超过全屏幕的四分之一； \n\n*   2、主线程中的所有SharedPreference能否在非UI线程中进行，SharedPreferences的apply函数需要注意，因为Commit函数会阻塞IO，这个函数虽然执行很快，但是系统会有另外一个线程来负责写操作，当apply频率高的时候，该线程就会比较占用CPU资源。类似的还有统计埋点等，在主线程埋点但异步线程提交，频率高的情况也会出现这样的问题。 \n\n*   3、对于首次启动的黑屏问题，对于“黑屏”是否可以设计一个.9图片替换掉，间接减少用户等待时间。 \n\n*   4、对于网络错误界面，友好提示界面，使用ViewStub的方式，减少UI一次性绘制的压力。 \n\n*   5、通过下面这种方式进行懒加载\n\n*   ```none\n     getWindow().getDecorView()\n         .post(new Runnable() {\n               @Override\n               public void run() {\n                   myHandler.post(mLoadingRunnable);\n                }\n      });\n    ```\n\n*   6、Multidex的使用，也是拖慢启动速度的元凶，必须要做优化"]],[1054,1054],[2821,2821]]],[1520243303157,[null,[[1,1051,")"],[-1,1053,")"]],[1051,1051],[1053,1053]]],[1520243303158,[null,[[-1,1051,")"],[1,1054,")"]],[1053,1053],[1051,1051]]],[1520243254561,["gengmei_pxf@gengmei123.local",[[1,1054,"\n"],[-1,1324," "],[1,1325," "],[-1,2240," "],[1,2241," "],[-1,2429," "],[1,2430," "],[-1,2483," "],[1,2484," "],[-1,2535," "],[1,2536," "],[-1,2608,"   "],[1,2611,"   "],[-1,2640,"         "],[1,2649,"         "],[-1,2665,"         "],[1,2674,"         "],[-1,2700,"             "],[1,2713,"             "],[-1,2753,"           "],[1,2764,"           "],[-1,2771," "],[1,2772," "]],[1052,1052],[1053,1053]]],[1520243254752,["gengmei_pxf@gengmei123.local",[[1,1055,"\n"]],[1053,1053],[1054,1054]]],[1520243255318,["gengmei_pxf@gengmei123.local",[[1,1054,"## 启动页优化\n\n## 平时我们在开发App时，都会设置一个启动页SplashActivity,然后2或3秒后，并且SplashActivity里面可以去做一些MainActivity的数据的预加载，然后需要通过意图传到MainActivity。 \n\n*   优点：启动速度有所加快 \n\n*   缺点：最终还是要进入首页，在进入首页的时候，首页复杂的View渲染以及必须在UI线程执行的业务逻辑，仍然拖慢了启动速度。启动页简单执行快，首页复杂执行慢，前轻后重。\n\n> 思路：能否在启动页的展示的同时，首页的View就能够被加载，首页的业务逻辑就能够被执行？\n\n优化方向："]],[1054,1054],[1340,1340]]],[1520243268217,["gengmei_pxf@gengmei123.local",[[-1,1065,"#"],[-1,1178," "],[1,1179," "],[-1,1196," "],[1,1197," "]],[1066,1066],[1065,1065]]],[1520243271145,["gengmei_pxf@gengmei123.local",[[-1,1064,"# "]],[1065,1065],[1064,1064]]],[1520243290288,["gengmei_pxf@gengmei123.local",[[-1,2427,"5"]],[2428,2428],[2427,2427]]],[1520243290457,["gengmei_pxf@gengmei123.local",[[-1,2428,"\n"]],[2427,2427],[2426,2426]]],[1520243290760,["gengmei_pxf@gengmei123.local",[[-1,2427,"\n"]],[2426,2426],[2425,2425]]],[1520243337141,[null,[[1,1051,")"],[-1,1053,")"]],[1051,1051],[1053,1053]]],[1520243337141,[null,[[-1,1051,")"],[1,1054,")"]],[1053,1053],[1051,1051]]],[1520243319334,["gengmei_pxf@gengmei123.local",[[-1,2841,"*"]],[2842,2842],[2841,2841]]],[1520243322296,["gengmei_pxf@gengmei123.local",[[-1,2840,"\n"]],[2841,2841],[2840,2840]]],[1520243324367,["gengmei_pxf@gengmei123.local",[[1,2840,"\n"]],[2840,2840],[2841,2841]]],[1520243328736,["gengmei_pxf@gengmei123.local",[[-1,2847,"none"]],[2847,2851],[2847,2847]]],[1520244357191,[null,[[1,1051,")"],[-1,1053,")"]],[1051,1051],[1053,1053]]],[1520244357191,[null,[[-1,1051,")"],[1,1054,")"]],[1053,1053],[1051,1051]]],[1520244305014,["gengmei_pxf@gengmei123.local",[[-1,1064,"平时我们在开发App时，都会设置一个启动页SplashActivity,然后2或3秒后，并且SplashActivity里面可以去做一些MainActivity的数据的预加载，然后需要通过意图传到MainActivity。 \n\n*   优点：启动速度有所加快 \n\n*   缺点：最终还是要进入首页，在进入首页的时候，首页复杂的View渲染以及必须在UI线程执行的业务逻辑，仍然拖慢了启动速度。启动页简单执行快，首页复杂执行慢，前轻后重。\n\n> 思路：能否在启动页的展示的同时，首页的View就能够被加载，首页的业务逻辑就能够被执行？\n\n优化方向：\n\n把SplashActivity改成SplashFragment,应用程序的入口仍然是MainActivity,在MainActivity中先展示SplashFragment\n\n当SplashFragment显示完毕后再将它remove，同时在SplashFragment的2S的友好时间内进行网络数据缓存，在窗口加载完毕后，我们加载activity_main的布局，考虑到这个布局有可能比较复杂，耽误View的解析时间，采用ViewStub的形式进行懒加载。\n\n这样一开始只要加载SplashFragment所展示的布局就Ok了。\n\n代码： \nMainActivity.java\n\n![](http://www.10tiao.com/img.do?url=http%3A//mmbiz.qpic.cn/mmbiz_jpg/MOu2ZNAwZwONVq0CkCGePV0DbibArTP4XLS5V5cqe0viapTRlQVN5JTcVZOBwZZy6NrDNkSJXjwnrlTdwOwELAEQ/0%3Fwx_fmt%3Djpeg)\n\nSplashFragment .java\n\n![](http://www.10tiao.com/img.do?url=http%3A//mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwONVq0CkCGePV0DbibArTP4XC4myKXoxtRQqFWMYrbOBiaNrsTVMD4WfQDFhdOo22gtEHI3E2ibZzPqA/0%3Fwx_fmt%3Dpng)\n\nactivity_mian.xml\n\n![](http://www.10tiao.com/img.do?url=http%3A//mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwONVq0CkCGePV0DbibArTP4XzGe9BYEmIERLxwZFhsdQym3vEUicGyxF1JicydtghyTwdsicfEJFBKcKA/0%3Fwx_fmt%3Dpng)\n\nfragment.xml\n\n![](http://www.10tiao.com/img.do?url=http%3A//mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwONVq0CkCGePV0DbibArTP4Xv103lxCv271tW6Eb3gzHuMgps21JQJiaZT38VGyNYMOH9sequ4ETdTQ/0%3Fwx_fmt%3Dpng)\n\n采用以上方式后，可以发现启动速度得到很大的改观。\n\n## 启动优化一些思路\n\n*   1、避免启动页UI的过度绘制，减少UI重复绘制时间，打开设置中的GPU过度绘制开关，界面整体呈现浅色，特别复杂的界面，红色区域也不应该超过全屏幕的四分之一； \n\n*   2、主线程中的所有SharedPreference能否在非UI线程中进行，SharedPreferences的apply函数需要注意，因为Commit函数会阻塞IO，这个函数虽然执行很快，但是系统会有另外一个线程来负责写操作，当apply频率高的时候，该线程就会比较占用CPU资源。类似的还有统计埋点等，在主线程埋点但异步线程提交，频率高的情况也会出现这样的问题。 \n\n*   3、对于首次启动的黑屏问题，对于“黑屏”是否可以设计一个.9图片替换掉，间接减少用户等待时间。 \n\n*   4、对于网络错误界面，友好提示界面，使用ViewStub的方式，减少UI一次性绘制的压力。 \n\n*   5、通过下面这种方式进行懒加载\n\n   ```\n     getWindow().getDecorView()\n         .post(new Runnable() {\n               @Override\n               public void run() {\n                   myHandler.post(mLoadingRunnable);\n                }\n      });\n    ```\n"],[1,3061,"### Static Block\n\n很多代码中的Static Block，都是做一些初始化工作，特别是ContentProvider中在Static Block中初始化一些UriMatcher，这些东西可以做成懒加载模式。\n\n### Application\n\nApplication是程序的主入口，特别是很多第三方SDK都会需要在Application的onCreate里面做很多初始化操作，不得不说，各种第三方SDK，都特别喜欢这个『兵家必争之地』，再加上自己的一些库的初始化，会让整个Application不堪重负。\n\n优化的方法，无非是通过以下几个方面：\n\n*   延迟初始化\n*   后台任务\n*   界面预加载\n\n### 阻塞\n\n阻塞有很多种情况，例如磁盘IO阻塞（读写文件、SharedPerfences）、网络阻塞（现在应该不会了）以及高CPU占用的代码（加解密、渲染、解析等等）。\n\n### View层级\n\n见《Android群英传》\n\n### 耗时方法\n\n通过使用TraceView && Systrace && Method Tracing工具来进行排查，见《Android群英传:神兵利器》\n\n## App启动优化的一般过程\n\n1.  通过TraceView、Systrace来分析耗时的方法与组件。\n2.  梳理启动加载的每一个库、组件。\n3.  将梳理出来的库，按功能和需求进行划分，设计该库的启动时机。\n4.  与交互沟通，设计启动画面，按前文方法进行优化。\n\n## 解决方案\n\n### Theme\n\n当系统加载一个Activity的时候，onCreate()是一个耗时过程，那么在这个过程中，系统为了让用户能有一个比较好的体验，实际上会先绘制一些初始界面，类似于PlaceHolder。\n\n系统首先会读取当前Activity的Theme，然后根据Theme中的配置来绘制，当Activity加载完毕后，才会替换为真正的界面。所以，Google官方提供的解决方案，就是通过android:windowBackground属性，来进行加载前的配置，同时，这里不仅可以配置颜色，还能配置图片，例如，我们可以使用一个layer-list来作为android:windowBackground要显示的图：\n\nstart_window.xml\n\n```\n<layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\n            android:opacity=\"opaque\">\n    <item android:drawable=\"@android:color/darker_gray\"/>\n    <item>\n        <bitmap\n            android:gravity=\"center\"\n            android:src=\"@mipmap/ic_launcher\"/>\n    </item>\n</layer-list>\n```\n\n可以看见，这里通过layer-list来实现图片的叠加，让开发者可以自由组合。\n\n> 配置中的android:opacity=”opaque”参数是为了防止在启动的时候出现背景的闪烁。\n\n接下来可以设置一个新的Style，这个Style就是Activity预加载的Style。\n\n```\n<resources>\n\n    <!-- Base application theme. -->\n    <style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\">\n        <!-- Customize your theme here. -->\n        <item name=\"colorPrimary\">@color/colorPrimary</item>\n        <item name=\"colorPrimaryDark\">@color/colorPrimaryDark</item>\n        <item name=\"colorAccent\">@color/colorAccent</item>\n    </style>\n\n    <style name=\"StartStyle\" parent=\"AppTheme\">\n        <item name=\"android:windowBackground\">@drawable/start_window</item>\n    </style>\n</resources>\n```\n\nOK，下面在Mainifest中给Activity指定需要预加载的Style：\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n          package=\"com.xys.startperformancedemo\">\n\n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/AppTheme\">\n        <activity\n            android:name=\".MainActivity\"\n            android:theme=\"@style/StartStyle\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\"/>\n\n                <category android:name=\"android.intent.category.LAUNCHER\"/>\n            </intent-filter>\n        </activity>\n    </application>\n\n</manifest>\n```\n\n这里需要注意下，一定是Activity的Theme，而不是Application的Theme。\n\n最后，我们在Activity加载真正的界面之前，将Theme设置回正常的Theme就好了：\n\n```\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        setTheme(R.style.AppTheme);\n        super.onCreate(savedInstanceState);\n        SystemClock.sleep(2000);\n        setContentView(R.layout.activity_main);\n    }\n}\n\n```\n\n在这个Activity中，我使用SystemClock.sleep(2000)，模拟了一个Activity加载的耗时过程，在super.onCreate(savedInstanceState)调用前，将主题重新设置为原来的主题。\n\n通过这种方式设置的效果如下：\n\n![这里写图片描述](http://img.blog.csdn.net/20161105135857103)\n\n启动的时候，会先展示一个画面，这个画面就是系统解析到的Style，等Activity加载完全完毕后，才会加载Activity的界面，而在Activity的界面中，我们将主题重新设置为正常的主题，从而达到一个友好的启动体验，这种方式其实并没有真正的加速启动过程，而是通过交互体验来优化了展示的效果。\n\n### 异步初始化\n\n这个很简单，就是让App在onCreate里面尽可能的少做事情，而利用手机的多核特性，尽可能的利用多线程，例如一些第三方框架的初始化，如果能放线程，就尽量的放入线程中，最简单的，你可以直接new Thread()，当然，你也可以通过公共的线程池来进行异步的初始化工作，这个是最能够压缩启动时间的方式\n\n### 延迟初始化\n\n延迟初始化并不是减少了启动时间，而是让耗时操作让位、让资源给UI绘制，将耗时的操作延迟到UI加载完毕后，所以，这里建议通过mDecoView.post方法，来进行延迟加载，代码如下：\n\n```\ngetWindow().getDecorView().post(new Runnable() {\n\n  @Override public void run() {\n    ……\n  }\n});\n```\n\n我们的ContentView就是通过mDecoView.addView加入到根布局的，所以，通过这种方式，可以让延迟加载的内容，在ContentView初始化完毕后，再进行执行，保证了UI绘制的流畅性。\n\n### IntentService\n\nIntentService是继承于Service并处理异步请求的一个类，在IntentService的内部，有一个工作线程来处理耗时操作，启动IntentService的方式和启动传统Service一样，同时，当任务执行完后，IntentService会自动停止，而不需要去手动控制。\n\n```\npublic class InitIntentService extends IntentService {\n\n    private static final String ACTION = \"com.xys.startperformancedemo.action\";\n\n    public InitIntentService() {\n        super(\"InitIntentService\");\n    }\n\n    public static void start(Context context) {\n        Intent intent = new Intent(context, InitIntentService.class);\n        intent.setAction(ACTION);\n        context.startService(intent);\n    }\n\n    @Override\n    protected void onHandleIntent(Intent intent) {\n        SystemClock.sleep(2000);\n        Log.d(TAG, \"onHandleIntent: \");\n    }\n}\n```\n\n我们将耗时任务丢到IntentService中去处理，系统会自动开启线程去处理，同时，在任务结束后，还能自己结束Service，多么的人性化！OK，只需要在Application或者Activity的onCreate中去启动这个IntentService即可：\n\n```\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    InitIntentService.start(this);\n}\n```\n\n最后不要忘记在Mainifest注册Service。\n\n### 使用ActivityLifecycleCallbacks\n\nFramework提供的这个方法可以监控到所有Activity的生命周期，在这里，我们就可以通过onActivityCreated这样一个回调，来将一些UI相关的初始化操作放到这里，同时，通过unregisterActivityLifecycleCallbacks来避免重复的初始化。同时，这里onActivityCreated回调的参数Bundle，可以用来区别是否是被系统所回收的Activity。\n\n```\npublic class MainApplication extends Application {\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        // 初始化基本内容\n        // ……\n        registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() {\n            @Override\n            public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n                unregisterActivityLifecycleCallbacks(this);\n                // 初始化UI相关的内容\n                // ……\n            }\n\n            @Override\n            public void onActivityStarted(Activity activity) {\n            }\n\n            @Override\n            public void onActivityResumed(Activity activity) {\n            }\n\n            @Override\n            public void onActivityPaused(Activity activity) {\n            }\n\n            @Override\n            public void onActivityStopped(Activity activity) {\n            }\n\n            @Override\n            public void onActivitySaveInstanceState(Activity activity, Bundle outState) {\n            }\n\n            @Override\n            public void onActivityDestroyed(Activity activity) {\n            }\n        });\n    }\n}\n```\n\n### 资源优化\n\n有几个方面，一个自然是优化布局、布局层级，一个是优化资源，尽可能的精简资源、避免垃圾资源，这些可以通过混淆和tinyPNG这些工具来实现。\n\n## 甩锅方案\n\n下面是两种不同的方案，都是在Style中进行配置：\n\n```\n<item name=\"android:windowDisablePreview\">true</item>\n```\n\n与\n\n```\n<item name=\"android:windowIsTranslucent\">true</item>\n<item name=\"android:windowNoTitle\">true</item>\n```\n\n我们先来看看这样做的效果：\n\n![这里写图片描述](http://ac-mhke0kuv.clouddn.com/a6b118d4ade7ed6fd8f6.gif)\n\n设置效果类似，即通过取消、透明化系统的统一的加载页面来达到启动的『加速』，实际上，是一个『甩锅』的过程。强烈建议开发者不要通过这种方式去做『所谓的启动加速』,这种方式虽然看上去自己的App启动非常快，瞬间就完成了，但实际上，是将真正的启动界面给隐藏了。\n\n> 系统说：这锅，我们不背！\n\n## 无解\n\n对应5.0以下的65535问题，目前只能通过Multidex来进行处理，而在5.0以下的机器上，系统在加载前的合并Dex的过程，有可能非常长，这也是暂时无解的问题，只能希望后面Multidex进行优化。\n\nOK，App的启动优化基本如上，其重点过程，依然是分析耗时的操作，以及如何设计合理的启动顺序，希望各位能够通过文中介绍的方式来进行App的启动优化。"]],[1064,3061],[8173,8173]]],[1520244347227,["gengmei_pxf@gengmei123.local",[[-1,1464,"### View层级\n\n见《Android群英传》\n"]],[1464,1490],[1464,1464]]],[1520244347778,["gengmei_pxf@gengmei123.local",[[-1,1464,"\n"]],[1464,1464],[1463,1463]]],[1520244657204,[null,[[1,1051,")"],[-1,1053,")"]],[1051,1051],[1053,1053]]],[1520244657204,[null,[[-1,1051,")"],[1,1054,")"]],[1053,1053],[1051,1051]]],[1520244604760,["gengmei_pxf@gengmei123.local",[[-1,7734,"我们先来看看这样做的效果：\n\n![这里写图片描述](http://ac-mhke0kuv.clouddn.com/a6b118d4ade7ed6fd8f6.gif)\n\n"]],[7734,7818],[7734,7734]]],[1520244606920,["gengmei_pxf@gengmei123.local",[[-1,7733,"\n"]],[7734,7734],[7733,7733]]],[1520244630967,["gengmei_pxf@gengmei123.local",[[-1,8062,"*   6、"]],[8062,8068],[8062,8062]]],[1520244632879,["gengmei_pxf@gengmei123.local",[[-1,8074,"也"]],[8075,8075],[8074,8074]]],[1520244639382,["gengmei_pxf@gengmei123.local",[[1,8092,"\n"]],[8091,8091],[8092,8092]]],[1520244639684,["gengmei_pxf@gengmei123.local",[[1,8093,"\n"]],[8092,8092],[8093,8093]]],[1520244646285,["gengmei_pxf@gengmei123.local",[[-1,8093,"\n"],[1,8094,"## ckao"]],[8093,8093],[8100,8100]]],[1520244647134,["gengmei_pxf@gengmei123.local",[[-1,8096,"ckao"]],[8100,8100],[8096,8096]]],[1520244648647,["gengmei_pxf@gengmei123.local",[[1,8096,"ckao"]],[8096,8096],[8100,8100]]],[1520244650614,["gengmei_pxf@gengmei123.local",[[-1,8096,"ckao"]],[8100,8100],[8096,8096]]],[1520244653222,["gengmei_pxf@gengmei123.local",[[1,8096,"ckao"]],[8096,8096],[8100,8100]]],[1520244654301,["gengmei_pxf@gengmei123.local",[[-1,8096,"ckao"]],[8100,8100],[8096,8096]]],[1520244691092,[null,[[1,1051,")"],[-1,1053,")"]],[1051,1051],[1053,1053]]],[1520244691092,[null,[[-1,1051,")"],[1,1054,")"]],[1053,1053],[1051,1051]]],[1520244658127,["gengmei_pxf@gengmei123.local",[[1,8096,"参考"]],[8096,8096],[8098,8098]]],[1520244659086,["gengmei_pxf@gengmei123.local",[[1,8098,"\n\n"]],[8098,8098],[8099,8099]]],[1520244665210,["gengmei_pxf@gengmei123.local",[[-1,8099,"\n"],[1,8100,"[])"]],[8099,8099],[8102,8102]]],[1520244666193,["gengmei_pxf@gengmei123.local",[[-1,8101,")"]],[8102,8102],[8101,8101]]],[1520244666690,["gengmei_pxf@gengmei123.local",[[1,8101,"()"]],[8101,8101],[8103,8103]]],[1520244676776,["gengmei_pxf@gengmei123.local",[[1,8102,"http://blog.csdn.net/eclipsexys/article/details/53044990"]],[8102,8102],[8158,8158]]],[1520244685147,["gengmei_pxf@gengmei123.local",[[1,8100,"# 一触即发 App启动优化最佳实践"]],[8100,8100],[8118,8118]]],[1520244689190,["gengmei_pxf@gengmei123.local",[[-1,8100,"# "]],[8102,8102],[8100,8100]]],[1520245092388,[null,[[1,1051,")"],[-1,1053,")"]],[1051,1051],[1053,1053]]],[1520245092388,[null,[[-1,1051,")"],[1,1054,")"]],[1053,1053],[1051,1051]]],[1520245071676,["gengmei_pxf@gengmei123.local",[[-1,8033,"，希望各位能够通过文中介绍的方式来进行App的启动优化。"]],[8033,8061],[8033,8033]]],[1520245074847,["gengmei_pxf@gengmei123.local",[[-1,8034,"Multidex的使用，是拖慢启动速度的元凶，必须要做优化"]],[8034,8063],[8034,8034]]],[1520245075283,["gengmei_pxf@gengmei123.local",[[-1,8035,"\n"]],[8034,8034],[8033,8033]]],[1520245078499,["gengmei_pxf@gengmei123.local",[[1,7987,"\n"]],[7986,7986],[7987,7987]]],[1520245088677,["gengmei_pxf@gengmei123.local",[[1,7986,"Multidex的使用，是拖慢启动速度的元凶，必须要做优化."]],[7986,7986],[8016,8016]]],[1520245089955,["gengmei_pxf@gengmei123.local",[[-1,8015,"."]],[8016,8016],[8015,8015]]],[1520245090829,["gengmei_pxf@gengmei123.local",[[1,8015,"。"]],[8015,8015],[8016,8016]]]]]]}