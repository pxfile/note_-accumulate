{"compress":true,"commitItems":[["d7c8b18d-ac59-456c-8917-a0e182953067",1521530406181,"",[[1521530355809,["gengmei_pxf@gengmei123.local",[[1,0,"面试题总结4\n===\n\n\n"]],[0,0],[13,13]]],[1521530359688,["gengmei_pxf@gengmei123.local",[[-1,12,"\n"],[1,13,"1."]],[12,12],[14,14]]],[1521530362552,["gengmei_pxf@gengmei123.local",[[-1,12,"1."]],[14,14],[12,12]]],[1521530366161,["gengmei_pxf@gengmei123.local",[[-1,11,"\n"],[1,12,"# Java"]],[12,12],[17,17]]],[1521530366639,["gengmei_pxf@gengmei123.local",[[1,17,"\n\n"]],[17,17],[18,18]]],[1521530369105,["gengmei_pxf@gengmei123.local",[[-1,18,"\n"],[1,19,"##"]],[18,18],[20,20]]],[1521530371159,["gengmei_pxf@gengmei123.local",[[1,18,"\n"]],[18,18],[19,19]]],[1521530374471,["gengmei_pxf@gengmei123.local",[[-1,0,"面试题总结"]],[0,5],[0,0]]],[1521530377834,["gengmei_pxf@gengmei123.local",[[1,0,"ms"]],[0,0],[2,2]]],[1521530388521,["gengmei_pxf@gengmei123.local",[[1,18," 匿名内部类月"]],[18,18],[25,25]]],[1521530389574,["gengmei_pxf@gengmei123.local",[[-1,24,"月"]],[25,25],[24,24]]],[1521530397104,["gengmei_pxf@gengmei123.local",[[1,24,"与内部类的区别"]],[24,24],[31,31]]],[1521530397726,["gengmei_pxf@gengmei123.local",[[1,31,"\n\n"]],[31,31],[32,32]]],[1521530398822,["gengmei_pxf@gengmei123.local",[[1,33,"\n"]],[32,32],[33,33]]],[1521530400592,["gengmei_pxf@gengmei123.local",[[-1,33,"\n"],[1,34,"## "]],[33,33],[36,36]]],[1521530414630,["gengmei_pxf@gengmei123.local",[[-1,0,"ms4"]],[0,3],[0,0]]],[1521530425606,["gengmei_pxf@gengmei123.local",[[1,33,"hashmap"]],[33,33],[40,40]]],[1521530427076,["gengmei_pxf@gengmei123.local",[[-1,37,"map"]],[40,40],[37,37]]],[1521530433866,["gengmei_pxf@gengmei123.local",[[1,37,"Map shuju"]],[37,37],[46,46]]],[1521530434900,["gengmei_pxf@gengmei123.local",[[-1,41,"shuju"]],[46,46],[41,41]]],[1521530452732,["gengmei_pxf@gengmei123.local",[[1,41,"原理，与hashmap"]],[41,41],[52,52]]],[1521530453603,["gengmei_pxf@gengmei123.local",[[-1,49,"map"]],[52,52],[49,49]]],[1521530464789,["gengmei_pxf@gengmei123.local",[[1,49,"Map类似的线程"]],[49,49],[57,57]]],[1521530470717,["gengmei_pxf@gengmei123.local",[[1,57,"安全的数据集合"]],[57,57],[64,64]]],[1521530474458,["gengmei_pxf@gengmei123.local",[[1,64,"\n\n"]],[64,64],[65,65]]],[1521530474786,["gengmei_pxf@gengmei123.local",[[1,66,"\n"]],[65,65],[66,66]]],[1521530496320,["gengmei_pxf@gengmei123.local",[[-1,66,"\n"],[1,67,"## JAVA/Android 多线程实现方式及并发与同步"]],[66,66],[95,95]]],[1521530501247,["gengmei_pxf@gengmei123.local",[[1,95,"\n\n"]],[95,95],[96,96]]],[1521530502401,["gengmei_pxf@gengmei123.local",[[-1,96,"\n"],[1,97,"（）"]],[96,96],[98,98]]],[1521530523481,["gengmei_pxf@gengmei123.local",[[1,97,"引申syn"]],[97,97],[102,102]]],[1521530527270,["gengmei_pxf@gengmei123.local",[[-1,99,"syn"]],[102,102],[99,99]]],[1521530535662,["gengmei_pxf@gengmei123.local",[[1,99,"synchronize的使用\n\n"]],[99,99],[115,115]]],[1521530536046,["gengmei_pxf@gengmei123.local",[[1,116,"\n"]],[115,115],[116,116]]],[1521530537760,["gengmei_pxf@gengmei123.local",[[-1,116,"\n"],[1,117,"## "]],[116,116],[119,119]]],[1521530612458,[null,[[1,113,"）"],[-1,115,"）"]],[113,113],[115,115]]],[1521530612458,[null,[[-1,113,"）"],[1,116,"）"]],[115,115],[113,113]]],[1521530585885,["gengmei_pxf@gengmei123.local",[[1,30,"\n"]],[28,28],[29,29]]],[1521530586093,["gengmei_pxf@gengmei123.local",[[1,31,"\n"]],[29,29],[30,30]]],[1521530597415,["gengmei_pxf@gengmei123.local",[[1,30,"## 静态类"]],[30,30],[36,36]]],[1521530599757,["gengmei_pxf@gengmei123.local",[[-1,35,"类"]],[36,36],[35,35]]],[1521530604160,["gengmei_pxf@gengmei123.local",[[1,35,"与非建泰"]],[35,35],[39,39]]],[1521530604764,["gengmei_pxf@gengmei123.local",[[-1,37,"建泰"]],[39,39],[37,37]]],[1521530609943,["gengmei_pxf@gengmei123.local",[[1,37,"静态"]],[37,37],[39,39]]],[1521530672464,[null,[[1,124,"）"],[-1,126,"）"]],[124,124],[126,126]]],[1521530672464,[null,[[-1,124,"）"],[1,127,"）"]],[126,126],[124,124]]],[1521530648484,["gengmei_pxf@gengmei123.local",[[1,130,"Android中的设计模式"]],[130,130],[143,143]]],[1521530649178,["gengmei_pxf@gengmei123.local",[[1,143,"\n\n"]],[143,143],[144,144]]],[1521530649860,["gengmei_pxf@gengmei123.local",[[-1,144,"\n"],[1,145,"（）"]],[144,144],[146,146]]],[1521530658908,["gengmei_pxf@gengmei123.local",[[1,145,"builder 创建"]],[145,145],[155,155]]],[1521530732461,[null,[[1,124,"）"],[-1,126,"）"]],[124,124],[126,126]]],[1521530732461,[null,[[-1,124,"）"],[1,127,"）"]],[126,126],[124,124]]],[1521530695680,["gengmei_pxf@gengmei123.local",[[1,155,"模式设计的好处是啥\n\n"]],[155,155],[166,166]]],[1521530696136,["gengmei_pxf@gengmei123.local",[[1,167,"\n"]],[166,166],[167,167]]],[1521530697584,["gengmei_pxf@gengmei123.local",[[-1,167,"\n"],[1,168,"## "]],[167,167],[170,170]]],[1521530716364,["gengmei_pxf@gengmei123.local",[[1,121,"，volatile"]],[121,121],[130,130]]],[1521530732239,["gengmei_pxf@gengmei123.local",[[1,179,"对象的"]],[179,179],[182,182]]],[1521530792463,[null,[[1,133,"）"],[-1,135,"）"],[1,173,"）"],[-1,175,"）"]],[133,133],[175,175]]],[1521530792463,[null,[[-1,133,"）"],[1,136,"）"],[-1,173,"）"],[1,176,"）"]],[175,175],[133,133]]],[1521530733670,["gengmei_pxf@gengmei123.local",[[1,182,"应用"]],[182,182],[184,184]]],[1521530736764,["gengmei_pxf@gengmei123.local",[[-1,5,"# Java"]],[5,11],[5,5]]],[1521530737380,["gengmei_pxf@gengmei123.local",[[-1,6,"\n"]],[5,5],[4,4]]],[1521530739636,["gengmei_pxf@gengmei123.local",[[-1,175,"应用"]],[177,177],[175,175]]],[1521530747015,["gengmei_pxf@gengmei123.local",[[1,175,"引用"]],[175,175],[177,177]]],[1521530747939,["gengmei_pxf@gengmei123.local",[[1,177,"\n\n"]],[177,177],[178,178]]],[1521530748372,["gengmei_pxf@gengmei123.local",[[1,179,"\n"]],[178,178],[179,179]]],[1521530755271,["gengmei_pxf@gengmei123.local",[[1,169,"\n"]],[167,167],[168,168]]],[1521530755599,["gengmei_pxf@gengmei123.local",[[1,170,"\n"]],[168,168],[169,169]]],[1521530763433,["gengmei_pxf@gengmei123.local",[[1,169,"## Activity的启动模式"]],[169,169],[185,185]]],[1521530765517,["gengmei_pxf@gengmei123.local",[[1,198,"\n"]],[196,196],[197,197]]],[1521530773905,["gengmei_pxf@gengmei123.local",[[1,197,"## Service的创建方式"]],[197,197],[212,212]]],[1521530774638,["gengmei_pxf@gengmei123.local",[[1,214,"\n"]],[212,212],[213,213]]],[1521530775344,["gengmei_pxf@gengmei123.local",[[1,213,"（）"]],[213,213],[215,215]]],[1521530791160,["gengmei_pxf@gengmei123.local",[[1,214,"Service bind创建，没有unbind这么"]],[214,214],[239,239]]],[1521530791966,["gengmei_pxf@gengmei123.local",[[-1,237,"这么"]],[239,239],[237,237]]],[1521530852464,[null,[[1,126,"）"],[-1,128,"）"],[1,166,"）"],[-1,168,"）"]],[126,126],[168,168]]],[1521530852464,[null,[[-1,126,"）"],[1,129,"）"],[-1,166,"）"],[1,169,"）"]],[168,168],[126,126]]],[1521530794565,["gengmei_pxf@gengmei123.local",[[1,237,"怎么退出"]],[237,237],[241,241]]],[1521530796516,["gengmei_pxf@gengmei123.local",[[-1,239,"退出"]],[241,241],[239,239]]],[1521530804264,["gengmei_pxf@gengmei123.local",[[1,239,"关闭Service"]],[239,239],[248,248]]],[1521530805732,["gengmei_pxf@gengmei123.local",[[1,251,"\n"]],[249,249],[250,250]]],[1521530806101,["gengmei_pxf@gengmei123.local",[[1,252,"\n"]],[250,250],[251,251]]],[1521530821601,["gengmei_pxf@gengmei123.local",[[1,251,"## View的绘制流程"]],[251,251],[263,263]]],[1521530822559,["gengmei_pxf@gengmei123.local",[[1,265,"\n"]],[263,263],[264,264]]],[1521530823469,["gengmei_pxf@gengmei123.local",[[1,266,"\n"]],[264,264],[265,265]]],[1521530832871,["gengmei_pxf@gengmei123.local",[[1,265,"## View的时间流程"]],[265,265],[277,277]]],[1521530834110,["gengmei_pxf@gengmei123.local",[[-1,273,"时间流程"]],[277,277],[273,273]]],[1521530837360,["gengmei_pxf@gengmei123.local",[[1,273,"事件流程"]],[273,273],[277,277]]],[1521530837732,["gengmei_pxf@gengmei123.local",[[1,279,"\n"]],[277,277],[278,278]]],[1521530838556,["gengmei_pxf@gengmei123.local",[[1,278,"（）"]],[278,278],[280,280]]],[1521530844873,["gengmei_pxf@gengmei123.local",[[1,279,"具体出"]],[279,279],[282,282]]],[1521530847422,["gengmei_pxf@gengmei123.local",[[-1,281,"出"]],[282,282],[281,281]]],[1521530850680,["gengmei_pxf@gengmei123.local",[[1,281,"题目是 "]],[281,281],[285,285]]],[1521530912465,[null,[[1,126,"）"],[-1,128,"）"],[1,166,"）"],[-1,168,"）"]],[126,126],[168,168]]],[1521530912465,[null,[[-1,126,"）"],[1,129,"）"],[-1,166,"）"],[1,169,"）"]],[168,168],[126,126]]],[1521530860280,["gengmei_pxf@gengmei123.local",[[1,285,"一个frameLayout钟"]],[285,285],[299,299]]],[1521530861428,["gengmei_pxf@gengmei123.local",[[-1,298,"钟"]],[299,299],[298,298]]],[1521530899174,["gengmei_pxf@gengmei123.local",[[1,298,"中有1到6个View叠加，点击第三个View时，调用‘’"]],[298,298],[326,326]]],[1521530899932,["gengmei_pxf@gengmei123.local",[[-1,324,"‘’"]],[326,326],[324,324]]],[1521530900759,["gengmei_pxf@gengmei123.local",[[1,324,"``"]],[324,324],[326,326]]],[1521530912388,["gengmei_pxf@gengmei123.local",[[1,325,"dispatchTouch"]],[325,325],[338,338]]],[1521530972467,[null,[[1,126,"）"],[-1,128,"）"],[1,166,"）"],[-1,168,"）"]],[126,126],[168,168]]],[1521530972468,[null,[[-1,126,"）"],[1,129,"）"],[-1,166,"）"],[1,169,"）"]],[168,168],[126,126]]],[1521530916774,["gengmei_pxf@gengmei123.local",[[1,338,"Event()"]],[338,338],[345,345]]],[1521530917987,["gengmei_pxf@gengmei123.local",[[1,344,"e"]],[344,344],[345,345]]],[1521530921125,["gengmei_pxf@gengmei123.local",[[1,346,"{]"]],[346,346],[348,348]]],[1521530922107,["gengmei_pxf@gengmei123.local",[[-1,347,"]"]],[348,348],[347,347]]],[1521530922498,["gengmei_pxf@gengmei123.local",[[1,347,"\n"]],[347,347],[348,348]]],[1521530923219,["gengmei_pxf@gengmei123.local",[[1,348,"\n"]],[348,348],[349,349]]],[1521530925579,["gengmei_pxf@gengmei123.local",[[1,349,"\n"]],[348,348],[349,349]]],[1521530926005,["gengmei_pxf@gengmei123.local",[[1,349,"}"]],[349,349],[350,350]]],[1521530929395,["gengmei_pxf@gengmei123.local",[[1,352,"\n"]],[352,352],[353,353]]],[1521530933747,["gengmei_pxf@gengmei123.local",[[1,324,"\n"]],[324,324],[325,325]]],[1521530935843,["gengmei_pxf@gengmei123.local",[[-1,325,"`"]],[326,326],[325,325]]],[1521530936786,["gengmei_pxf@gengmei123.local",[[1,325,"\n"]],[325,325],[326,326]]],[1521530938348,["gengmei_pxf@gengmei123.local",[[1,325,"```"]],[325,325],[328,328]]],[1521530942386,["gengmei_pxf@gengmei123.local",[[-1,278,"（"]],[279,279],[278,278]]],[1521530944668,["gengmei_pxf@gengmei123.local",[[1,355,"``"]],[355,355],[357,357]]],[1521530960964,["gengmei_pxf@gengmei123.local",[[1,351,"\tsuper.dispatchTouchEvent()"]],[351,351],[378,378]]],[1521530962075,["gengmei_pxf@gengmei123.local",[[1,377,"e"]],[377,377],[378,378]]],[1521530963124,["gengmei_pxf@gengmei123.local",[[1,379,";"]],[379,379],[380,380]]],[1521530963352,["gengmei_pxf@gengmei123.local",[[1,381,"\n"]],[380,380],[381,381]]],[1521530965994,["gengmei_pxf@gengmei123.local",[[1,381,"\ttr"]],[381,381],[384,384]]],[1521530966585,["gengmei_pxf@gengmei123.local",[[-1,382,"tr"]],[384,384],[382,382]]],[1521530970956,["gengmei_pxf@gengmei123.local",[[1,382,"return true;"]],[382,382],[394,394]]],[1521531032472,[null,[[1,126,"）"],[-1,128,"）"],[1,166,"）"],[-1,168,"）"]],[126,126],[168,168]]],[1521531032472,[null,[[-1,126,"）"],[1,129,"）"],[-1,166,"）"],[1,169,"）"]],[168,168],[126,126]]],[1521530972840,["gengmei_pxf@gengmei123.local",[[-1,399,"`"]],[400,400],[399,399]]],[1521530975811,["gengmei_pxf@gengmei123.local",[[1,399,"`"]],[399,399],[400,400]]],[1521530978145,["gengmei_pxf@gengmei123.local",[[-1,403,"\n"]],[403,403],[402,402]]],[1521530978506,["gengmei_pxf@gengmei123.local",[[-1,401,"）"]],[402,402],[401,401]]],[1521530987644,["gengmei_pxf@gengmei123.local",[[-1,313,"三"],[1,314,"3"]],[313,314],[314,314]]],[1521530990986,["gengmei_pxf@gengmei123.local",[[-1,401,"\n"],[1,402,"zu"]],[401,401],[403,403]]],[1521530991793,["gengmei_pxf@gengmei123.local",[[-1,402,"u"]],[403,403],[402,402]]],[1521530992057,["gengmei_pxf@gengmei123.local",[[-1,401,"z"],[1,402,"\n"]],[402,402],[401,401]]],[1521530993931,["gengmei_pxf@gengmei123.local",[[-1,401,"\n"],[1,402,"最后"]],[401,401],[403,403]]],[1521530994425,["gengmei_pxf@gengmei123.local",[[-1,402,"后"]],[403,403],[402,402]]],[1521530994567,["gengmei_pxf@gengmei123.local",[[-1,401,"最"],[1,402,"\n"]],[402,402],[401,401]]],[1521530997099,["gengmei_pxf@gengmei123.local",[[-1,401,"\n"]],[401,401],[0,0]]],[1521530997762,["gengmei_pxf@gengmei123.local",[[-1,400,"\n"],[1,401,"z"]],[0,0],[400,401]]],[1521530998038,["gengmei_pxf@gengmei123.local",[[1,401,"e"]],[400,401],[400,402]]],[1521530998227,["gengmei_pxf@gengmei123.local",[[1,402,"n"]],[400,402],[400,403]]],[1521530998359,["gengmei_pxf@gengmei123.local",[[1,403,"g"]],[400,403],[400,404]]],[1521530998559,["gengmei_pxf@gengmei123.local",[[1,404,"'g"]],[400,404],[400,406]]],[1521530998676,["gengmei_pxf@gengmei123.local",[[1,406,"e"]],[400,406],[400,407]]],[1521530999408,["gengmei_pxf@gengmei123.local",[[-1,406,"e"]],[400,407],[400,406]]],[1521530999559,["gengmei_pxf@gengmei123.local",[[-1,404,"'g"]],[400,406],[400,404]]],[1521530999705,["gengmei_pxf@gengmei123.local",[[-1,403,"g"]],[400,404],[400,403]]],[1521530999875,["gengmei_pxf@gengmei123.local",[[-1,402,"n"]],[400,403],[400,402]]],[1521531000339,["gengmei_pxf@gengmei123.local",[[-1,400,"ez"]],[400,402],[400,400]]],[1521531000736,["gengmei_pxf@gengmei123.local",[[1,400,"\n\n"]],[400,400],[401,401]]],[1521531014629,["gengmei_pxf@gengmei123.local",[[-1,401,"\n"],[1,402,"整个事件的传递机制"]],[401,401],[410,410]]],[1521531023899,["gengmei_pxf@gengmei123.local",[[1,401,"说下"]],[401,401],[403,403]]],[1521531026178,["gengmei_pxf@gengmei123.local",[[1,412,"\n\n"]],[412,412],[413,413]]],[1521531026393,["gengmei_pxf@gengmei123.local",[[1,414,"\n"]],[413,413],[414,414]]],[1521531031962,["gengmei_pxf@gengmei123.local",[[-1,414,"\n"],[1,415,"##"]],[414,414],[416,416]]],[1521531092475,[null,[[1,126,"）"],[-1,128,"）"],[1,166,"）"],[-1,168,"）"]],[126,126],[168,168]]],[1521531092475,[null,[[-1,126,"）"],[1,129,"）"],[-1,166,"）"],[1,169,"）"]],[168,168],[126,126]]],[1521531032591,["gengmei_pxf@gengmei123.local",[[1,416," "]],[416,416],[417,417]]],[1521531033703,["gengmei_pxf@gengmei123.local",[[1,414,"\n"]],[413,413],[414,414]]],[1521531152477,[null,[[1,126,"）"],[-1,128,"）"],[1,166,"）"],[-1,168,"）"]],[126,126],[168,168]]],[1521531152477,[null,[[-1,126,"）"],[1,129,"）"],[-1,166,"）"],[1,169,"）"]],[168,168],[126,126]]],[1521531112194,["gengmei_pxf@gengmei123.local",[[1,412,"（）"]],[412,412],[414,414]]],[1521531132945,["gengmei_pxf@gengmei123.local",[[1,413,"事件会不会继续往下传，还是就消费了"]],[413,413],[430,430]]],[1521531134462,["gengmei_pxf@gengmei123.local",[[1,434,"\n"]],[431,431],[432,432]]],[1521531137960,["gengmei_pxf@gengmei123.local",[[1,432,"****"]],[432,432],[436,436]]],[1521531140856,["gengmei_pxf@gengmei123.local",[[1,434,"答案"]],[434,434],[436,436]]],[1521531151558,["gengmei_pxf@gengmei123.local",[[1,438,"：调用super（）"]],[438,438],[448,448]]],[1521531212476,[null,[[1,126,"）"],[-1,128,"）"],[1,166,"）"],[-1,168,"）"]],[126,126],[168,168]]],[1521531212476,[null,[[-1,126,"）"],[1,129,"）"],[-1,166,"）"],[1,169,"）"]],[168,168],[126,126]]],[1521531195983,["gengmei_pxf@gengmei123.local",[[1,448,"里面还会调用很多子类的dispatchTouchEvent方法，所以事件会继续往下传"]],[448,448],[490,490]]],[1521531200124,["gengmei_pxf@gengmei123.local",[[-1,492,"\n"]],[492,492],[491,491]]],[1521531212163,["gengmei_pxf@gengmei123.local",[[1,495,"MVC"]],[495,495],[498,498]]],[1521531272478,[null,[[1,126,"）"],[-1,128,"）"],[1,166,"）"],[-1,168,"）"]],[126,126],[168,168]]],[1521531272478,[null,[[-1,126,"）"],[1,129,"）"],[-1,166,"）"],[1,169,"）"]],[168,168],[126,126]]],[1521531215043,["gengmei_pxf@gengmei123.local",[[1,498,"与MVVM"]],[498,498],[503,503]]],[1521531222400,["gengmei_pxf@gengmei123.local",[[1,498,"，MVP"]],[498,498],[502,502]]],[1521531225506,["gengmei_pxf@gengmei123.local",[[1,507,"模式"]],[507,507],[509,509]]],[1521531226960,["gengmei_pxf@gengmei123.local",[[1,509,"\n\n"]],[509,509],[510,510]]],[1521531239869,["gengmei_pxf@gengmei123.local",[[-1,510,"\n"],[1,511,"为什么选择这种模式"]],[510,510],[519,519]]],[1521531242757,["gengmei_pxf@gengmei123.local",[[1,519,"\n\n"]],[519,519],[520,520]]],[1521531243141,["gengmei_pxf@gengmei123.local",[[1,521,"\n"]],[520,520],[521,521]]],[1521531292791,[null,[[1,126,"）"],[-1,128,"）"],[1,166,"）"],[-1,168,"）"]],[126,126],[168,168]]],[1521531292791,[null,[[-1,126,"）"],[1,129,"）"],[-1,166,"）"],[1,169,"）"]],[168,168],[126,126]]],[1521531278778,["gengmei_pxf@gengmei123.local",[[-1,521,"\n"],[1,522,"## 算法（）"]],[521,521],[528,528]]],[1521531286474,["gengmei_pxf@gengmei123.local",[[1,527,"不规则二叉树的高度"]],[527,527],[536,536]]],[1521531290058,["gengmei_pxf@gengmei123.local",[[1,527,"求"]],[527,527],[528,528]]],[1521531494055,[null,[[1,126,"）"],[-1,128,"）"],[1,166,"）"],[-1,168,"）"]],[126,126],[168,168]]],[1521531494055,[null,[[-1,126,"）"],[1,129,"）"],[-1,166,"）"],[1,169,"）"]],[168,168],[126,126]]],[1521531476264,["gengmei_pxf@gengmei123.local",[[1,129,"\n"]],[127,127],[128,128]]],[1521531476971,["gengmei_pxf@gengmei123.local",[[1,128,"【】"]],[128,128],[130,130]]],[1521531477848,["gengmei_pxf@gengmei123.local",[[-1,128,"【】"]],[130,130],[128,128]]],[1521531479434,["gengmei_pxf@gengmei123.local",[[1,128,"[]()"]],[128,128],[132,132]]],[1521531481251,["gengmei_pxf@gengmei123.local",[[1,129,"# JAVA\\Android 多线程实现方式及并发与同步"]],[129,129],[157,157]]],[1521531484439,["gengmei_pxf@gengmei123.local",[[-1,129,"# "]],[131,131],[129,129]]],[1521531490834,["gengmei_pxf@gengmei123.local",[[1,157,"http://blog.csdn.net/csdn_aiyang/article/details/65442540"]],[157,157],[214,214]]],[1521531492896,["gengmei_pxf@gengmei123.local",[[1,128,"\n"]],[128,128],[129,129]]],[1521534949032,[null,[[-1,126,"\n"],[1,127,"）"],[-1,216,"）"],[1,217,"\n"],[1,255,"）"],[-1,257,"）"]],[126,126],[257,257]]],[1521534949032,[null,[[1,126,"\n"],[-1,126,"）"],[1,216,"）"],[-1,216,"\n"],[-1,255,"）"],[1,258,"）"]],[257,257],[126,126]]],[1521534937820,["gengmei_pxf@gengmei123.local",[[1,34,"\n"]],[32,32],[33,33]]],[1521534938377,["gengmei_pxf@gengmei123.local",[[1,33,"# [java静态与非静态区别](http://www.cnblogs.com/itdev/p/5665531.html)\n\n这里的静态，指以static关键字修饰的，包括类，方法，块，字段。\n\n非静态，指没有用static 修饰的。\n\n静态有一些特点：\n\n1.全局唯一，任何一次的修改都是全局性的影响\n\n2.只加载一次，优先于非静态\n\n3.使用方式上不依赖于实例对象。\n\n4.生命周期属于类级别，从JVM 加载开始到JVM卸载结束。\n\n可参考 ：http://blog.csdn.net/zhandoushi1982/article/details/8453522/。\n\n关于静态内部类（嵌套类）和非静态内部类的区别，可参考：\n\nhttp://www.jb51.net/article/74838.htm\n\n（1）内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。\n\n（2）非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。\n\n（3）一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。"]],[33,33],[546,546]]],[1521534940499,["gengmei_pxf@gengmei123.local",[[-1,33,"# "]],[35,35],[33,33]]],[1521535009023,[null,[[-1,638,"\n"],[1,639,"）"],[-1,728,"）"],[1,729,"\n"],[1,767,"）"],[-1,769,"）"]],[638,638],[769,769]]],[1521535009023,[null,[[1,638,"\n"],[-1,638,"）"],[1,728,"）"],[-1,728,"\n"],[-1,767,"）"],[1,770,"）"]],[769,769],[638,638]]],[1521534964739,["gengmei_pxf@gengmei123.local",[[-1,250,"可参考 ：http://blog.csdn.net/zhandoushi1982/article/details/8453522/。\n\n关于静态内部类（嵌套类）和非静态内部类的区别，可参考：\n\nhttp://www.jb51.net/article/74838.htm"]],[250,384],[250,250]]],[1521534965314,["gengmei_pxf@gengmei123.local",[[-1,251,"\n"]],[250,250],[249,249]]],[1521534965866,["gengmei_pxf@gengmei123.local",[[-1,250,"\n"]],[249,249],[248,248]]],[1521534968666,["gengmei_pxf@gengmei123.local",[[1,250,"\n"]],[248,248],[249,249]]],[1521534969481,["gengmei_pxf@gengmei123.local",[[1,251,"\n"]],[249,249],[250,250]]],[1521534970156,["gengmei_pxf@gengmei123.local",[[1,250,"可参考 ：http://blog.csdn.net/zhandoushi1982/article/details/8453522/。\n\n关于静态内部类（嵌套类）和非静态内部类的区别，可参考：\n\nhttp://www.jb51.net/article/74838.htm"]],[250,250],[250,384]]],[1521534973658,["gengmei_pxf@gengmei123.local",[[-1,250,"可参考 ：http://blog.csdn.net/zhandoushi1982/article/details/8453522/。\n\n"]],[250,318],[250,250]]],[1521534979586,["gengmei_pxf@gengmei123.local",[[-1,272,"，可参考：\n\nhttp://www.jb51.net/article/74838.htm"]],[272,316],[272,272]]],[1521534987362,["gengmei_pxf@gengmei123.local",[[-1,128,"\n"]],[128,128],[127,127]]],[1521534989375,["gengmei_pxf@gengmei123.local",[[-1,148,"\n"]],[148,148],[147,147]]],[1521534990418,["gengmei_pxf@gengmei123.local",[[1,148,"\n"]],[147,147],[148,148]]],[1521534992777,["gengmei_pxf@gengmei123.local",[[1,149,"### "]],[149,149],[153,153]]],[1521534996979,["gengmei_pxf@gengmei123.local",[[1,253,"### "]],[253,253],[257,257]]],[1521535006832,["gengmei_pxf@gengmei123.local",[[1,163,"* "]],[163,163],[165,165]]],[1521535020546,[null,[[-1,535,"\n"],[1,536,"）"],[-1,625,"）"],[1,626,"\n"],[1,664,"）"],[-1,666,"）"]],[535,535],[666,666]]],[1521535020546,[null,[[1,535,"\n"],[-1,535,"）"],[1,625,"）"],[-1,625,"\n"],[-1,664,"）"],[1,667,"）"]],[666,666],[535,535]]],[1521535009936,["gengmei_pxf@gengmei123.local",[[1,189,"* "]],[189,189],[191,191]]],[1521535010635,["gengmei_pxf@gengmei123.local",[[1,207,"* "]],[207,207],[209,209]]],[1521535011787,["gengmei_pxf@gengmei123.local",[[1,227,"* "]],[227,227],[229,229]]],[1521535014107,["gengmei_pxf@gengmei123.local",[[1,289,"* "]],[289,289],[291,291]]],[1521535015386,["gengmei_pxf@gengmei123.local",[[1,333,"* "]],[333,333],[335,335]]],[1521535016987,["gengmei_pxf@gengmei123.local",[[1,394,"* "]],[394,394],[396,396]]]]],["ed3b9847-636e-416e-85e6-dd1eb385797e",1521535529682,"\n===\n\n## 匿名内部类与内部类的区别\n\n## 静态与非静态\n[java静态与非静态区别](http://www.cnblogs.com/itdev/p/5665531.html)\n\n这里的静态，指以static关键字修饰的，包括类，方法，块，字段。\n非静态，指没有用static 修饰的。\n\n### 静态有一些特点：\n\n* 1.全局唯一，任何一次的修改都是全局性的影响\n\n* 2.只加载一次，优先于非静态\n\n* 3.使用方式上不依赖于实例对象。\n\n* 4.生命周期属于类级别，从JVM 加载开始到JVM卸载结束。\n\n### 关于静态内部类（嵌套类）和非静态内部类的区别\n\n* （1）内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。\n\n* （2）非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。\n\n* （3）一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。\n\n## hashMap 原理，与hashMap类似的线程安全的数据集合\n\n## JAVA/Android 多线程实现方式及并发与同步\n（引申synchronize，volatile的使用）\n\n[JAVA\\Android 多线程实现方式及并发与同步](http://blog.csdn.net/csdn_aiyang/article/details/65442540)\n\n## Android中的设计模式\n（builder 创建模式设计的好处是啥）\n\n## Activity的启动模式\n\n## 对象的引用\n\n## Service的创建方式\n（Service bind创建，没有unbind怎么关闭Service）\n\n## View的绘制流程\n\n## View的事件流程\n具体题目是 一个frameLayout中有1到6个View叠加，点击第3个View时，调用\n```\ndispatchTouchEvent(e){\n\tsuper.dispatchTouchEvent(e);\n\treturn true;\n}\n```\n说下整个事件的传递机制（事件会不会继续往下传，还是就消费了）\n**答案**：调用super（）里面还会调用很多子类的dispatchTouchEvent方法，所以事件会继续往下传\n\n## MVC，MVP与MVVM模式\n为什么选择这种模式\n\n## 算法（求不规则二叉树的高度）",[[1521535524963,["gengmei_pxf@gengmei123.local",[[1,491,"\n"]],[489,489],[490,490]]],[1521535525258,["gengmei_pxf@gengmei123.local",[[1,492,"\n"]],[490,490],[491,491]]],[1521535525968,["gengmei_pxf@gengmei123.local",[[1,491,"## HashMap实现原理要点概括\n\n参考文献：[http://zhangshixi.iteye.com/blog/672697](http://zhangshixi.iteye.com/blog/672697) \n参考文献：[http://blog.csdn.net/lizhongkaide/article/details/50595719](http://blog.csdn.net/lizhongkaide/article/details/50595719)\n\n1.  HashMap是基于哈希表的Map接口的非同步实现，允许使用null值和null键，但不保证映射的顺序。\n2.  底层使用数组实现，数组中每一项是个单向链表，即数组和链表的结合体；当链表长度大于一定阈值时，链表转换为红黑树，这样减少链表查询时间。\n3.  HashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Node对象。HashMap底层采用一个Node[]数组来保存所有的key-value对，当需要存储一个Node对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Node时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Node。\n4.  HashMap进行数组扩容需要重新计算扩容后每个元素在数组中的位置，很耗性能\n5.  采用了Fail-Fast机制，通过一个modCount值记录修改次数，对HashMap内容的修改都将增加这个值。迭代器初始化过程中会将这个值赋给迭代器的expectedModCount，在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map，马上抛出异常\n\n## Hashtable实现原理要点概括\n\n参考文献：[http://blog.csdn.net/zheng0518/article/details/42199477](http://blog.csdn.net/zheng0518/article/details/42199477)\n\n1.  Hashtable是基于哈希表的Map接口的同步实现，不允许使用null值和null键\n2.  底层使用数组实现，数组中每一项是个单链表，即数组和链表的结合体\n3.  Hashtable在底层将key-value当成一个整体进行处理，这个整体就是一个Entry对象。Hashtable底层采用一个Entry[]数组来保存所有的key-value对，当需要存储一个Entry对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。\n4.  synchronized是针对整张Hash表的，即每次锁住整张表让线程独占\n\n## ConcurrentHashMap实现原理要点概括\n\n参考文献：[http://blog.csdn.net/zheng0518/article/details/42199477](http://blog.csdn.net/zheng0518/article/details/42199477)\n\n1.  ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。\n2.  它使用了多个锁来控制对hash表的不同段进行的修改，每个段其实就是一个小的hashtable，它们有自己的锁。只要多个并发发生在不同的段上，它们就可以并发进行。\n3.  ConcurrentHashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Entry对象。Hashtable底层采用一个Entry[]数组来保存所有的key-value对，当需要存储一个Entry对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。\n4.  与HashMap不同的是，ConcurrentHashMap使用多个子Hash表，也就是段(Segment)\n5.  ConcurrentHashMap完全允许多个读操作并发进行，读操作并不需要加锁。如果使用传统的技术，如HashMap中的实现，如果允许可以在hash链的中间添加或删除元素，读操作不加锁将得到不一致的数据。ConcurrentHashMap实现技术是保证HashEntry几乎是不可变的。\n\n## HashSet实现原理要点概括\n\n参考文献：[http://zhangshixi.iteye.com/blog/673143l](http://zhangshixi.iteye.com/blog/673143)\n\n1.  HashSet由哈希表(实际上是一个HashMap实例)支持，不保证set的迭代顺序，并允许使用null元素。\n2.  基于HashMap实现，API也是对HashMap的行为进行了封装，可参考HashMap\n\n## LinkedHashMap实现原理要点概括\n\n参考文献：[http://zhangshixi.iteye.com/blog/673789l](http://zhangshixi.iteye.com/blog/673789)\n\n1.  LinkedHashMap继承于HashMap，底层使用哈希表和双向链表来保存所有元素，并且它是非同步，允许使用null值和null键。\n2.  基本操作与父类HashMap相似，通过重写HashMap相关方法，重新定义了数组中保存的元素Entry，来实现自己的链接列表特性。该Entry除了保存当前对象的引用外，还保存了其上一个元素before和下一个元素after的引用，从而构成了双向链接列表。"]],[491,491],[3084,3084]]],[1521535528725,["gengmei_pxf@gengmei123.local",[[1,493,"#"],[-1,598," "],[1,599," "]],[491,491],[492,492]]],[1521535534842,["gengmei_pxf@gengmei123.local",[[1,1297,"#"]],[1295,1295],[1296,1296]]],[1521535538524,["gengmei_pxf@gengmei123.local",[[1,1807,"#"]],[1805,1805],[1806,1806]]],[1521535545866,["gengmei_pxf@gengmei123.local",[[-1,2547,"## HashSet实现原理要点概括\n\n参考文献：[http://zhangshixi.iteye.com/blog/673143l](http://zhangshixi.iteye.com/blog/673143)\n\n1.  HashSet由哈希表(实际上是一个HashMap实例)支持，不保证set的迭代顺序，并允许使用null元素。\n2.  基于HashMap实现，API也是对HashMap的行为进行了封装，可参考HashMap"]],[2547,2765],[2547,2547]]],[1521535546254,["gengmei_pxf@gengmei123.local",[[-1,2548,"\n"]],[2547,2547],[2546,2546]]],[1521535546751,["gengmei_pxf@gengmei123.local",[[-1,2547,"\n"]],[2546,2546],[2545,2545]]],[1521535549243,["gengmei_pxf@gengmei123.local",[[1,2549,"#"]],[2548,2548],[2549,2549]]],[1521535569473,["gengmei_pxf@gengmei123.local",[[1,728,"* "]],[728,728],[730,730]]],[1521535575031,["gengmei_pxf@gengmei123.local",[[1,787,"\n"]],[787,787],[788,788]]],[1521535575682,["gengmei_pxf@gengmei123.local",[[1,788,"* "]],[788,788],[790,790]]],[1521535578257,["gengmei_pxf@gengmei123.local",[[1,861,"\n"]],[861,861],[862,862]]],[1521535578545,["gengmei_pxf@gengmei123.local",[[1,862,"* "]],[862,862],[864,864]]],[1521535581534,["gengmei_pxf@gengmei123.local",[[1,1094,"\n"]],[1094,1094],[1095,1095]]],[1521535581817,["gengmei_pxf@gengmei123.local",[[1,1095,"* "]],[1095,1095],[1097,1097]]],[1521535583903,["gengmei_pxf@gengmei123.local",[[1,1140,"\n"]],[1140,1140],[1141,1141]]],[1521535584201,["gengmei_pxf@gengmei123.local",[[1,1141,"* "]],[1141,1141],[1143,1143]]],[1521535589626,["gengmei_pxf@gengmei123.local",[[1,1453,"* "]],[1453,1453],[1455,1455]]],[1521535592129,["gengmei_pxf@gengmei123.local",[[1,1503,"* "]],[1503,1503],[1505,1505]]],[1521535594054,["gengmei_pxf@gengmei123.local",[[1,1503,"\n"]],[1503,1503],[1504,1504]]],[1521535594983,["gengmei_pxf@gengmei123.local",[[1,1542,"\n"]],[1542,1542],[1543,1543]]],[1521535595768,["gengmei_pxf@gengmei123.local",[[1,1543,"* "]],[1543,1543],[1545,1545]]],[1521535599409,["gengmei_pxf@gengmei123.local",[[1,1784,"\n"]],[1784,1784],[1785,1785]]],[1521535599737,["gengmei_pxf@gengmei123.local",[[1,1785,"* "]],[1785,1785],[1787,1787]]],[1521535604729,["gengmei_pxf@gengmei123.local",[[1,1982,"* "]],[1982,1982],[1984,1984]]],[1521535606598,["gengmei_pxf@gengmei123.local",[[1,2033,"\n"]],[2033,2033],[2034,2034]]],[1521535606910,["gengmei_pxf@gengmei123.local",[[1,2034,"* "]],[2034,2034],[2036,2036]]],[1521535608902,["gengmei_pxf@gengmei123.local",[[1,2121,"\n"]],[2121,2121],[2122,2122]]],[1521535609312,["gengmei_pxf@gengmei123.local",[[1,2122,"* "]],[2122,2122],[2124,2124]]],[1521535616878,["gengmei_pxf@gengmei123.local",[[1,2371,"\n"]],[2371,2371],[2372,2372]]],[1521535617560,["gengmei_pxf@gengmei123.local",[[1,2372,"* "]],[2372,2372],[2374,2374]]],[1521535619814,["gengmei_pxf@gengmei123.local",[[1,2433,"\n"]],[2433,2433],[2434,2434]]],[1521535620256,["gengmei_pxf@gengmei123.local",[[1,2434,"* "]],[2434,2434],[2436,2436]]],[1521535624030,["gengmei_pxf@gengmei123.local",[[1,2703,"* "]],[2703,2703],[2705,2705]]],[1521535625678,["gengmei_pxf@gengmei123.local",[[1,2778,"\n"]],[2778,2778],[2779,2779]]],[1521535626033,["gengmei_pxf@gengmei123.local",[[1,2779,"* "]],[2779,2779],[2781,2781]]],[1521535675173,["gengmei_pxf@gengmei123.local",[[1,491,"\n"]],[490,490],[491,491]]],[1521535676540,["gengmei_pxf@gengmei123.local",[[1,492,"\n"]],[491,491],[492,492]]],[1521535678168,["gengmei_pxf@gengmei123.local",[[1,491,"【】"]],[491,491],[493,493]]],[1521535678949,["gengmei_pxf@gengmei123.local",[[-1,491,"【】"]],[493,493],[491,491]]],[1521535680510,["gengmei_pxf@gengmei123.local",[[1,491,"[]()"]],[491,491],[495,495]]],[1521535682094,["gengmei_pxf@gengmei123.local",[[1,492,"# 集合各实现类的底层实现原理"]],[492,492],[507,507]]],[1521535684549,["gengmei_pxf@gengmei123.local",[[-1,492,"# "]],[494,494],[492,492]]],[1521535690951,["gengmei_pxf@gengmei123.local",[[1,507,"http://blog.csdn.net/qq_25868207/article/details/55259978"]],[507,507],[564,564]]],[1521536186515,["gengmei_pxf@gengmei123.local",[[1,3178,"\n"]],[3176,3176],[3177,3177]]],[1521536187391,["gengmei_pxf@gengmei123.local",[[1,3177,"# 1 Builder模式概念\n\n## 1.1 介绍\n\n　　Builder模式是一步一步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更精细地控制对象的构造流程。该模式是为了将构建复杂对象的过程和它的部件解耦，使得构建过程和部件的表示隔离开来。 \n　　Builder模式，在于分工明确，一个抽象建造者，一个具体的建造者，一个指挥者，当然还需要具体的产品。那么我们以一个软件产品为例：技术主管就是抽象建造者，他和产品经理沟通，知道要做一个什么样的产品；而程序员就是具体的劳动者，技术主管说咋做你就咋做；而指挥者就是公司的产品经理，负责和用户沟通，了解客户的需求。\n\n## 1.2 定义\n\n　　将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n\n## 1.3 使用场景\n\n*   相同的方法，不同的执行顺序，产生不同的事件结果时；\n*   多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时；\n*   产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适；\n*   当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值时。"]],[3177,3177],[3694,3694]]],[1521536192588,["gengmei_pxf@gengmei123.local",[[1,3178,"##"],[-1,3313," "],[1,3314," "]],[3178,3178],[3180,3180]]],[1521536194337,["gengmei_pxf@gengmei123.local",[[1,3198,"##"]],[3198,3198],[3200,3200]]],[1521536196213,["gengmei_pxf@gengmei123.local",[[1,3479,"##"]],[3479,3479],[3481,3481]]],[1521536197628,["gengmei_pxf@gengmei123.local",[[1,3533,"##"]],[3533,3533],[3535,3535]]],[1521536278180,["gengmei_pxf@gengmei123.local",[[1,3704,"\n"]],[3702,3702],[3703,3703]]],[1521536279044,["gengmei_pxf@gengmei123.local",[[1,3705,"\n"]],[3703,3703],[3704,3704]]],[1521536279520,["gengmei_pxf@gengmei123.local",[[1,3704,"（8）小总结 \n　　在AlertDialog的Builder模式中并没有看到Director角色出现，并没按照标准的模式使用，而是做了一些修改。AlertDialog.Builder同时扮演了上下文提到的builder、ConcreteBuilder、Director的角色，简化了Builder模式的设计。\n\n# 7 总结\n\n　　Builder模式在Android开发中也较为常用，通常作为配置类的构建器将配置的构建和表示分离开来，同时也是将配置从目标类中隔离出来，避免过多的setter方法。Builder模式比较常见的实现形式是通过调用链实现，这样使得代码更简洁、易懂，例如图片请求框架ImageLoader就是通过ImageLoaderConfig进行配置，这样避免了目标类中被过多的接口“污染”。\n\n### 7.1 优点\n\n（1）良好的封装性， 使用建造者模式可以使客户端不必知道产品内部组成的细节； \n（2）建造者独立，容易扩展； \n（3）在对象创建过程中会使用到系统中的一些其它对象，这些对象在产品对象的创建过程中不易得到。\n\n### 7.2 缺点\n\n（1）会产生多余的Builder对象以及Director对象，消耗内存； \n（2）对象的构建过程暴露。"]],[3704,3704],[4238,4238]]],[1521536287228,["gengmei_pxf@gengmei123.local",[[-1,3705,"8）小总结 "],[1,3711," "],[-1,4109," "],[1,4110," "],[-1,4125," "],[1,4126," "],[-1,4223," "],[1,4224," "]],[3705,3710],[3705,3705]]],[1521536287684,["gengmei_pxf@gengmei123.local",[[-1,3704,"（"]],[3705,3705],[3704,3704]]],[1521536291428,["gengmei_pxf@gengmei123.local",[[1,3704,"#### s"]],[3704,3704],[3710,3710]]],[1521536292002,["gengmei_pxf@gengmei123.local",[[1,3710,"hiy"]],[3710,3710],[3713,3713]]],[1521536292850,["gengmei_pxf@gengmei123.local",[[-1,3709,"shiy"]],[3713,3713],[3709,3709]]],[1521536297229,["gengmei_pxf@gengmei123.local",[[1,3709,"使用Dialog"]],[3709,3709],[3717,3717]]],[1521536299491,["gengmei_pxf@gengmei123.local",[[1,3717,"\n"]],[3717,3717],[3718,3718]]],[1521536305610,["gengmei_pxf@gengmei123.local",[[1,3869,"####"]],[3869,3869],[3873,3873]]],[1521536306402,["gengmei_pxf@gengmei123.local",[[-1,3872,"#"]],[3873,3873],[3872,3872]]],[1521536311724,["gengmei_pxf@gengmei123.local",[[1,4073,"##"]],[4073,4073],[4075,4075]]],[1521536314044,["gengmei_pxf@gengmei123.local",[[1,4191,"##"]],[4191,4191],[4193,4193]]],[1521536335376,["gengmei_pxf@gengmei123.local",[[-1,3201,"1."]],[3203,3203],[3201,3201]]],[1521536338144,["gengmei_pxf@gengmei123.local",[[-1,3480,"1."]],[3482,3482],[3480,3480]]],[1521536341175,["gengmei_pxf@gengmei123.local",[[-1,3532,"1."]],[3534,3534],[3532,3532]]],[1521536346952,["gengmei_pxf@gengmei123.local",[[1,3703,"4 "]],[3703,3703],[3705,3705]]],[1521536348631,["gengmei_pxf@gengmei123.local",[[-1,3869,"7"]],[3870,3870],[3869,3869]]],[1521536348841,["gengmei_pxf@gengmei123.local",[[1,3869,"5"]],[3869,3869],[3870,3870]]],[1521536352566,["gengmei_pxf@gengmei123.local",[[-1,4072,"7"]],[4073,4073],[4072,4072]]],[1521536352776,["gengmei_pxf@gengmei123.local",[[1,4072,"5"]],[4072,4072],[4073,4073]]],[1521536355671,["gengmei_pxf@gengmei123.local",[[-1,4190,"7"]],[4191,4191],[4190,4190]]],[1521536355863,["gengmei_pxf@gengmei123.local",[[1,4190,"5"]],[4190,4190],[4191,4191]]],[1521536625261,["gengmei_pxf@gengmei123.local",[[1,3177,"\n"]],[3177,3177],[3178,3178]]],[1521539188656,["gengmei_pxf@gengmei123.local",[[1,4334,"\n"]],[4332,4332],[4333,4333]]],[1521539189237,["gengmei_pxf@gengmei123.local",[[1,4333,"特别注意：\n\n1、你应当知道在调用 bindService 绑定到Service的时候，你就应当保证在某处调用 unbindService 解除绑定（尽管 Activity 被 finish 的时候绑定会自　　　　　　动解除，并且Service会自动停止）；\n\n2、你应当注意 使用 startService 启动服务之后，一定要使用 stopService停止服务，不管你是否使用bindService； \n\n3、同时使用 startService 与 bindService 要注意到，Service 的终止，需要unbindService与stopService同时调用，才能终止 Service，不管 startService 与 bindService 的调用顺序，如果先调用 unbindService 此时服务不会自动终止，再调用 stopService 之后服务才会停止，如果先调用 stopService 此时服务也不会终止，而再调用 unbindService 或者 之前调用 bindService 的 Context 不存在了（如Activity 被 finish 的时候）之后服务才会自动停止；\n\n4、当在旋转手机屏幕的时候，当手机屏幕在“横”“竖”变换时，此时如果你的 Activity 如果会自动旋转的话，旋转其实是 Activity 的重新创建，因此旋转之前的使用 bindService 建立的连接便会断开（Context 不存在了），对应服务的生命周期与上述相同。\n\n5、在 sdk 2.0 及其以后的版本中，对应的 onStart 已经被否决变为了 onStartCommand，不过之前的 onStart 任然有效。这意味着，如果你开发的应用程序用的 sdk 为 2.0 及其以后的版本，那么你应当使用 onStartCommand 而不是 onStart。"]],[4333,4333],[5132,5132]]],[1521539193691,["gengmei_pxf@gengmei123.local",[[1,4333,"\n"],[-1,4536," "],[1,4537," **"]],[4333,4333],[4336,4336]]],[1521539197491,["gengmei_pxf@gengmei123.local",[[1,5135,"**"]],[5135,5135],[5137,5137]]],[1521539200753,["gengmei_pxf@gengmei123.local",[[-1,5134,"。"]],[5135,5135],[5134,5134]]],[1521539202683,["gengmei_pxf@gengmei123.local",[[1,5136,"。"]],[5136,5136],[5137,5137]]],[1521539205537,["gengmei_pxf@gengmei123.local",[[-1,5134,"**"]],[5136,5136],[5134,5134]]],[1521539266737,[null,[[1,4334,"**"],[-1,4538,"**"]],[4334,4334],[4538,4538]]],[1521539266737,[null,[[-1,4334,"**"],[1,4540,"**"]],[4538,4538],[4334,4334]]],[1521539217787,["gengmei_pxf@gengmei123.local",[[1,4341,"*"]],[4341,4341],[4342,4342]]],[1521539218952,["gengmei_pxf@gengmei123.local",[[-1,4341,"*"]],[4342,4342],[4341,4341]]],[1521539220513,["gengmei_pxf@gengmei123.local",[[1,4340,"**"]],[4340,4340],[4342,4342]]],[1521539252877,["gengmei_pxf@gengmei123.local",[[1,5139,"\n"]],[5137,5137],[5138,5138]]],[1521539253079,["gengmei_pxf@gengmei123.local",[[1,5140,"\n"]],[5138,5138],[5139,5139]]],[1521539253523,["gengmei_pxf@gengmei123.local",[[1,5139,"## 几点提示\n\n1.  由于服务进程是有可能在中途被杀死的，在客户端保持`mBound`布尔值来判断是否连接仍然健康是必要的，否则你应该监控是否有`DeadObjectException`的发生。\n\n2.  **绑定Service后一定要在onStop或者onDestroy中调用`unBindService`释放连接，否则会有内存泄露。** 具体要和哪个生命周期进行搭配，取决于应用需要，参考[Managing the Activity Lifecycle](http://developer.android.com/training/basics/activity-lifecycle/index.html).\n\n3.  **无论Service被多少个线程绑定，它都只会返回同一个IBinder实例。**"]],[5139,5139],[5494,5494]]],[1521539261886,["gengmei_pxf@gengmei123.local",[[1,4334,"#"],[-1,5311," "],[1,5312," ## "]],[4334,4334],[4338,4338]]],[1521539264939,["gengmei_pxf@gengmei123.local",[[1,5145,"#"]],[5145,5145],[5146,5146]]],[1521539386752,[null,[[1,4335,"## **"],[1,4339,"**"],[-1,4341,"**"],[-1,4541,"**"],[1,5142,"#"],[-1,5145,"#"],[-1,5313," ##"]],[4335,4335],[5313,5313]]],[1521539386752,[null,[[-1,4335,"## **"],[-1,4344,"**"],[1,4348,"**"],[1,4546,"**"],[-1,5145,"#"],[1,5149,"#"],[1,5316," ##"]],[5313,5313],[4335,4335]]],[1521539367926,["gengmei_pxf@gengmei123.local",[[1,5454,"\n"]],[5452,5452],[5453,5453]]],[1521539368465,["gengmei_pxf@gengmei123.local",[[1,5455,"\n"]],[5453,5453],[5454,5454]]],[1521539368962,["gengmei_pxf@gengmei123.local",[[1,5454,"1.当启动时，单独调用bindService方法，在unbindService后，会执行service的onUnbind，在执行onDestroy方法。\n 2.当启动时，先调用startService，再调用bindService方法后，在unbindService后，会执行service的onUnbind，不会执行onDestroy方法。除非你在执行stopService.\n 3\\. 先调用startService，在调用stopService，会执行service的onDestroy方法。"]],[5454,5454],[5703,5703]]],[1521539371935,["gengmei_pxf@gengmei123.local",[[-1,5454,"1"],[-1,5531," "],[1,5532," "],[-1,5644," "],[1,5645," 4"]],[5455,5455],[5455,5455]]],[1521539374086,["gengmei_pxf@gengmei123.local",[[1,5532,"\n"]],[5532,5532],[5533,5533]]],[1521539375414,["gengmei_pxf@gengmei123.local",[[-1,5533,"2"]],[5534,5534],[5533,5533]]],[1521539375665,["gengmei_pxf@gengmei123.local",[[1,5533,"5"]],[5533,5533],[5534,5534]]],[1521539381533,["gengmei_pxf@gengmei123.local",[[-1,5645," 3\\"]],[5648,5648],[5645,5645]]],[1521539382392,["gengmei_pxf@gengmei123.local",[[1,5645,"6"]],[5645,5645],[5646,5646]]],[1521539383437,["gengmei_pxf@gengmei123.local",[[1,5645,"\n"]],[5645,5645],[5646,5646]]],[1521539446744,[null,[[1,4335,"## **"],[1,4339,"**"],[-1,4341,"**"],[-1,4541,"**"],[1,4543,""],[1,5142,"#"],[-1,5145,"#"],[-1,5314,"## "],[1,5454,"4"],[-1,5531,"2"],[1,5534,"."],[-1,5644," "]],[4335,4335],[5644,5644]]],[1521539446744,[null,[[-1,4335,"## **"],[-1,4344,"**"],[1,4348,"**"],[1,4546,"**"],[-1,4546,""],[-1,5145,"#"],[1,5149,"#"],[1,5317,"## "],[-1,5454,"4"],[1,5532,"2"],[-1,5534,"."],[1,5645," "]],[5644,5644],[4335,4335]]],[1521539416669,["gengmei_pxf@gengmei123.local",[[1,4334,"\n"]],[4333,4333],[4334,4334]]],[1521539418143,["gengmei_pxf@gengmei123.local",[[1,4333,"【】"]],[4333,4333],[4335,4335]]],[1521539419148,["gengmei_pxf@gengmei123.local",[[-1,4333,"【】"]],[4335,4335],[4333,4333]]],[1521539420973,["gengmei_pxf@gengmei123.local",[[1,4333,"[]()"]],[4333,4333],[4337,4337]]],[1521539422767,["gengmei_pxf@gengmei123.local",[[1,4334,"### Android中Service的使用详解和注意点（LocalService）"]],[4334,4334],[4376,4376]]],[1521539425803,["gengmei_pxf@gengmei123.local",[[-1,4334,"### "]],[4338,4338],[4334,4334]]],[1521539434367,["gengmei_pxf@gengmei123.local",[[1,4374,"https://www.cnblogs.com/linlf03/p/3296323.html"]],[4374,4374],[4420,4420]]],[1521539436348,["gengmei_pxf@gengmei123.local",[[1,4333,"\n"]],[4333,4333],[4334,4334]]],[1521539437924,["gengmei_pxf@gengmei123.local",[[1,4424,"\n"]],[4423,4423],[4424,4424]]],[1521539438132,["gengmei_pxf@gengmei123.local",[[1,4425,"\n"]],[4424,4424],[4425,4425]]],[1521539440299,["gengmei_pxf@gengmei123.local",[[1,4424,"[]()"]],[4424,4424],[4428,4428]]],[1521539463116,[null,[[1,4431,"## **"],[1,4435,"**"],[-1,4437,"**"],[-1,4637,"**"],[1,4639,""],[1,5238,"#"],[-1,5241,"#"],[-1,5410,"## "],[1,5550,"4"],[-1,5627,"2"],[1,5630,"."],[-1,5740," "]],[4431,4431],[5740,5740]]],[1521539463116,[null,[[-1,4431,"## **"],[-1,4440,"**"],[1,4444,"**"],[1,4642,"**"],[-1,4642,""],[-1,5241,"#"],[1,5245,"#"],[1,5413,"## "],[-1,5550,"4"],[1,5628,"2"],[-1,5630,"."],[1,5741," "]],[5740,5740],[4431,4431]]],[1521539450933,["gengmei_pxf@gengmei123.local",[[1,4425,"# Android Service整理－本地绑定和远程绑定"]],[4425,4425],[4454,4454]]],[1521539453100,["gengmei_pxf@gengmei123.local",[[-1,4425,"# "]],[4427,4427],[4425,4425]]],[1521539461421,["gengmei_pxf@gengmei123.local",[[1,4454,"http://blog.csdn.net/wl455624651/article/details/41868915"]],[4454,4454],[4511,4511]]],[1521539583132,[null,[[1,4515,"## **"],[1,4519,"**"],[-1,4521,"**"],[-1,4721,"**"],[1,4723,""],[1,5322,"#"],[-1,5325,"#"],[-1,5494,"## "],[1,5634,"4"],[-1,5711,"2"],[1,5714,"."],[-1,5824," "]],[4515,4515],[5824,5824]]],[1521539583132,[null,[[-1,4515,"## **"],[-1,4524,"**"],[1,4528,"**"],[1,4726,"**"],[-1,4726,""],[-1,5325,"#"],[1,5329,"#"],[1,5497,"## "],[-1,5634,"4"],[1,5712,"2"],[-1,5714,"."],[1,5825," "]],[5824,5824],[4515,4515]]],[1521539527945,["gengmei_pxf@gengmei123.local",[[1,4296,"\n"]],[4295,4295],[4296,4296]]],[1521539528240,["gengmei_pxf@gengmei123.local",[[1,4297,"\n"]],[4296,4296],[4297,4297]]],[1521539529619,["gengmei_pxf@gengmei123.local",[[1,4296,"## 面试的时候被问到这样一个问题，绑定server之后如果不解绑，程序会Crash吗？我擦，蒙逼了，回去之后试了试，不会异常，但是会泄漏"]],[4296,4296],[4365,4365]]],[1521539532336,["gengmei_pxf@gengmei123.local",[[-1,4296,"##"]],[4298,4298],[4296,4296]]],[1521539539648,["gengmei_pxf@gengmei123.local",[[-1,4338,"我擦，蒙逼了，"]],[4338,4345],[4338,4338]]],[1521539548086,["gengmei_pxf@gengmei123.local",[[1,4297,"\n"]],[4297,4297],[4298,4298]]],[1521539549969,["gengmei_pxf@gengmei123.local",[[1,4298,"* "]],[4298,4298],[4300,4300]]],[1521539643116,[null,[[1,4580,"## **"],[1,4584,"**"],[-1,4586,"**"],[-1,4786,"**"],[1,4788,""],[1,5387,"#"],[-1,5390,"#"],[-1,5559,"## "],[1,5699,"4"],[-1,5776,"2"],[1,5779,"."],[-1,5889," "]],[4580,4580],[5889,5889]]],[1521539643116,[null,[[-1,4580,"## **"],[-1,4589,"**"],[1,4593,"**"],[1,4791,"**"],[-1,4791,""],[-1,5390,"#"],[1,5394,"#"],[1,5562,"## "],[-1,5699,"4"],[1,5777,"2"],[-1,5779,"."],[1,5890," "]],[5889,5889],[4580,4580]]],[1521539583270,["gengmei_pxf@gengmei123.local",[[1,4359,"."]],[4359,4359],[4360,4360]]],[1521539583700,["gengmei_pxf@gengmei123.local",[[1,4362,"\n"]],[4360,4360],[4361,4361]]],[1521539584605,["gengmei_pxf@gengmei123.local",[[1,4363,"\n"]],[4361,4361],[4362,4362]]],[1521539585727,["gengmei_pxf@gengmei123.local",[[1,4362,"*## 这种异常是直接bind之后退出程序（界面不可见出现问题，如果直接干掉程序是没问题的）\n\n2.异常二,不绑定直接退出，也会出异常 \n同样看一叙异常"]],[4362,4362],[4438,4438]]],[1521539587693,["gengmei_pxf@gengmei123.local",[[-1,4365," "],[-1,4429," "],[1,4430," "]],[4366,4366],[4365,4365]]],[1521539588178,["gengmei_pxf@gengmei123.local",[[-1,4363,"##"]],[4365,4365],[4363,4363]]],[1521539588608,["gengmei_pxf@gengmei123.local",[[1,4363," "]],[4363,4363],[4364,4364]]],[1521539629159,["gengmei_pxf@gengmei123.local",[[-1,4408,"2.异常二,"],[1,4414,"* "]],[4408,4414],[4410,4410]]],[1521539636352,["gengmei_pxf@gengmei123.local",[[-1,4425,"同样看一叙异常"]],[4425,4432],[4425,4425]]],[1521539636744,["gengmei_pxf@gengmei123.local",[[-1,4426,"\n"]],[4425,4425],[4424,4424]]],[1521539639618,["gengmei_pxf@gengmei123.local",[[1,4426,"*"]],[4426,4426],[4427,4427]]],[1521539642222,["gengmei_pxf@gengmei123.local",[[-1,4427,"（"]],[4428,4428],[4427,4427]]],[1521539642857,["gengmei_pxf@gengmei123.local",[[1,4427," "]],[4427,4427],[4428,4428]]],[1521539703118,[null,[[1,4646,"## **"],[1,4650,"**"],[-1,4652,"**"],[-1,4852,"**"],[1,4854,""],[1,5453,"#"],[-1,5456,"#"],[-1,5625,"## "],[1,5765,"4"],[-1,5842,"2"],[1,5845,"."],[-1,5955," "]],[4646,4646],[5955,5955]]],[1521539703118,[null,[[-1,4646,"## **"],[-1,4655,"**"],[1,4659,"**"],[1,4857,"**"],[-1,4857,""],[-1,5456,"#"],[1,5460,"#"],[1,5628,"## "],[-1,5765,"4"],[1,5843,"2"],[-1,5845,"."],[1,5956," "]],[5955,5955],[4646,4646]]],[1521539645359,["gengmei_pxf@gengmei123.local",[[-1,4462,"）"]],[4463,4463],[4462,4462]]],[1521539663463,["gengmei_pxf@gengmei123.local",[[1,4435,"shi"]],[4435,4435],[4438,4438]]],[1521539664293,["gengmei_pxf@gengmei123.local",[[-1,4435,"shi"]],[4438,4438],[4435,4435]]],[1521539671854,["gengmei_pxf@gengmei123.local",[[1,4435,"是远程进程，通过"]],[4435,4435],[4443,4443]]],[1521539674214,["gengmei_pxf@gengmei123.local",[[-1,4443," "]],[4444,4444],[4443,4443]]],[1521539676030,["gengmei_pxf@gengmei123.local",[[-1,4447,"创建"]],[4449,4449],[4447,4447]]],[1521539677665,["gengmei_pxf@gengmei123.local",[[1,4447,"不定"]],[4447,4447],[4449,4449]]],[1521539678380,["gengmei_pxf@gengmei123.local",[[-1,4447,"不定"]],[4449,4449],[4447,4447]]],[1521539681353,["gengmei_pxf@gengmei123.local",[[1,4447,"绑定柱"]],[4447,4447],[4450,4450]]],[1521539682053,["gengmei_pxf@gengmei123.local",[[-1,4449,"柱"]],[4450,4450],[4449,4449]]],[1521539688624,["gengmei_pxf@gengmei123.local",[[1,4449,"主进程的Activity"]],[4449,4449],[4461,4461]]],[1521539699511,["gengmei_pxf@gengmei123.local",[[1,4470,"，会发生什么？"]],[4470,4470],[4477,4477]]],[1521539702623,["gengmei_pxf@gengmei123.local",[[1,4488,"？"]],[4488,4488],[4489,4489]]],[1521539737972,[null,[[1,4672,"## **"],[1,4676,"**"],[-1,4678,"**"],[-1,4878,"**"],[1,4880,""],[1,5479,"#"],[-1,5482,"#"],[-1,5651,"## "],[1,5791,"4"],[-1,5868,"2"],[1,5871,"."],[-1,5981," "]],[4672,4672],[5981,5981]]],[1521539737972,[null,[[-1,4672,"## **"],[-1,4681,"**"],[1,4685,"**"],[1,4883,"**"],[-1,4883,""],[-1,5482,"#"],[1,5486,"#"],[1,5654,"## "],[-1,5791,"4"],[1,5869,"2"],[-1,5871,"."],[1,5982," "]],[5981,5981],[4672,4672]]],[1521539706910,["gengmei_pxf@gengmei123.local",[[1,4481,"远程"]],[4481,4481],[4483,4483]]],[1521539709156,["gengmei_pxf@gengmei123.local",[[-1,4435,"是"]],[4436,4436],[4435,4435]]],[1521539712759,["gengmei_pxf@gengmei123.local",[[1,4435,"是"]],[4435,4435],[4436,4436]]],[1521539715061,["gengmei_pxf@gengmei123.local",[[-1,4438,"进程"],[1,4440,"f"]],[4438,4440],[4438,4439]]],[1521539715242,["gengmei_pxf@gengmei123.local",[[1,4439,"u"]],[4438,4439],[4438,4440]]],[1521539715695,["gengmei_pxf@gengmei123.local",[[1,4440,"'w"]],[4438,4440],[4438,4442]]],[1521539715862,["gengmei_pxf@gengmei123.local",[[1,4442,"u"]],[4438,4442],[4438,4443]]],[1521539716092,["gengmei_pxf@gengmei123.local",[[-1,4438,"fu'wu"],[1,4443,"服务"]],[4438,4443],[4440,4440]]],[1521539797971,[null,[[1,4674,"## **"],[1,4678,"**"],[-1,4680,"**"],[-1,4880,"**"],[1,4882,""],[1,5481,"#"],[-1,5484,"#"],[-1,5653,"## "],[1,5793,"4"],[-1,5870,"2"],[1,5873,"."],[-1,5983," "]],[4674,4674],[5983,5983]]],[1521539797971,[null,[[-1,4674,"## **"],[-1,4683,"**"],[1,4687,"**"],[1,4885,"**"],[-1,4885,""],[-1,5484,"#"],[1,5488,"#"],[1,5656,"## "],[-1,5793,"4"],[1,5871,"2"],[-1,5873,"."],[1,5984," "]],[5983,5983],[4674,4674]]],[1521539757705,["gengmei_pxf@gengmei123.local",[[-1,4784,"　　　　　　"]],[4784,4790],[4784,4784]]],[1521539767435,["gengmei_pxf@gengmei123.local",[[1,4428,"**"]],[4428,4428],[4430,4430]]],[1521539772372,["gengmei_pxf@gengmei123.local",[[1,4492,"**"]],[4492,4492],[4494,4494]]],[1521539824399,[null,[[1,4678,"## **"],[1,4682,"**"],[-1,4684,"**"],[-1,4783,"　　　　　"],[1,4788,"动解除，并"],[-1,4878,"**"],[1,5479,"#"],[-1,5482,"#"],[-1,5651,"## "],[1,5791,"4"],[-1,5868,"2"],[1,5871,"."],[-1,5981," "]],[4678,4678],[5981,5981]]],[1521539824399,[null,[[-1,4678,"## **"],[-1,4687,"**"],[1,4691,"**"],[1,4788,"　　　　　"],[-1,4788,"动解除，并"],[1,4883,"**"],[-1,5482,"#"],[1,5486,"#"],[1,5654,"## "],[-1,5791,"4"],[1,5869,"2"],[-1,5871,"."],[1,5982," "]],[5981,5981],[4678,4678]]],[1521539819246,["gengmei_pxf@gengmei123.local",[[1,4473,"但是调用了stopService，"]],[4473,4473],[4490,4490]]],[1521539821484,["gengmei_pxf@gengmei123.local",[[-1,4472,"，"]],[4473,4473],[4472,4472]]],[1521539830327,[null,[[1,4694,"## **"],[1,4698,"**"],[-1,4700,"**"],[-1,4799,"　　　　　"],[1,4804,"动解除，并"],[-1,4894,"**"],[1,5495,"#"],[-1,5498,"#"],[-1,5667,"## "],[1,5807,"4"],[-1,5884,"2"],[1,5887,"."],[-1,5997," "]],[4694,4694],[5997,5997]]],[1521539830327,[null,[[-1,4694,"## **"],[-1,4703,"**"],[1,4707,"**"],[1,4804,"　　　　　"],[-1,4804,"动解除，并"],[1,4899,"**"],[-1,5498,"#"],[1,5502,"#"],[1,5670,"## "],[-1,5807,"4"],[1,5885,"2"],[-1,5887,"."],[1,5998," "]],[5997,5997],[4694,4694]]],[1521539826956,["gengmei_pxf@gengmei123.local",[[1,4513,"\n"]],[4512,4512],[4513,4513]]],[1521539827718,["gengmei_pxf@gengmei123.local",[[1,4514,"\n"]],[4513,4513],[4514,4514]]],[1521539890328,[null,[[1,4696,"## **"],[1,4700,"**"],[-1,4702,"**"],[-1,4801,"　　　　　"],[1,4806,"动解除，并"],[-1,4896,"**"],[1,5497,"#"],[-1,5500,"#"],[-1,5669,"## "],[1,5809,"4"],[-1,5886,"2"],[1,5889,"."],[-1,5999," "]],[4696,4696],[5999,5999]]],[1521539890328,[null,[[-1,4696,"## **"],[-1,4705,"**"],[1,4709,"**"],[1,4806,"　　　　　"],[-1,4806,"动解除，并"],[1,4901,"**"],[-1,5500,"#"],[1,5504,"#"],[1,5672,"## "],[-1,5809,"4"],[1,5887,"2"],[-1,5889,"."],[1,6000," "]],[5999,5999],[4696,4696]]],[1521539859453,["gengmei_pxf@gengmei123.local",[[1,4513,"Service没有解绑，也没有停止。"]],[4513,4513],[4531,4531]]],[1521539859939,["gengmei_pxf@gengmei123.local",[[1,4533,"\n"]],[4531,4531],[4532,4532]]],[1521539874916,["gengmei_pxf@gengmei123.local",[[1,4532,"当绑定的Activity退出，或者柱进程"]],[4532,4532],[4552,4552]]],[1521539876411,["gengmei_pxf@gengmei123.local",[[-1,4549,"柱进程"]],[4552,4552],[4549,4549]]],[1521539888533,["gengmei_pxf@gengmei123.local",[[1,4549,"主进程杀死时，"]],[4549,4549],[4556,4556]]],[1521539950327,[null,[[1,4739,"## **"],[1,4743,"**"],[-1,4745,"**"],[-1,4844,"　　　　　"],[1,4849,"动解除，并"],[-1,4939,"**"],[1,5540,"#"],[-1,5543,"#"],[-1,5712,"## "],[1,5852,"4"],[-1,5929,"2"],[1,5932,"."],[-1,6042," "]],[4739,4739],[6042,6042]]],[1521539950327,[null,[[-1,4739,"## **"],[-1,4748,"**"],[1,4752,"**"],[1,4849,"　　　　　"],[-1,4849,"动解除，并"],[1,4944,"**"],[-1,5543,"#"],[1,5547,"#"],[1,5715,"## "],[-1,5852,"4"],[1,5930,"2"],[-1,5932,"."],[1,6043," "]],[6042,6042],[4739,4739]]],[1521539908252,["gengmei_pxf@gengmei123.local",[[1,4556,"绑定会自动解除，Service停止。"]],[4556,4556],[4574,4574]]],[1521539922931,["gengmei_pxf@gengmei123.local",[[1,4771,"* "]],[4771,4771],[4773,4773]]],[1521539925098,["gengmei_pxf@gengmei123.local",[[1,4891,"* "]],[4891,4891],[4893,4893]]],[1521539927202,["gengmei_pxf@gengmei123.local",[[1,4968,"* "]],[4968,4968],[4970,4970]]],[1521539941041,["gengmei_pxf@gengmei123.local",[[1,5276,"* "]],[5276,5276],[5278,5278]]],[1521539943498,["gengmei_pxf@gengmei123.local",[[1,5418,"* "]],[5418,5418],[5420,5420]]],[1521539987171,[null,[[1,4757,"## **"],[1,4761,"**"],[-1,4763,"**"],[1,4766,"* "],[-1,4771,"* "],[-1,4864,"　　　　　"],[1,4869,"动解除，并"],[1,4886,"* "],[-1,4891,"* "],[-1,4961,"**"],[1,4965,"* "],[-1,4968,"* "],[1,5273,"* "],[-1,5276,"* "],[1,5415,"* "],[-1,5418,"* "],[1,5568,"#"],[-1,5571,"#"],[-1,5740,"## "],[1,5880,"4"],[-1,5957,"2"],[1,5960,"."],[-1,6070," "]],[4757,4757],[6070,6070]]],[1521539987171,[null,[[-1,4757,"## **"],[-1,4766,"**"],[1,4770,"**"],[-1,4771,"* "],[1,4778,"* "],[1,4869,"　　　　　"],[-1,4869,"动解除，并"],[-1,4891,"* "],[1,4898,"* "],[1,4966,"**"],[-1,4968,"* "],[1,4973,"* "],[-1,5276,"* "],[1,5281,"* "],[-1,5418,"* "],[1,5423,"* "],[-1,5571,"#"],[1,5575,"#"],[1,5743,"## "],[-1,5880,"4"],[1,5958,"2"],[-1,5960,"."],[1,6071," "]],[6070,6070],[4757,4757]]],[1521539955649,["gengmei_pxf@gengmei123.local",[[-1,5569,"### 几点提示\n\n1"],[1,5580,"* 6"]],[5569,5580],[5572,5572]]],[1521539961114,["gengmei_pxf@gengmei123.local",[[1,5663,"* "]],[5663,5663],[5665,5665]]],[1521539962167,["gengmei_pxf@gengmei123.local",[[-1,5665,"2"]],[5666,5666],[5665,5665]]],[1521539962423,["gengmei_pxf@gengmei123.local",[[1,5665,"7"]],[5665,5665],[5666,5666]]],[1521539968254,["gengmei_pxf@gengmei123.local",[[-1,5666,". "]],[5668,5668],[5666,5666]]],[1521539972127,["gengmei_pxf@gengmei123.local",[[-1,5572,".  "]],[5575,5575],[5572,5572]]],[1521539972406,["gengmei_pxf@gengmei123.local",[[1,5572," "]],[5572,5572],[5573,5573]]],[1521539976360,["gengmei_pxf@gengmei123.local",[[1,5870,"* "]],[5870,5870],[5872,5872]]],[1521539978551,["gengmei_pxf@gengmei123.local",[[-1,5872,"4"]],[5873,5873],[5872,5872]]],[1521539978976,["gengmei_pxf@gengmei123.local",[[1,5872,"8"]],[5872,5872],[5873,5873]]],[1521539981176,["gengmei_pxf@gengmei123.local",[[1,5951,"* "]],[5951,5951],[5953,5953]]],[1521539982038,["gengmei_pxf@gengmei123.local",[[-1,5953,"5"]],[5954,5954],[5953,5953]]],[1521539982368,["gengmei_pxf@gengmei123.local",[[1,5953,"9"]],[5953,5953],[5954,5954]]],[1521539984976,["gengmei_pxf@gengmei123.local",[[1,6066,"* "]],[6066,6066],[6068,6068]]],[1521539985742,["gengmei_pxf@gengmei123.local",[[-1,6068,"6"]],[6069,6069],[6068,6068]]],[1521539986199,["gengmei_pxf@gengmei123.local",[[1,6068,"10"]],[6068,6068],[6070,6070]]],[1521540016371,[null,[[1,4757,"## **"],[1,4761,"**"],[-1,4763,"**"],[1,4766,"* "],[-1,4771,"* "],[-1,4864,"　　　　　"],[1,4869,"动解除，并"],[1,4886,"* "],[-1,4891,"* "],[-1,4961,"**"],[1,4965,"* "],[-1,4968,"* "],[1,5273,"* "],[-1,5276,"* "],[1,5415,"* "],[-1,5418,"* "],[-1,5566,"## "],[1,5573,"由于服"],[-1,5658,"2. "],[1,5664," **"],[-1,5730,"## "],[1,5873,"."],[-1,5949,"2"],[1,5954,"."],[-1,6064," "]],[4757,4757],[6064,6064]]],[1521540016371,[null,[[-1,4757,"## **"],[-1,4766,"**"],[1,4770,"**"],[-1,4771,"* "],[1,4778,"* "],[1,4869,"　　　　　"],[-1,4869,"动解除，并"],[-1,4891,"* "],[1,4898,"* "],[1,4966,"**"],[-1,4968,"* "],[1,4973,"* "],[-1,5276,"* "],[1,5281,"* "],[-1,5418,"* "],[1,5423,"* "],[1,5569,"## "],[-1,5573,"由于服"],[1,5661,"2. "],[-1,5664," **"],[1,5733,"## "],[-1,5873,"."],[1,5950,"2"],[-1,5954,"."],[1,6065," "]],[6064,6064],[4757,4757]]],[1521539992309,["gengmei_pxf@gengmei123.local",[[-1,6071," "]],[6072,6072],[6071,6071]]],[1521540001909,["gengmei_pxf@gengmei123.local",[[1,5572,"、"]],[5572,5572],[5573,5573]]],[1521540005453,["gengmei_pxf@gengmei123.local",[[-1,5572,"、 "]],[5573,5573],[5572,5572]]],[1521540005701,["gengmei_pxf@gengmei123.local",[[1,5572,"、"]],[5572,5572],[5573,5573]]],[1521540007613,["gengmei_pxf@gengmei123.local",[[-1,5664," "]],[5665,5665],[5664,5664]]],[1521540007861,["gengmei_pxf@gengmei123.local",[[1,5664,"、"]],[5664,5664],[5665,5665]]],[1521540009996,["gengmei_pxf@gengmei123.local",[[-1,5873,"."]],[5874,5874],[5873,5873]]],[1521540010258,["gengmei_pxf@gengmei123.local",[[1,5873,"、"]],[5873,5873],[5874,5874]]],[1521540012086,["gengmei_pxf@gengmei123.local",[[-1,5954,"."],[1,5955,"、"]],[5954,5955],[5955,5955]]],[1521540014167,["gengmei_pxf@gengmei123.local",[[-1,6070,"."],[1,6071,"、"]],[6070,6071],[6071,6071]]],[1521540044892,[null,[[1,4757,"## **"],[1,4761,"**"],[-1,4763,"**"],[1,4766,"* "],[-1,4771,"* "],[-1,4864,"　　　　　"],[1,4869,"动解除，并"],[1,4886,"* "],[-1,4891,"* "],[-1,4961,"**"],[1,4965,"* "],[-1,4968,"* "],[1,5273,"* "],[-1,5276,"* "],[1,5415,"* "],[-1,5418,"* "],[-1,5566,"## "],[1,5573,"由于服"],[-1,5658,"2. "],[1,5665,"**绑"],[-1,5730,"## "],[1,5874,"当"],[-1,5949,"2"],[1,5955,"当"],[-1,6064," "]],[4757,4757],[6064,6064]]],[1521540044892,[null,[[-1,4757,"## **"],[-1,4766,"**"],[1,4770,"**"],[-1,4771,"* "],[1,4778,"* "],[1,4869,"　　　　　"],[-1,4869,"动解除，并"],[-1,4891,"* "],[1,4898,"* "],[1,4966,"**"],[-1,4968,"* "],[1,4973,"* "],[-1,5276,"* "],[1,5281,"* "],[-1,5418,"* "],[1,5423,"* "],[1,5569,"## "],[-1,5573,"由于服"],[1,5661,"2. "],[-1,5665,"**绑"],[1,5733,"## "],[-1,5874,"当"],[1,5950,"2"],[-1,5955,"当"],[1,6065," "]],[6064,6064],[4757,4757]]],[1521540031020,["gengmei_pxf@gengmei123.local",[[1,4298,"\n"]],[4297,4297],[4298,4298]]],[1521540039878,["gengmei_pxf@gengmei123.local",[[1,4298,"### 设计"]],[4298,4298],[4304,4304]]],[1521540040627,["gengmei_pxf@gengmei123.local",[[-1,4302,"设计"]],[4304,4304],[4302,4302]]],[1521540043403,["gengmei_pxf@gengmei123.local",[[1,4302,"涉及到的问题"]],[4302,4302],[4308,4308]]],[1521540044211,["gengmei_pxf@gengmei123.local",[[1,4309,"\n"]],[4308,4308],[4309,4309]]],[1521540064452,[null,[[1,4769,"## **"],[1,4773,"**"],[-1,4775,"**"],[1,4778,"* "],[-1,4783,"* "],[-1,4876,"　　　　　"],[1,4881,"动解除，并"],[1,4898,"* "],[-1,4903,"* "],[-1,4973,"**"],[1,4977,"* "],[-1,4980,"* "],[1,5285,"* "],[-1,5288,"* "],[1,5427,"* "],[-1,5430,"* "],[-1,5578,"## "],[1,5585,"由于服"],[-1,5670,"2. "],[1,5677,"**绑"],[-1,5742,"## "],[1,5886,"当"],[-1,5961,"2"],[1,5967,"当"],[-1,6076," "]],[4769,4769],[6076,6076]]],[1521540064453,[null,[[-1,4769,"## **"],[-1,4778,"**"],[1,4782,"**"],[-1,4783,"* "],[1,4790,"* "],[1,4881,"　　　　　"],[-1,4881,"动解除，并"],[-1,4903,"* "],[1,4910,"* "],[1,4978,"**"],[-1,4980,"* "],[1,4985,"* "],[-1,5288,"* "],[1,5293,"* "],[-1,5430,"* "],[1,5435,"* "],[1,5581,"## "],[-1,5585,"由于服"],[1,5673,"2. "],[-1,5677,"**绑"],[1,5745,"## "],[-1,5886,"当"],[1,5962,"2"],[-1,5967,"当"],[1,6077," "]],[6076,6076],[4769,4769]]],[1521540059550,["gengmei_pxf@gengmei123.local",[[1,4312,"**"]],[4312,4312],[4314,4314]]],[1521540061918,["gengmei_pxf@gengmei123.local",[[1,4374,"**"]],[4374,4374],[4376,4376]]],[1521540124462,[null,[[1,4773,"## **"],[1,4777,"**"],[-1,4779,"**"],[1,4782,"* "],[-1,4787,"* "],[-1,4880,"　　　　　"],[1,4885,"动解除，并"],[1,4902,"* "],[-1,4907,"* "],[-1,4977,"**"],[1,4981,"* "],[-1,4984,"* "],[1,5289,"* "],[-1,5292,"* "],[1,5431,"* "],[-1,5434,"* "],[-1,5582,"## "],[1,5589,"由于服"],[-1,5674,"2. "],[1,5681,"**绑"],[-1,5746,"## "],[1,5890,"当"],[-1,5965,"2"],[1,5971,"当"],[-1,6080," "]],[4773,4773],[6080,6080]]],[1521540124462,[null,[[-1,4773,"## **"],[-1,4782,"**"],[1,4786,"**"],[-1,4787,"* "],[1,4794,"* "],[1,4885,"　　　　　"],[-1,4885,"动解除，并"],[-1,4907,"* "],[1,4914,"* "],[1,4982,"**"],[-1,4984,"* "],[1,4989,"* "],[-1,5292,"* "],[1,5297,"* "],[-1,5434,"* "],[1,5439,"* "],[1,5585,"## "],[-1,5589,"由于服"],[1,5677,"2. "],[-1,5681,"**绑"],[1,5749,"## "],[-1,5890,"当"],[1,5966,"2"],[-1,5971,"当"],[1,6081," "]],[6080,6080],[4773,4773]]],[1521540116792,["gengmei_pxf@gengmei123.local",[[1,4529,"**"]],[4529,4529],[4531,4531]]],[1521540118895,["gengmei_pxf@gengmei123.local",[[1,4592,"**"]],[4592,4592],[4594,4594]]],[1521540121118,["gengmei_pxf@gengmei123.local",[[-1,4591,"。"]],[4592,4592],[4591,4591]]],[1521540122560,["gengmei_pxf@gengmei123.local",[[1,4593,"、"]],[4593,4593],[4594,4594]]],[1521540123190,["gengmei_pxf@gengmei123.local",[[-1,4593,"、"]],[4594,4594],[4593,4593]]],[1521540123591,["gengmei_pxf@gengmei123.local",[[1,4593,"。"]],[4593,4593],[4594,4594]]],[1521540133988,[null,[[1,4777,"## **"],[1,4781,"**"],[-1,4783,"**"],[1,4786,"* "],[-1,4791,"* "],[-1,4884,"　　　　　"],[1,4889,"动解除，并"],[1,4906,"* "],[-1,4911,"* "],[-1,4981,"**"],[1,4985,"* "],[-1,4988,"* "],[1,5293,"* "],[-1,5296,"* "],[1,5435,"* "],[-1,5438,"* "],[-1,5586,"## "],[1,5593,"由于服"],[-1,5678,"2. "],[1,5685,"**绑"],[-1,5750,"## "],[1,5894,"当"],[-1,5969,"2"],[1,5975,"当"],[-1,6084," "]],[4777,4777],[6084,6084]]],[1521540133988,[null,[[-1,4777,"## **"],[-1,4786,"**"],[1,4790,"**"],[-1,4791,"* "],[1,4798,"* "],[1,4889,"　　　　　"],[-1,4889,"动解除，并"],[-1,4911,"* "],[1,4918,"* "],[1,4986,"**"],[-1,4988,"* "],[1,4993,"* "],[-1,5296,"* "],[1,5301,"* "],[-1,5438,"* "],[1,5443,"* "],[1,5589,"## "],[-1,5593,"由于服"],[1,5681,"2. "],[-1,5685,"**绑"],[1,5753,"## "],[-1,5894,"当"],[1,5970,"2"],[-1,5975,"当"],[1,6085," "]],[6084,6084],[4777,4777]]],[1521540132569,["gengmei_pxf@gengmei123.local",[[1,4531,"答案："]],[4531,4531],[4534,4534]]]]],["2931dee9-61ba-47a1-9b92-d6f4ba27e68b",1521543429772,"\n===\n\n## 匿名内部类与内部类的区别\n\n## 静态与非静态\n[java静态与非静态区别](http://www.cnblogs.com/itdev/p/5665531.html)\n\n这里的静态，指以static关键字修饰的，包括类，方法，块，字段。\n非静态，指没有用static 修饰的。\n\n### 静态有一些特点：\n\n* 1.全局唯一，任何一次的修改都是全局性的影响\n\n* 2.只加载一次，优先于非静态\n\n* 3.使用方式上不依赖于实例对象。\n\n* 4.生命周期属于类级别，从JVM 加载开始到JVM卸载结束。\n\n### 关于静态内部类（嵌套类）和非静态内部类的区别\n\n* （1）内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。\n\n* （2）非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。\n\n* （3）一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。\n\n## hashMap 原理，与hashMap类似的线程安全的数据集合\n\n[集合各实现类的底层实现原理](http://blog.csdn.net/qq_25868207/article/details/55259978)\n\n### HashMap实现原理要点概括\n\n参考文献：[http://zhangshixi.iteye.com/blog/672697](http://zhangshixi.iteye.com/blog/672697) \n参考文献：[http://blog.csdn.net/lizhongkaide/article/details/50595719](http://blog.csdn.net/lizhongkaide/article/details/50595719)\n\n* 1.  HashMap是基于哈希表的Map接口的非同步实现，允许使用null值和null键，但不保证映射的顺序。\n\n* 2.  底层使用数组实现，数组中每一项是个单向链表，即数组和链表的结合体；当链表长度大于一定阈值时，链表转换为红黑树，这样减少链表查询时间。\n\n* 3.  HashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Node对象。HashMap底层采用一个Node[]数组来保存所有的key-value对，当需要存储一个Node对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Node时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Node。\n\n* 4.  HashMap进行数组扩容需要重新计算扩容后每个元素在数组中的位置，很耗性能\n\n* 5.  采用了Fail-Fast机制，通过一个modCount值记录修改次数，对HashMap内容的修改都将增加这个值。迭代器初始化过程中会将这个值赋给迭代器的expectedModCount，在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map，马上抛出异常\n\n### Hashtable实现原理要点概括\n\n参考文献：[http://blog.csdn.net/zheng0518/article/details/42199477](http://blog.csdn.net/zheng0518/article/details/42199477)\n\n* 1.  Hashtable是基于哈希表的Map接口的同步实现，不允许使用null值和null键\n\n* 2.  底层使用数组实现，数组中每一项是个单链表，即数组和链表的结合体\n\n* 3.  Hashtable在底层将key-value当成一个整体进行处理，这个整体就是一个Entry对象。Hashtable底层采用一个Entry[]数组来保存所有的key-value对，当需要存储一个Entry对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。\n\n* 4.  synchronized是针对整张Hash表的，即每次锁住整张表让线程独占\n\n### ConcurrentHashMap实现原理要点概括\n\n参考文献：[http://blog.csdn.net/zheng0518/article/details/42199477](http://blog.csdn.net/zheng0518/article/details/42199477)\n\n* 1.  ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。\n\n* 2.  它使用了多个锁来控制对hash表的不同段进行的修改，每个段其实就是一个小的hashtable，它们有自己的锁。只要多个并发发生在不同的段上，它们就可以并发进行。\n\n* 3.  ConcurrentHashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Entry对象。Hashtable底层采用一个Entry[]数组来保存所有的key-value对，当需要存储一个Entry对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。\n\n* 4.  与HashMap不同的是，ConcurrentHashMap使用多个子Hash表，也就是段(Segment)\n\n* 5.  ConcurrentHashMap完全允许多个读操作并发进行，读操作并不需要加锁。如果使用传统的技术，如HashMap中的实现，如果允许可以在hash链的中间添加或删除元素，读操作不加锁将得到不一致的数据。ConcurrentHashMap实现技术是保证HashEntry几乎是不可变的。\n\n### LinkedHashMap实现原理要点概括\n\n参考文献：[http://zhangshixi.iteye.com/blog/673789l](http://zhangshixi.iteye.com/blog/673789)\n\n* 1.  LinkedHashMap继承于HashMap，底层使用哈希表和双向链表来保存所有元素，并且它是非同步，允许使用null值和null键。\n\n* 2.  基本操作与父类HashMap相似，通过重写HashMap相关方法，重新定义了数组中保存的元素Entry，来实现自己的链接列表特性。该Entry除了保存当前对象的引用外，还保存了其上一个元素before和下一个元素after的引用，从而构成了双向链接列表。\n\n## JAVA/Android 多线程实现方式及并发与同步\n（引申synchronize，volatile的使用）\n\n[JAVA\\Android 多线程实现方式及并发与同步](http://blog.csdn.net/csdn_aiyang/article/details/65442540)\n\n## Android中的设计模式\n（builder 创建模式设计的好处是啥）\n\n### 1 Builder模式概念\n\n#### 1 介绍\n\n　　Builder模式是一步一步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更精细地控制对象的构造流程。该模式是为了将构建复杂对象的过程和它的部件解耦，使得构建过程和部件的表示隔离开来。 \n　　Builder模式，在于分工明确，一个抽象建造者，一个具体的建造者，一个指挥者，当然还需要具体的产品。那么我们以一个软件产品为例：技术主管就是抽象建造者，他和产品经理沟通，知道要做一个什么样的产品；而程序员就是具体的劳动者，技术主管说咋做你就咋做；而指挥者就是公司的产品经理，负责和用户沟通，了解客户的需求。\n\n#### 2 定义\n\n　　将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n\n#### 3 使用场景\n\n*   相同的方法，不同的执行顺序，产生不同的事件结果时；\n*   多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时；\n*   产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适；\n*   当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值时。\n\n#### 4 使用Dialog\n \n　　在AlertDialog的Builder模式中并没有看到Director角色出现，并没按照标准的模式使用，而是做了一些修改。AlertDialog.Builder同时扮演了上下文提到的builder、ConcreteBuilder、Director的角色，简化了Builder模式的设计。\n\n#### 5 总结\n\n　　Builder模式在Android开发中也较为常用，通常作为配置类的构建器将配置的构建和表示分离开来，同时也是将配置从目标类中隔离出来，避免过多的setter方法。Builder模式比较常见的实现形式是通过调用链实现，这样使得代码更简洁、易懂，例如图片请求框架ImageLoader就是通过ImageLoaderConfig进行配置，这样避免了目标类中被过多的接口“污染”。\n\n##### 5.1 优点\n\n（1）良好的封装性， 使用建造者模式可以使客户端不必知道产品内部组成的细节； \n（2）建造者独立，容易扩展； \n（3）在对象创建过程中会使用到系统中的一些其它对象，这些对象在产品对象的创建过程中不易得到。\n\n##### 5.2 缺点\n\n（1）会产生多余的Builder对象以及Director对象，消耗内存； \n（2）对象的构建过程暴露。\n\n## Activity的启动模式\n\n## 对象的引用\n\n## Service的创建方式\n \n### 涉及到的问题\n\n* **面试的时候被问到这样一个问题，绑定server之后如果不解绑，程序会Crash吗？回去之后试了试，不会异常，但是会泄漏.**\n\n* 这种异常是直接bind之后退出程序（界面不可见出现问题，如果直接干掉程序是没问题的）\n\n* 不绑定直接退出，也会出异常 \n\n* **Service是远程服务，通过bind绑定主进程的Activity，没有unbind但是调用了stopService，会发生什么？怎么关闭远程Service**？\n\n**答案：Service没有解绑，也没有停止。\n当绑定的Activity退出，或者主进程杀死时，绑定会自动解除，Service停止**。\n\n[Android中Service的使用详解和注意点（LocalService）](https://www.cnblogs.com/linlf03/p/3296323.html)\n\n[Android Service整理－本地绑定和远程绑定](http://blog.csdn.net/wl455624651/article/details/41868915)\n\n### **特别注意**：\n\n* 1、你应当知道在调用 bindService 绑定到Service的时候，你就应当保证在某处调用 unbindService 解除绑定（尽管 Activity 被 finish 的时候绑定会自动解除，并且Service会自动停止）；\n\n* 2、你应当注意 使用 startService 启动服务之后，一定要使用 stopService停止服务，不管你是否使用bindService； \n\n* 3、同时使用 startService 与 bindService 要注意到，Service 的终止，需要unbindService与stopService同时调用，才能终止 Service，不管 startService 与 bindService 的调用顺序，如果先调用 unbindService 此时服务不会自动终止，再调用 stopService 之后服务才会停止，如果先调用 stopService 此时服务也不会终止，而再调用 unbindService 或者 之前调用 bindService 的 Context 不存在了（如Activity 被 finish 的时候）之后服务才会自动停止；\n\n* 4、当在旋转手机屏幕的时候，当手机屏幕在“横”“竖”变换时，此时如果你的 Activity 如果会自动旋转的话，旋转其实是 Activity 的重新创建，因此旋转之前的使用 bindService 建立的连接便会断开（Context 不存在了），对应服务的生命周期与上述相同。\n\n* 5、在 sdk 2.0 及其以后的版本中，对应的 onStart 已经被否决变为了 onStartCommand，不过之前的 onStart 任然有效。这意味着，如果你开发的应用程序用的 sdk 为 2.0 及其以后的版本，那么你应当使用 onStartCommand 而不是 onStart。\n\n* 6、由于服务进程是有可能在中途被杀死的，在客户端保持`mBound`布尔值来判断是否连接仍然健康是必要的，否则你应该监控是否有`DeadObjectException`的发生。\n\n* 7、**绑定Service后一定要在onStop或者onDestroy中调用`unBindService`释放连接，否则会有内存泄露。** 具体要和哪个生命周期进行搭配，取决于应用需要，参考[Managing the Activity Lifecycle](http://developer.android.com/training/basics/activity-lifecycle/index.html).\n\n* 8、当启动时，单独调用bindService方法，在unbindService后，会执行service的onUnbind，在执行onDestroy方法。\n \n* 9、当启动时，先调用startService，再调用bindService方法后，在unbindService后，会执行service的onUnbind，不会执行onDestroy方法。除非你在执行stopService.\n\n* 10、先调用startService，在调用stopService，会执行service的onDestroy方法。\n\n3.  **无论Service被多少个线程绑定，它都只会返回同一个IBinder实例。**\n\n## View的绘制流程\n\n## View的事件流程\n具体题目是 一个frameLayout中有1到6个View叠加，点击第3个View时，调用\n```\ndispatchTouchEvent(e){\n\tsuper.dispatchTouchEvent(e);\n\treturn true;\n}\n```\n说下整个事件的传递机制（事件会不会继续往下传，还是就消费了）\n**答案**：调用super（）里面还会调用很多子类的dispatchTouchEvent方法，所以事件会继续往下传\n\n## MVC，MVP与MVVM模式\n为什么选择这种模式\n\n## 算法（求不规则二叉树的高度）",[[1521543372096,["gengmei_pxf@gengmei123.local",[[1,6484,"\n\n"]],[6484,6484],[6485,6485]]],[1521543373330,["gengmei_pxf@gengmei123.local",[[-1,6485,"\n"],[1,6486,"···"]],[6485,6485],[6488,6488]]],[1521543374130,["gengmei_pxf@gengmei123.local",[[-1,6486,"··"]],[6488,6488],[6486,6486]]],[1521543374327,["gengmei_pxf@gengmei123.local",[[-1,6485,"·"],[1,6486,"\n"]],[6486,6486],[6485,6485]]],[1521543375992,["gengmei_pxf@gengmei123.local",[[-1,6485,"\n"],[1,6486,"```"]],[6485,6485],[6488,6488]]],[1521543376454,["gengmei_pxf@gengmei123.local",[[1,6488,"\n\n"]],[6488,6488],[6489,6489]]],[1521543376791,["gengmei_pxf@gengmei123.local",[[1,6490,"\n"]],[6489,6489],[6490,6490]]],[1521543377434,["gengmei_pxf@gengmei123.local",[[-1,6490,"\n"],[1,6491,"```"]],[6490,6490],[6493,6493]]],[1521543379150,["gengmei_pxf@gengmei123.local",[[1,6489,"二叉树结构定义为："]],[6489,6489],[6498,6498]]],[1521543391367,["gengmei_pxf@gengmei123.local",[[1,6499,"\n"]],[6498,6498],[6499,6499]]],[1521543391782,["gengmei_pxf@gengmei123.local",[[1,6500,"\n"]],[6499,6499],[6500,6500]]],[1521543392327,["gengmei_pxf@gengmei123.local",[[1,6500,"public  class Node {  char val; Node left; Node right; public  Node(){} public  Node(int val) { this.val = val; } }"]],[6500,6500],[6615,6615]]],[1521543395719,["gengmei_pxf@gengmei123.local",[[1,6520,"\n"]],[6520,6520],[6521,6521]]],[1521543397710,["gengmei_pxf@gengmei123.local",[[1,6533,"\n"]],[6533,6533],[6534,6534]]],[1521543399277,["gengmei_pxf@gengmei123.local",[[1,6534,"\t"]],[6534,6534],[6535,6535]]],[1521543401190,["gengmei_pxf@gengmei123.local",[[1,6523,"\t"]],[6523,6523],[6524,6524]]],[1521543403182,["gengmei_pxf@gengmei123.local",[[1,6546,"\n"]],[6546,6546],[6547,6547]]],[1521543403870,["gengmei_pxf@gengmei123.local",[[1,6547,"\t"]],[6547,6547],[6548,6548]]],[1521543409278,["gengmei_pxf@gengmei123.local",[[-1,6548," "]],[6549,6549],[6548,6548]]],[1521543411382,["gengmei_pxf@gengmei123.local",[[1,6559,"\n"]],[6559,6559],[6560,6560]]],[1521543413108,["gengmei_pxf@gengmei123.local",[[1,6561,"\t"]],[6561,6561],[6562,6562]]],[1521543419704,["gengmei_pxf@gengmei123.local",[[1,6578,"\n"]],[6578,6578],[6579,6579]]],[1521543420553,["gengmei_pxf@gengmei123.local",[[1,6579,"\t"]],[6579,6579],[6580,6580]]],[1521543422262,["gengmei_pxf@gengmei123.local",[[-1,6580," "]],[6581,6581],[6580,6580]]],[1521543424737,["gengmei_pxf@gengmei123.local",[[1,6603,"\n"]],[6603,6603],[6604,6604]]],[1521543425344,["gengmei_pxf@gengmei123.local",[[1,6604,"\t"]],[6604,6604],[6605,6605]]],[1521543427536,["gengmei_pxf@gengmei123.local",[[1,6622,"\n"]],[6622,6622],[6623,6623]]],[1521543428424,["gengmei_pxf@gengmei123.local",[[1,6623,"\t"]],[6623,6623],[6624,6624]]],[1521543431576,["gengmei_pxf@gengmei123.local",[[1,6625,"\n"]],[6625,6625],[6626,6626]]],[1521543435696,["gengmei_pxf@gengmei123.local",[[1,6629,"\n"]],[6628,6628],[6629,6629]]],[1521543435854,["gengmei_pxf@gengmei123.local",[[1,6630,"\n"]],[6629,6629],[6630,6630]]],[1521543451921,["gengmei_pxf@gengmei123.local",[[1,6630,"di"]],[6630,6630],[6632,6632]]],[1521543453024,["gengmei_pxf@gengmei123.local",[[-1,6630,"di"]],[6632,6632],[6630,6630]]],[1521543455541,["gengmei_pxf@gengmei123.local",[[1,6630,"地柜"]],[6630,6630],[6632,6632]]],[1521543456255,["gengmei_pxf@gengmei123.local",[[-1,6630,"地柜"]],[6632,6632],[6630,6630]]],[1521543458602,["gengmei_pxf@gengmei123.local",[[1,6630,"递归"]],[6630,6630],[6632,6632]]],[1521543458943,["gengmei_pxf@gengmei123.local",[[1,6633,"\n"]],[6632,6632],[6633,6633]]],[1521543461397,["gengmei_pxf@gengmei123.local",[[1,6634,"\n"]],[6633,6633],[6634,6634]]],[1521543461747,["gengmei_pxf@gengmei123.local",[[1,6634,"static  int  calTreeHeight(Node root) { if (root == null) return  0; return Math.max(calTreeHeight(root.left), calTreeHeight(root.right)) + 1;"]],[6634,6634],[6776,6776]]],[1521543464663,["gengmei_pxf@gengmei123.local",[[1,6673,"\n"]],[6673,6673],[6674,6674]]],[1521543466415,["gengmei_pxf@gengmei123.local",[[1,6674,"\t"]],[6674,6674],[6675,6675]]],[1521543469934,["gengmei_pxf@gengmei123.local",[[1,6712,"\t\t"]],[6712,6712],[6714,6714]]],[1521543471895,["gengmei_pxf@gengmei123.local",[[1,6704,"\n"]],[6704,6704],[6705,6705]]],[1521543475071,["gengmei_pxf@gengmei123.local",[[-1,6675," "]],[6676,6676],[6675,6675]]],[1521543479473,["gengmei_pxf@gengmei123.local",[[1,6705,"   "]],[6705,6705],[6708,6708]]],[1521543486997,["gengmei_pxf@gengmei123.local",[[-1,6716,"\t"]],[6717,6717],[6716,6716]]],[1521543492160,["gengmei_pxf@gengmei123.local",[[1,6751,"\t\t "]],[6751,6751],[6754,6754]]],[1521543506102,["gengmei_pxf@gengmei123.local",[[-1,6749,", \t\t "]],[6754,6754],[6749,6749]]],[1521543508471,["gengmei_pxf@gengmei123.local",[[1,6749,", \t\t "]],[6749,6749],[6754,6754]]]]],["b471ec95-2fac-4b74-941b-4a04239a1ccd",1521598319689,"\n===\n\n## 匿名内部类与内部类的区别\n\n## 静态与非静态\n[java静态与非静态区别](http://www.cnblogs.com/itdev/p/5665531.html)\n\n这里的静态，指以static关键字修饰的，包括类，方法，块，字段。\n非静态，指没有用static 修饰的。\n\n### 静态有一些特点：\n\n* 1.全局唯一，任何一次的修改都是全局性的影响\n\n* 2.只加载一次，优先于非静态\n\n* 3.使用方式上不依赖于实例对象。\n\n* 4.生命周期属于类级别，从JVM 加载开始到JVM卸载结束。\n\n### 关于静态内部类（嵌套类）和非静态内部类的区别\n\n* （1）内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。\n\n* （2）非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。\n\n* （3）一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。\n\n## hashMap 原理，与hashMap类似的线程安全的数据集合\n\n[集合各实现类的底层实现原理](http://blog.csdn.net/qq_25868207/article/details/55259978)\n\n### HashMap实现原理要点概括\n\n参考文献：[http://zhangshixi.iteye.com/blog/672697](http://zhangshixi.iteye.com/blog/672697) \n参考文献：[http://blog.csdn.net/lizhongkaide/article/details/50595719](http://blog.csdn.net/lizhongkaide/article/details/50595719)\n\n* 1.  HashMap是基于哈希表的Map接口的非同步实现，允许使用null值和null键，但不保证映射的顺序。\n\n* 2.  底层使用数组实现，数组中每一项是个单向链表，即数组和链表的结合体；当链表长度大于一定阈值时，链表转换为红黑树，这样减少链表查询时间。\n\n* 3.  HashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Node对象。HashMap底层采用一个Node[]数组来保存所有的key-value对，当需要存储一个Node对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Node时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Node。\n\n* 4.  HashMap进行数组扩容需要重新计算扩容后每个元素在数组中的位置，很耗性能\n\n* 5.  采用了Fail-Fast机制，通过一个modCount值记录修改次数，对HashMap内容的修改都将增加这个值。迭代器初始化过程中会将这个值赋给迭代器的expectedModCount，在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map，马上抛出异常\n\n### Hashtable实现原理要点概括\n\n参考文献：[http://blog.csdn.net/zheng0518/article/details/42199477](http://blog.csdn.net/zheng0518/article/details/42199477)\n\n* 1.  Hashtable是基于哈希表的Map接口的同步实现，不允许使用null值和null键\n\n* 2.  底层使用数组实现，数组中每一项是个单链表，即数组和链表的结合体\n\n* 3.  Hashtable在底层将key-value当成一个整体进行处理，这个整体就是一个Entry对象。Hashtable底层采用一个Entry[]数组来保存所有的key-value对，当需要存储一个Entry对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。\n\n* 4.  synchronized是针对整张Hash表的，即每次锁住整张表让线程独占\n\n### ConcurrentHashMap实现原理要点概括\n\n参考文献：[http://blog.csdn.net/zheng0518/article/details/42199477](http://blog.csdn.net/zheng0518/article/details/42199477)\n\n* 1.  ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。\n\n* 2.  它使用了多个锁来控制对hash表的不同段进行的修改，每个段其实就是一个小的hashtable，它们有自己的锁。只要多个并发发生在不同的段上，它们就可以并发进行。\n\n* 3.  ConcurrentHashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Entry对象。Hashtable底层采用一个Entry[]数组来保存所有的key-value对，当需要存储一个Entry对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。\n\n* 4.  与HashMap不同的是，ConcurrentHashMap使用多个子Hash表，也就是段(Segment)\n\n* 5.  ConcurrentHashMap完全允许多个读操作并发进行，读操作并不需要加锁。如果使用传统的技术，如HashMap中的实现，如果允许可以在hash链的中间添加或删除元素，读操作不加锁将得到不一致的数据。ConcurrentHashMap实现技术是保证HashEntry几乎是不可变的。\n\n### LinkedHashMap实现原理要点概括\n\n参考文献：[http://zhangshixi.iteye.com/blog/673789l](http://zhangshixi.iteye.com/blog/673789)\n\n* 1.  LinkedHashMap继承于HashMap，底层使用哈希表和双向链表来保存所有元素，并且它是非同步，允许使用null值和null键。\n\n* 2.  基本操作与父类HashMap相似，通过重写HashMap相关方法，重新定义了数组中保存的元素Entry，来实现自己的链接列表特性。该Entry除了保存当前对象的引用外，还保存了其上一个元素before和下一个元素after的引用，从而构成了双向链接列表。\n\n## JAVA/Android 多线程实现方式及并发与同步\n（引申synchronize，volatile的使用）\n\n[JAVA\\Android 多线程实现方式及并发与同步](http://blog.csdn.net/csdn_aiyang/article/details/65442540)\n\n## Android中的设计模式\n（builder 创建模式设计的好处是啥）\n\n### 1 Builder模式概念\n\n#### 1 介绍\n\n　　Builder模式是一步一步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更精细地控制对象的构造流程。该模式是为了将构建复杂对象的过程和它的部件解耦，使得构建过程和部件的表示隔离开来。 \n　　Builder模式，在于分工明确，一个抽象建造者，一个具体的建造者，一个指挥者，当然还需要具体的产品。那么我们以一个软件产品为例：技术主管就是抽象建造者，他和产品经理沟通，知道要做一个什么样的产品；而程序员就是具体的劳动者，技术主管说咋做你就咋做；而指挥者就是公司的产品经理，负责和用户沟通，了解客户的需求。\n\n#### 2 定义\n\n　　将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n\n#### 3 使用场景\n\n*   相同的方法，不同的执行顺序，产生不同的事件结果时；\n*   多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时；\n*   产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适；\n*   当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值时。\n\n#### 4 使用Dialog\n \n　　在AlertDialog的Builder模式中并没有看到Director角色出现，并没按照标准的模式使用，而是做了一些修改。AlertDialog.Builder同时扮演了上下文提到的builder、ConcreteBuilder、Director的角色，简化了Builder模式的设计。\n\n#### 5 总结\n\n　　Builder模式在Android开发中也较为常用，通常作为配置类的构建器将配置的构建和表示分离开来，同时也是将配置从目标类中隔离出来，避免过多的setter方法。Builder模式比较常见的实现形式是通过调用链实现，这样使得代码更简洁、易懂，例如图片请求框架ImageLoader就是通过ImageLoaderConfig进行配置，这样避免了目标类中被过多的接口“污染”。\n\n##### 5.1 优点\n\n（1）良好的封装性， 使用建造者模式可以使客户端不必知道产品内部组成的细节； \n（2）建造者独立，容易扩展； \n（3）在对象创建过程中会使用到系统中的一些其它对象，这些对象在产品对象的创建过程中不易得到。\n\n##### 5.2 缺点\n\n（1）会产生多余的Builder对象以及Director对象，消耗内存； \n（2）对象的构建过程暴露。\n\n## Activity的启动模式\n\n## 对象的引用\n\n## Service的创建方式\n \n### 涉及到的问题\n\n* **面试的时候被问到这样一个问题，绑定server之后如果不解绑，程序会Crash吗？回去之后试了试，不会异常，但是会泄漏.**\n\n* 这种异常是直接bind之后退出程序（界面不可见出现问题，如果直接干掉程序是没问题的）\n\n* 不绑定直接退出，也会出异常 \n\n* **Service是远程服务，通过bind绑定主进程的Activity，没有unbind但是调用了stopService，会发生什么？怎么关闭远程Service**？\n\n**答案：Service没有解绑，也没有停止。\n当绑定的Activity退出，或者主进程杀死时，绑定会自动解除，Service停止**。\n\n[Android中Service的使用详解和注意点（LocalService）](https://www.cnblogs.com/linlf03/p/3296323.html)\n\n[Android Service整理－本地绑定和远程绑定](http://blog.csdn.net/wl455624651/article/details/41868915)\n\n### **特别注意**：\n\n* 1、你应当知道在调用 bindService 绑定到Service的时候，你就应当保证在某处调用 unbindService 解除绑定（尽管 Activity 被 finish 的时候绑定会自动解除，并且Service会自动停止）；\n\n* 2、你应当注意 使用 startService 启动服务之后，一定要使用 stopService停止服务，不管你是否使用bindService； \n\n* 3、同时使用 startService 与 bindService 要注意到，Service 的终止，需要unbindService与stopService同时调用，才能终止 Service，不管 startService 与 bindService 的调用顺序，如果先调用 unbindService 此时服务不会自动终止，再调用 stopService 之后服务才会停止，如果先调用 stopService 此时服务也不会终止，而再调用 unbindService 或者 之前调用 bindService 的 Context 不存在了（如Activity 被 finish 的时候）之后服务才会自动停止；\n\n* 4、当在旋转手机屏幕的时候，当手机屏幕在“横”“竖”变换时，此时如果你的 Activity 如果会自动旋转的话，旋转其实是 Activity 的重新创建，因此旋转之前的使用 bindService 建立的连接便会断开（Context 不存在了），对应服务的生命周期与上述相同。\n\n* 5、在 sdk 2.0 及其以后的版本中，对应的 onStart 已经被否决变为了 onStartCommand，不过之前的 onStart 任然有效。这意味着，如果你开发的应用程序用的 sdk 为 2.0 及其以后的版本，那么你应当使用 onStartCommand 而不是 onStart。\n\n* 6、由于服务进程是有可能在中途被杀死的，在客户端保持`mBound`布尔值来判断是否连接仍然健康是必要的，否则你应该监控是否有`DeadObjectException`的发生。\n\n* 7、**绑定Service后一定要在onStop或者onDestroy中调用`unBindService`释放连接，否则会有内存泄露。** 具体要和哪个生命周期进行搭配，取决于应用需要，参考[Managing the Activity Lifecycle](http://developer.android.com/training/basics/activity-lifecycle/index.html).\n\n* 8、当启动时，单独调用bindService方法，在unbindService后，会执行service的onUnbind，在执行onDestroy方法。\n \n* 9、当启动时，先调用startService，再调用bindService方法后，在unbindService后，会执行service的onUnbind，不会执行onDestroy方法。除非你在执行stopService.\n\n* 10、先调用startService，在调用stopService，会执行service的onDestroy方法。\n\n3.  **无论Service被多少个线程绑定，它都只会返回同一个IBinder实例。**\n\n## View的绘制流程\n\n## View的事件流程\n具体题目是 一个frameLayout中有1到6个View叠加，点击第3个View时，调用\n```\ndispatchTouchEvent(e){\n\tsuper.dispatchTouchEvent(e);\n\treturn true;\n}\n```\n说下整个事件的传递机制（事件会不会继续往下传，还是就消费了）\n**答案**：调用super（）里面还会调用很多子类的dispatchTouchEvent方法，所以事件会继续往下传\n\n## MVC，MVP与MVVM模式\n为什么选择这种模式\n\n## 算法（求不规则二叉树的高度）\n```\n二叉树结构定义为：\n\npublic  class Node {\n  \tchar val; \n\tNode left;\n\tNode right;\n \tpublic  Node(){}\n\tpublic  Node(int val) {\n\t this.val = val; \n\t}\n }\n\n递归\n\nstatic  int  calTreeHeight(Node root) {\n\tif (root == null) return  0;\n    return \tMath.max(calTreeHeight(root.left), \t\t calTreeHeight(root.right)) + 1;\n```",[[1521598310689,["gengmei_pxf@gengmei123.local",[[1,4270,"\n"]],[4268,4268],[4269,4269]]],[1521598311053,["gengmei_pxf@gengmei123.local",[[1,4271,"\n"]],[4269,4269],[4270,4270]]],[1521598313149,["gengmei_pxf@gengmei123.local",[[1,4270,"##  \n\n# [AlertDialog，Toast对Activity生命周期的影响](http://blog.csdn.net/u011348999/article/details/56011562)"]],[4270,4270],[4371,4371]]],[1521598315300,["gengmei_pxf@gengmei123.local",[[-1,4273," "],[1,4274," "],[-1,4276,"# "]],[4278,4278],[4276,4276]]],[1521598315653,["gengmei_pxf@gengmei123.local",[[-1,4275,"\n"]],[4276,4276],[4275,4275]]],[1521598316101,["gengmei_pxf@gengmei123.local",[[-1,4274,"\n"]],[4275,4275],[4274,4274]]],[1521598317269,["gengmei_pxf@gengmei123.local",[[-1,4273," "]],[4274,4274],[4273,4273]]],[1521598326220,["gengmei_pxf@gengmei123.local",[[-1,4273,"["]],[4274,4274],[4273,4273]]],[1521598329599,["gengmei_pxf@gengmei123.local",[[-1,4306,"](http://blog.csdn.net/u011348999/article/details/56011562)"]],[4306,4365],[4306,4306]]],[1521598330548,["gengmei_pxf@gengmei123.local",[[1,4308,"\n"]],[4306,4306],[4307,4307]]],[1521598331605,["gengmei_pxf@gengmei123.local",[[1,4309,"\n"]],[4307,4307],[4308,4308]]],[1521598342606,["gengmei_pxf@gengmei123.local",[[1,4308,"只有再启动另外一个Activity的时候才会进入onPause状态，而不是想象中的被覆盖或者不可见\n\n同时通过AlertDialog源码或者Toast源码我们都可以发现它们实现的原理都是windowmanager.addView();来添加的， 它们都是一个个view ,因此不会对activity的生命周期有任何影响。"]],[4308,4308],[4468,4468]]],[1521598359626,["gengmei_pxf@gengmei123.local",[[1,4470,"\n"]],[4468,4468],[4469,4469]]],[1521598359994,["gengmei_pxf@gengmei123.local",[[1,4471,"\n"]],[4469,4469],[4470,4470]]],[1521598376885,["gengmei_pxf@gengmei123.local",[[1,4470,"在我们创建对话框的时候,需要传入一个context类型的参数.这个参数也就说明我们的dialog是在这个上下文创建的,我们的activity也是正在交互的,并不会执行onPause的"]],[4470,4470],[4561,4561]]],[1521598383636,["gengmei_pxf@gengmei123.local",[[1,4308,"* "]],[4308,4308],[4310,4310]]],[1521598385974,["gengmei_pxf@gengmei123.local",[[1,4361,"* "]],[4361,4361],[4363,4363]]],[1521598387814,["gengmei_pxf@gengmei123.local",[[1,4474,"* "]],[4474,4474],[4476,4476]]]]]]}