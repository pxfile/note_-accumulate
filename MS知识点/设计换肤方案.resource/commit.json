{"compress":true,"commitItems":[["163c4b0b-6bc7-4246-abbe-c0d39cb33690",1521443414655,"",[[1521443376652,["gengmei_pxf@gengmei123.local",[[1,0,"设计换肤方案\n===\n\n\n##### **换肤介绍**\n\nApp换肤主要涉及的有页面中文字的颜色、控件的背景颜色、一些图片资源和主题颜色等资源。\n\n为了实现换肤资源不与原项目混淆，尽量降低风险，可以将这些资源封装在一个独立的Apk资源文件中。在App运行时，主程序动态的从Apk皮肤包中读取相应的资源，无需Acitvity重启即可实现皮肤的实时更换，皮肤包与原安装包相分离，从而实现插件式换肤。\n\n##### **换肤原理**\n\n###### **1. 如何加载皮肤资源文件**\n使用插件式换肤，皮肤资源肯定不会在被封装到主工程中，要怎么加载外部的皮肤资源呢？\n\n先看下 Apk 的打包流程\n![Apk 的打包流程](https://images2018.cnblogs.com/blog/561894/201711/561894-20171129112116909-329161900.png)\n\n这里流程中，有两个关键点\n\n* 1.R文件的生成\n\nR文件是一个Java文件，通过R文件我们就可以找到对应的资源。R文件就像一张映射表，帮助我们找到资源文件。\n\n* 2.资源文件的打包生成\n\n资源文件经过压缩打包，生成 resources 文件，通过R文件找到里面保存的对映的资源文件。在 App 内部，我们一般通过下面代码，获取资源：\n\n```\ncontext.getResource.getString(R.string.hello);\ncontext.getResource.getColor(R.color.black);\ncontext.getResource.getDrawable(R.drawable.splash);\n```\n这个时获取 App 内部的资源，能我们家在皮肤资源什么思路吗？加载外部资源的 Resources 能通过类似的思路吗？\n我们查看下 Resources 类的源码，发现 Resources 的构造函数\n\n```\npublic Resources(AssetManager assets, DisplayMetrics metrics, Configuration config) {\n      this(assets, metrics, config, CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO);\n  }\n```\n这里关键是第一个参数如何获取，第二和第三个参数可以通过 Activity 获取到。我们再去看下 AssetManager 的代码，同时会发现下面的这个\n\n```\n/**\n     * Add an additional set of assets to the asset manager.  This can be\n     * either a directory or ZIP file.  Not for use by applications.  Returns\n     * the cookie of the added asset, or 0 on failure.\n     * {@hide}\n     */\n  public final int addAssetPath(String path) {\n        synchronized (this) {\n            int res = addAssetPathNative(path);\n            makeStringBlocks(mStringBlocks);\n            return res;\n        }\n    }\n```\nAssetManager 可以加载一个zip 格式的压缩包，而 Apk 文件不就是一个 压缩包吗。我们通过反射的方法，拿到 AssetManager，加载 Apk 内部的资源，获取到 Resources 对象，这样再想办法，把 R文件里面保存的ID获取到，这样既可以拿到对应的资源文件了。理论上我们的思路时成立的。\n我们看下，如何通过代码获取 Resources 对象。\n```\nAssetManager assetManager = AssetManager.class.newInstance();\nMethod addAssetPath = assetManager.getClass().getMethod(\"addAssetPath\", String.class);\naddAssetPath.invoke(assetManager, skinPkgPath);\n \nResources superRes = context.getResources();\nResources skinResource = new Resources(assetManager,superRes.getDisplayMetrics(),superRes.getConfiguration());\n```\n###### **2.如何标记需要换肤的View**\n找到资源文件之后，我们要接着标记需要换肤的 View 。\n\n找到需要换肤的 View\n怎么寻找哪些是我们要关注的 View 呢？ 我们还是重 View 的创建时机寻找机会。我们添加一个布局文件时，会使用 LayoutInflater的 Inflater方法，我们看下这个方法是怎么讲一个View添加到Activity 中的。\nLayoutInflater 中有个接口\n```\npublic interface Factory {\n        /**\n         * Hook you can supply that is called when inflating from a LayoutInflater.\n         * You can use this to customize the tag names available in your XML\n         * layout files.\n         *\n         * <p>\n         * Note that it is good practice to prefix these custom names with your\n         * package (i.e., com.coolcompany.apps) to avoid conflicts with system\n         * names.\n         *\n         * @param name Tag name to be inflated.\n         * @param context The context the view is being created in.\n         * @param attrs Inflation attributes as specified in XML file.\n         *\n         * @return View Newly created view. Return null for the default\n         *         behavior.\n         */\n        public View onCreateView(String name, Context context, AttributeSet attrs);\n    }\n```\n根据这里的注释描述，我们可以自己实现这个接口，在 onCreateView 方法中选择我们需要标记的View，根据 AttributeSet 值，过滤不需要关注的View。\n\n**标记 View 与对应的资源**\n\n我们在 View 创建时，通过过滤 Attribute 属性，找到我们要标记的 View ，下面我们就把这些View的属性记下来\n```\nfor (int i = 0; i < attrs.getAttributeCount(); i++){\n            String attrName = attrs.getAttributeName(i);\n            String attrValue = attrs.getAttributeValue(i);\n            if(!AttrFactory.isSupportedAttr(attrName)){\n                continue;\n            } \n            if(attrValue.startsWith(\"@\")){\n                try {\n                    int id = Integer.parseInt(attrValue.substring(1));\n                    String entryName = context.getResources().getResourceEntryName(id);\n                    String typeName = context.getResources().getResourceTypeName(id);\n                    SkinAttr mSkinAttr = AttrFactory.get(attrName, id, entryName, typeName);\n                    if (mSkinAttr != null) {\n                        viewAttrs.add(mSkinAttr);\n                    }\n                } catch (NumberFormatException e) {\n                    e.printStackTrace();\n                } catch (NotFoundException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n```\n然后把这些 View 和属性值，一起封装保存起来\n```\nif(!ListUtils.isEmpty(viewAttrs)){\n            SkinItem skinItem = new SkinItem();\n            skinItem.view = view;\n            skinItem.attrs = viewAttrs;\n            mSkinItems.add(skinItem);\n            if(SkinManager.getInstance().isExternalSkin()){\n                skinItem.apply();\n            }\n    }\n```\n###### **3.如何做到及时更新UI**\n由于我们把需要更新的View 以及属性值都保存起来了，更新的时候只要把他们取出来遍历一遍即可。\n```\n@Override\n    public void onThemeUpdate() {\n        if(!isResponseOnSkinChanging){\n            return;\n        }\n        mSkinInflaterFactory.applySkin();\n    }\n```\n//applySkin 的具体实现\n\n```\npublic void applySkin(){\n        if(ListUtils.isEmpty(mSkinItems)){\n            return;\n        }  \n        for(SkinItem si : mSkinItems){\n            if(si.view == null){\n                continue;\n            }\n            si.apply();\n        }\n    }\n```\n###### **4.如何制作皮肤包**\n皮肤包制作相对简单\n\n* 1.创建独立工程 model，包名任意。\n\n* 2.添加资源文件到 model 中,不需要 java 代码\n\n* 3.运行 build.gradle 脚本，打包命令，生成apk文件，修改名称为 xxx.skin 皮肤包即可。\n"]],[0,0],[5341,5341]]],[1521443379929,["gengmei_pxf@gengmei123.local",[[-1,15,"###"]],[18,18],[15,15]]],[1521443385233,["gengmei_pxf@gengmei123.local",[[-1,198,"###"]],[197,200],[197,197]]],[1521443392393,["gengmei_pxf@gengmei123.local",[[-1,2078,"####"]],[2082,2082],[2078,2078]]],[1521443398185,["gengmei_pxf@gengmei123.local",[[-1,4667,"###"]],[4670,4670],[4667,4667]]],[1521443402136,["gengmei_pxf@gengmei123.local",[[-1,5184,"###"]],[5187,5187],[5184,5184]]],[1521443408768,["gengmei_pxf@gengmei123.local",[[-1,212,"###"]],[215,215],[212,212]]],[1521443412562,["gengmei_pxf@gengmei123.local",[[1,2075,"#"]],[2075,2075],[2076,2076]]],[1521443445970,["gengmei_pxf@gengmei123.local",[[1,12,"# [Android App插件式换肤实现方案](http://www.cnblogs.com/lzh-Linux/p/7919462.html)"]],[12,12],[85,85]]],[1521443447861,["gengmei_pxf@gengmei123.local",[[-1,12,"# "]],[14,14],[12,12]]],[1521443451188,["gengmei_pxf@gengmei123.local",[[1,84,"\n"]],[83,83],[84,84]]],[1521443478926,["gengmei_pxf@gengmei123.local",[[1,85,"\n"]],[84,84],[85,85]]],[1521443479261,["gengmei_pxf@gengmei123.local",[[1,86,"\n"]],[85,85],[86,86]]],[1521443480792,["gengmei_pxf@gengmei123.local",[[1,85,"# android 换肤（1）——插件式无缝换肤（解析鸿洋大神的换肤流程）"]],[85,85],[122,122]]],[1521443484221,["gengmei_pxf@gengmei123.local",[[-1,85,"# "]],[87,87],[85,85]]],[1521443485663,["gengmei_pxf@gengmei123.local",[[1,85,"["]],[85,85],[86,86]]],[1521443489725,["gengmei_pxf@gengmei123.local",[[-1,120,"）"]],[121,121],[120,120]]],[1521443492943,["gengmei_pxf@gengmei123.local",[[1,120,")]()"]],[120,120],[124,124]]],[1521443500919,["gengmei_pxf@gengmei123.local",[[1,123,"http://blog.csdn.net/yehui928186846/article/details/51569602"]],[123,123],[183,183]]],[1521443502268,["gengmei_pxf@gengmei123.local",[[1,186,"\n"]],[184,184],[185,185]]],[1521443502540,["gengmei_pxf@gengmei123.local",[[1,187,"\n"]],[185,185],[186,186]]],[1521443516263,["gengmei_pxf@gengmei123.local",[[1,186," [## android 换肤（2）——插件式无缝换肤（解析鸿洋大神的换肤流程）](http://blog.csdn.net/yehui928186846/article/details/51570503)"]],[186,186],[289,289]]],[1521443519004,["gengmei_pxf@gengmei123.local",[[-1,188,"## "]],[191,191],[188,188]]]]]]}