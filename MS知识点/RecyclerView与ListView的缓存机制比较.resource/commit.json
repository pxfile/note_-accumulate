{"compress":true,"commitItems":[["48375a8a-2780-4e11-93e8-68e951c17ea5",1521185705262,"",[[1521185666392,["gengmei_pxf@gengmei123.local",[[1,0,"RecyclerView与ListView的缓存机制比较\n===\n\n\n原文链接1、[Bugly-Android ListView 与 RecyclerView 对比浅析--缓存机制](https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653578065&idx=2&sn=25e64a8bb7b5934cf0ce2e49549a80d6&chksm=84b3b156b3c43840061c28869671da915a25cf3be54891f040a3532e1bb17f9d32e244b79e3f&scene=21#wechat_redirect)\n\n原文链接2、[RecyclerView 必知必会](https://mp.weixin.qq.com/s/CzrKotyupXbYY6EY2HP_dA)"]],[0,0],[385,385]]],[1521185669365,["gengmei_pxf@gengmei123.local",[[-1,35,"原文链接"]],[39,39],[35,35]]],[1521185669589,["gengmei_pxf@gengmei123.local",[[-1,34,"\n"]],[35,35],[34,34]]],[1521185671280,["gengmei_pxf@gengmei123.local",[[1,34,"* "]],[34,34],[36,36]]],[1521185675519,["gengmei_pxf@gengmei123.local",[[-1,306,"原文链接"],[1,310,"* "]],[306,310],[308,308]]],[1521185679156,["gengmei_pxf@gengmei123.local",[[1,380,"\n\n"]],[380,380],[381,381]]],[1521185679493,["gengmei_pxf@gengmei123.local",[[1,382,"\n"]],[381,381],[382,382]]],[1521185766306,["gengmei_pxf@gengmei123.local",[[1,382,"### RecyclerView回收机制\n\nRecyclerView和ListView的回收机制非常相似，但是ListView是以View作为单位进行回收，RecyclerView是以ViewHolder作为单位进行回收。Recycler是RecyclerView回收机制的实现类，他实现了四级缓存：\n\n*   mAttachedScrap: 缓存在屏幕上的ViewHolder。\n\n*   mCachedViews: 缓存屏幕外的ViewHolder，默认为2个。ListView对于屏幕外的缓存都会调用`getView()`。\n\n*   mViewCacheExtensions: 需要用户定制，默认不实现。\n\n*   mRecyclerPool: 缓存池，多个RecyclerView共用。\n\n在上文Layout Manager中已经介绍了RecyclerView的layout过程，但是一笔带过了`getViewForPosition()`，因此此处介绍该方法的实现。\n\n![](http://mmbiz.qpic.cn/mmbiz_png/tnZGrhTk4deAcQicPF0tHqZw2kX1iaHP9bY7lgSD8wkOK4yQ7Y47EXWcib7vaMDHJxUfxJa4euV39q7ibicCfy1Izpw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)\n\n从上述实现可以看出，依次从mAttachedScrap, mCachedViews, mViewCacheExtension, mRecyclerPool寻找可复用的ViewHolder，如果是从mAttachedScrap或mCachedViews中获取的ViewHolder，则不会调用`onBindViewHolder()`，mAttachedScrap和mCachedViews也就是我们所说的Scrap Heap；而如果从mViewCacheExtension或mRecyclerPool中获取的ViewHolder，则会调用`onBindViewHolder()`。\n\nRecyclerView局部刷新的实现原理也是基于RecyclerView的回收机制，即能直接复用的ViewHolder就不调用`onBindViewHolder()`。"]],[382,382],[1369,1369]]],[1521185774294,["gengmei_pxf@gengmei123.local",[[-1,384,"#"]],[385,385],[384,384]]],[1521185843235,["gengmei_pxf@gengmei123.local",[[1,1369,"\n"]],[1368,1368],[1369,1369]]],[1521185843443,["gengmei_pxf@gengmei123.local",[[1,1370,"\n"]],[1369,1369],[1370,1370]]],[1521185844071,["gengmei_pxf@gengmei123.local",[[1,1370,"RecyclerView 缓存机制（Recycler）大致可以分为5级。 \n第一级 通过mChangedScrap匹配 position或者id获取holder缓存。 \n第二级 从mAttachedScrap中通过匹配position获取holder缓存，或者通过ChildHelper找到隐藏但是没有被移除的View，通过getChildViewHolderInt(view)方法获取holder缓存，或者 \n从mCachedViews中通过匹配position获取holder缓存。 \n第三级 从mAttachedScrap中通过匹配id获取holder缓存，或者 \n从mCachedViews中通过匹配id获取holder缓存。 \n第四级 从ViewCacheExtension获取holder缓存。 \n第五级 通过RecyclerView 的ViewHolder缓存池获取holder。"]],[1370,1370],[1767,1767]]],[1521185863594,["gengmei_pxf@gengmei123.local",[[1,1369,"总结"],[-1,1406," "],[1,1407," "],[-1,1453," "],[1,1454," "],[-1,1574," "],[1,1575," "],[-1,1613," "],[1,1614," "],[-1,1654," "],[1,1655," "],[-1,1687," "],[1,1688," "],[-1,1723," "],[1,1724," RecyclerView 缓存机制"]],[1369,1369],[1388,1388]]],[1521185867514,["gengmei_pxf@gengmei123.local",[[1,1369,"### "]],[1369,1369],[1373,1373]]],[1521185869671,["gengmei_pxf@gengmei123.local",[[1,1369,"\n"]],[1368,1368],[1369,1369]]],[1521185879976,["gengmei_pxf@gengmei123.local",[[1,1394,"\n"]],[1394,1394],[1395,1395]]],[1521185883674,["gengmei_pxf@gengmei123.local",[[1,1433,"* "]],[1433,1433],[1435,1435]]],[1521185885873,["gengmei_pxf@gengmei123.local",[[1,1482,"* "]],[1482,1482],[1484,1484]]],[1521185888550,["gengmei_pxf@gengmei123.local",[[1,1644,"* "]],[1644,1644],[1646,1646]]],[1521185890255,["gengmei_pxf@gengmei123.local",[[1,1482,"\n"]],[1482,1482],[1483,1483]]],[1521185891819,["gengmei_pxf@gengmei123.local",[[1,1645,"\n"]],[1645,1645],[1646,1646]]],[1521185893635,["gengmei_pxf@gengmei123.local",[[1,1722,"* "]],[1722,1722],[1724,1724]]],[1521185895581,["gengmei_pxf@gengmei123.local",[[1,1722,"\n"]],[1722,1722],[1723,1723]]],[1521185897152,["gengmei_pxf@gengmei123.local",[[1,1761,"* "]],[1761,1761],[1763,1763]]],[1521185909668,[null,[[1,1376,"RecyclerView 缓存机制\n"],[-1,1394,"\n"],[1,1416,"* "],[-1,1433,"* "],[1,1465,"\n* "],[-1,1482,"\n* "],[1,1628,"\n* "],[-1,1645,"\n* "],[1,1705,"\n* "],[-1,1722,"\n* "],[-1,1743,"RecyclerView 缓存机制"]],[1376,1376],[1743,1743]]],[1521185909668,[null,[[-1,1376,"RecyclerView 缓存机制\n"],[1,1412,"\n"],[-1,1433,"* "],[1,1452,"* "],[-1,1482,"\n* "],[1,1502,"\n* "],[-1,1645,"\n* "],[1,1665,"\n* "],[-1,1722,"\n* "],[1,1742,"\n* "],[1,1760,"RecyclerView 缓存机制"]],[1743,1743],[1376,1376]]],[1521185906398,["gengmei_pxf@gengmei123.local",[[1,1761,"\n"]],[1761,1761],[1762,1762]]],[1521185932832,[null,[[1,1376,"RecyclerView 缓存机制\n"],[-1,1394,"\n"],[1,1416,"* "],[-1,1433,"* "],[1,1465,"\n* "],[-1,1482,"\n* "],[1,1628,"\n* "],[-1,1645,"\n* "],[1,1705,"\n* "],[-1,1722,"\n* "],[-1,1743,"RecyclerView 缓存机制"]],[1376,1376],[1743,1743]]],[1521185932832,[null,[[-1,1376,"RecyclerView 缓存机制\n"],[1,1412,"\n"],[-1,1433,"* "],[1,1452,"* "],[-1,1482,"\n* "],[1,1502,"\n* "],[-1,1645,"\n* "],[1,1665,"\n* "],[-1,1722,"\n* "],[1,1742,"\n* "],[1,1760,"RecyclerView 缓存机制"]],[1743,1743],[1376,1376]]],[1521185918134,["gengmei_pxf@gengmei123.local",[[1,1807,"\n"]],[1806,1806],[1807,1807]]],[1521185918406,["gengmei_pxf@gengmei123.local",[[1,1808,"\n"]],[1807,1807],[1808,1808]]],[1521185925982,["gengmei_pxf@gengmei123.local",[[-1,1808,"\n"],[1,1809,"## RecyclerView回收机制"]],[1808,1808],[1827,1827]]],[1521185927544,["gengmei_pxf@gengmei123.local",[[-1,1811,"RecyclerView"],[1,1823,"L"]],[1811,1823],[1811,1812]]],[1521185927795,["gengmei_pxf@gengmei123.local",[[1,1812,"i"]],[1811,1812],[1811,1813]]],[1521185928005,["gengmei_pxf@gengmei123.local",[[1,1813,"s"]],[1811,1813],[1811,1814]]],[1521185928221,["gengmei_pxf@gengmei123.local",[[1,1814,"t"]],[1811,1814],[1811,1815]]],[1521185928933,["gengmei_pxf@gengmei123.local",[[1,1815,"V"]],[1811,1815],[1811,1816]]],[1521185929103,["gengmei_pxf@gengmei123.local",[[1,1816,"i"]],[1811,1816],[1811,1817]]],[1521185929231,["gengmei_pxf@gengmei123.local",[[1,1817,"e"]],[1811,1817],[1811,1818]]],[1521185929349,["gengmei_pxf@gengmei123.local",[[1,1818,"w"]],[1811,1818],[1811,1819]]],[1521185931492,["gengmei_pxf@gengmei123.local",[[1,1823,"\n\n"]],[1823,1823],[1824,1824]]],[1521185931987,["gengmei_pxf@gengmei123.local",[[1,1825,"\n"]],[1824,1824],[1825,1825]]],[1521186952865,[null,[[1,1376,"RecyclerView 缓存机制\n"],[-1,1394,"\n"],[1,1416,"* "],[-1,1433,"* "],[1,1465,"\n* "],[-1,1482,"\n* "],[1,1628,"\n* "],[-1,1645,"\n* "],[1,1705,"\n* "],[-1,1722,"\n* "],[-1,1743,"RecyclerView 缓存机制"]],[1376,1376],[1743,1743]]],[1521186952865,[null,[[-1,1376,"RecyclerView 缓存机制\n"],[1,1412,"\n"],[-1,1433,"* "],[1,1452,"* "],[-1,1482,"\n* "],[1,1502,"\n* "],[-1,1645,"\n* "],[1,1665,"\n* "],[-1,1722,"\n* "],[1,1742,"\n* "],[1,1760,"RecyclerView 缓存机制"]],[1743,1743],[1376,1376]]],[1521186911394,["gengmei_pxf@gengmei123.local",[[1,1826,"\n"]],[1823,1823],[1824,1824]]],[1521186911794,["gengmei_pxf@gengmei123.local",[[1,1827,"\n"]],[1824,1824],[1825,1825]]],[1521186912441,["gengmei_pxf@gengmei123.local",[[1,1825,"**RecycleBin缓存机制）**\n\nListView这么厉害的原因，其中一部分就是因为RecycleBin缓存机制。RecycleBin缓存机制是写在AbsListView的一个内部类。所以ListView继承于AbsListView，也继承了这股力量。让我们看看它的内部几个重要的变量和方法：\n\n变量： \n1. `private View[] mActiveViews` : 缓存屏幕上可见的view \n2. `private int mViewTypeCount` : ListView中的子view的不同布局类型总数 \n3. `ArrayList<View>[] mScrapViews` : ListView中所有的废弃缓存。注意，这是一个数组。在ListView中，每种childView布局类型都会单独启用一个RecycleBin缓存机制。所以数组中的每一项ArrayList都对应着一种childView布局类型的废弃缓存。 \n4. `ArrayList<View> mCurrentScrap` : 当前childView布局类型下的废弃缓存。\n\n方法： \n1. `void fillActiveViews ()` : 此方法会将ListView中的指定元素存储到mActiveViews数组当中。 \n2. `View getActiveView ()` : 从mActiveViews中获取指定的元素。取出view后，在mActiveViews里的该指定位置将被置空。所以这个mActiveViews只能使用一次，并不能复用。 \n3. `void addScrapView ()` : 将一个废弃的view进行缓存。如果childView的布局类型只有一项，就直接缓存到mCurrentScrap。如果多种布局，则从mScrapViews找到相对应的废弃缓存ArrayList并缓存view。 \n4. `View getScrapView ()` : 从废弃缓存中取出一个View。同理，如果childView的布局类型只有一项，就直接从mCurrentScrap中取。如果多种布局，则从mScrapViews找到相对应的缓存ArrayList再取出view。 \n5. `void setViewTypeCount ()` : 为mViewTypeCount设置childView布局类型总数，并为每种类型的childView单独启用一个RecycleBin缓存机制。\n\n只是简单介绍了这几个重要的方法，可能大伙看得也是糊里糊涂的。或许有疑问，这个mActiveViews与mCurrentScrap有点相似，好像都是缓存view的。但它俩的区别在哪呢？莫急，等下会一一解答。\n\n先来说说**RecycleBin缓存机制的工作原理**： \nListView每当一项子view滑出界面时，RecycleBin会调用addScrapView()方法将这个废弃的子view进行缓存。每当子view滑入界面时，RecycleBin会调用getScrapView()方法获取一个废弃已缓存的view。所以我们再看回Adapter的`getView()`方法：\n\n```java\n@Override  \npublic View getView(int position, View convertView, ViewGroup parent) {   \n    View view;  \n    if (convertView == null) {  \n        view = LayoutInflater.from(context).inflate(resourceId, null);  \n        ······\n    } else {  \n        view = convertView;  \n    }   \n    ······\n    return view;  \n} 123456789101112\n```\n\n这个convertView是什么？convertView就是RecycleBin缓存机制调用getScrapView()方法获取废弃已缓存的view。`getView()`方法中有个判断，`if (convertView == null)`，当convertView为空，也就是没有废弃已缓存的view时，将调用LayoutInflater的inflate()方法加载出来布局view，这个操作是比较耗时的；当convertView不为空时，我们就直接用convertView了，而不需要再次调用LayoutInflater的inflate()方法加载出来布局view。所以如果我们没利用convertView，成千上万条数据，所有的视图都是调用LayoutInflater的inflate()方法去创建布局view的话，想想就知道这样的ListView的性能是多么的糟糕了，ListView的强大就大大打折扣了，所谓的洪荒之力也就没有了。 \n简单了解了RecycleBin缓存机制，接下来让我们看看ListView的工作原理："]],[1825,1825],[3967,3967]]],[1521186915372,["gengmei_pxf@gengmei123.local",[[-1,1841,"）"],[1,1842,""],[-1,1980," \n1. "],[1,1985," \n1. "],[-1,2014," "],[1,2015," "],[-1,2029," \n2. "],[1,2034," \n2. "],[-1,2062," "],[1,2063," "],[-1,2089," \n3. "],[1,2094," \n3. "],[-1,2125," "],[1,2126," "],[-1,2247," \n4. "],[1,2252," \n4. "],[-1,2283," "],[1,2284," "],[-1,2313," \n1. "],[1,2318," \n1. "],[-1,2343," "],[1,2344," "],[-1,2385," \n2. "],[1,2390," \n2. "],[-1,2413," "],[1,2414," "],[-1,2500," \n3. "],[1,2505," \n3. "],[-1,2527," "],[1,2528," "],[-1,2633," \n4. "],[1,2638," \n4. "],[-1,2660," "],[1,2661," "],[-1,2767," \n5. "],[1,2772," \n5. "],[-1,2798," "],[1,2799," "],[-1,3005," "],[1,3006," "],[-1,3923," "],[1,3924," "]],[1842,1842],[1841,1841]]],[1521186928667,["gengmei_pxf@gengmei123.local",[[1,1976,"* "]],[1976,1976],[1978,1978]]],[1521186932163,["gengmei_pxf@gengmei123.local",[[1,2311,"* "]],[2311,2311],[2313,2313]]],[1521186939249,["gengmei_pxf@gengmei123.local",[[1,3010,"\n"]],[3010,3010],[3011,3011]]],[1521186948137,["gengmei_pxf@gengmei123.local",[[-1,3486,"123456789101112"]],[3486,3501],[3486,3486]]],[1521186957708,[null,[[1,1376,"RecyclerView 缓存机制\n"],[-1,1394,"\n"],[1,1416,"* "],[-1,1433,"* "],[1,1465,"\n* "],[-1,1482,"\n* "],[1,1628,"\n* "],[-1,1645,"\n* "],[1,1705,"\n* "],[-1,1722,"\n* "],[-1,1743,"RecyclerView 缓存机制"]],[1376,1376],[1743,1743]]],[1521186957708,[null,[[-1,1376,"RecyclerView 缓存机制\n"],[1,1412,"\n"],[-1,1433,"* "],[1,1452,"* "],[-1,1482,"\n* "],[1,1502,"\n* "],[-1,1645,"\n* "],[1,1665,"\n* "],[-1,1722,"\n* "],[1,1742,"\n* "],[1,1760,"RecyclerView 缓存机制"]],[1743,1743],[1376,1376]]],[1521186955849,["gengmei_pxf@gengmei123.local",[[-1,3914,"简单了解了RecycleBin缓存机制，接下来让我们看看ListView的工作原理："]],[3914,3956],[3914,3914]]],[1521187797736,[null,[[1,1376,"RecyclerView 缓存机制\n"],[-1,1394,"\n"],[1,1416,"* "],[-1,1433,"* "],[1,1465,"\n* "],[-1,1482,"\n* "],[1,1628,"\n* "],[-1,1645,"\n* "],[1,1705,"\n* "],[-1,1722,"\n* "],[-1,1743,"RecyclerView 缓存机制"]],[1376,1376],[1743,1743]]],[1521187797736,[null,[[-1,1376,"RecyclerView 缓存机制\n"],[1,1412,"\n"],[-1,1433,"* "],[1,1452,"* "],[-1,1482,"\n* "],[1,1502,"\n* "],[-1,1645,"\n* "],[1,1665,"\n* "],[-1,1722,"\n* "],[1,1742,"\n* "],[1,1760,"RecyclerView 缓存机制"]],[1743,1743],[1376,1376]]],[1521187780539,["gengmei_pxf@gengmei123.local",[[1,1825,"\n"]],[1823,1823],[1824,1824]]],[1521187781604,["gengmei_pxf@gengmei123.local",[[1,1824,"【】"]],[1824,1824],[1826,1826]]],[1521187782508,["gengmei_pxf@gengmei123.local",[[-1,1824,"【】"]],[1826,1826],[1824,1824]]],[1521187783382,["gengmei_pxf@gengmei123.local",[[1,1824,"[]"]],[1824,1824],[1826,1826]]],[1521187784581,["gengmei_pxf@gengmei123.local",[[1,1825,"# 解析Android ListView工作原理及其缓存机制"]],[1825,1825],[1855,1855]]],[1521187790338,["gengmei_pxf@gengmei123.local",[[-1,1825,"# "]],[1827,1827],[1825,1825]]],[1521187792683,["gengmei_pxf@gengmei123.local",[[1,1854,"()"]],[1854,1854],[1856,1856]]],[1521187804103,[null,[[1,1376,"RecyclerView 缓存机制\n"],[-1,1394,"\n"],[1,1416,"* "],[-1,1433,"* "],[1,1465,"\n* "],[-1,1482,"\n* "],[1,1628,"\n* "],[-1,1645,"\n* "],[1,1705,"\n* "],[-1,1722,"\n* "],[-1,1743,"RecyclerView 缓存机制"]],[1376,1376],[1743,1743]]],[1521187804103,[null,[[-1,1376,"RecyclerView 缓存机制\n"],[1,1412,"\n"],[-1,1433,"* "],[1,1452,"* "],[-1,1482,"\n* "],[1,1502,"\n* "],[-1,1645,"\n* "],[1,1665,"\n* "],[-1,1722,"\n* "],[1,1742,"\n* "],[1,1760,"RecyclerView 缓存机制"]],[1743,1743],[1376,1376]]],[1521187799925,["gengmei_pxf@gengmei123.local",[[1,1855,"http://blog.csdn.net/libmill/article/details/49644743"]],[1855,1855],[1908,1908]]],[1521187802492,["gengmei_pxf@gengmei123.local",[[1,1824,"\n"]],[1823,1823],[1824,1824]]]]]]}