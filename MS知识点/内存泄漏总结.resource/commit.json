{"compress":true,"commitItems":[["a463ece1-eb15-4e63-88b2-42c90301613a",1518596244203,"",[[1518596202080,["gengmei_pxf@gengmei123.local",[[1,0,"Android内存泄漏 === 传统的内存泄漏是由忘记释放分配的内存导致的，而逻辑上的内存泄漏则是由于忘记在对象不再被使用的时候释放对其的引用导致的。\n\n## 静态的Activity\n  activity 类中定义一个 static 变量，并且将其指向一个[运行中的 activity 实例](https://github.com/NimbleDroid/Memory-Leaks/blob/master/app/src/main/java/com/nimbledroid/memoryleaks/MainActivity.java#L110)。如果在 activity 的生命周期结束之前，没有清除这个引用，那它就会泄漏了。这是因为 activity（例如 MainActivity） 的类对象是静态的，一旦加载，就会在 APP 运行时一直常驻内存，因此如果类对象不卸载，其静态成员就不会被垃圾回收。\n\n## 静态View 一旦 view 被加入到界面中，它就会持有 context 的强引用，也就是我们的 activity。由于我们通过一个静态成员引用了这个 view，所以我们也就引用了 activity，因此 activity 就发生了泄漏。所以一定不要把加载的 view 赋值给静态变量，如果你真的需要，那一定要确保在 activity 销毁之前[将其从 view 层级中移除](http://developer.android.com/reference/android/view/ViewGroup.html#removeView(android.view.View))。\n\n## 内部类 非静态内部类（包括匿名内部类）默认就会持有外部类的引用，当非静态内部类对象的生命周期比外部类对象的生命周期长时，就会导致内存泄露。\n\n## Handlers [定义一个匿名的 Runnable 对象并将其提交到 Handler 上](https://github.com/NimbleDroid/Memory-Leaks/blob/master/app/src/main/java/com/nimbledroid/memoryleaks/MainActivity.java#L114)也可能导致 activity 泄漏。Runnable 对象间接地引用了定义它的 activity 对象，而它会被提交到 Handler 的 MessageQueue 中，如果它在 activity 销毁时还没有被处理，那就会导致 activity 泄漏了。\n\n## Threads和Timer Tasks 只要它们是通过匿名类创建的，尽管它们在单独的线程被执行，它们也会持有对 activity 的强引用，进而导致内存泄漏。\n\n## Sensor Manager 系统服务可以通过 [context.getSystemService](http://developer.android.com/reference/android/content/Context.html#getSystemService(java.lang.String)) 获取，它们负责执行某些后台任务，或者为硬件访问提供接口。如果 context 对象想要在服务内部的事件发生时被通知，那就需要把自己注册到服务的[监听器](https://github.com/NimbleDroid/Memory-Leaks/blob/master/app/src/main/java/com/nimbledroid/memoryleaks/MainActivity.java#L136)中。然而，这会让服务持有 activity 的引用，如果程序员忘记在 activity 销毁时取消注册，那就会导致 activity 泄漏了。\n\n内存泄露 ===     ## 定义 内存泄露是指无用对象(不再使用的对象)持续占有内存或无用对象的内存得不到及时释放，从而造成的内存空间的浪费称为内存泄露。\n\n## 原因 长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，\n这就是`java`中内存泄露的发生场景。\n\n## 危害 只有一个，那就是虚拟机占用内存过高，导致`OOM`(内存溢出)。\n对于`Android`应用来说，就是你的用户打开一个`Activity`，使用完之后关闭它，内存泄露；又打开，又关闭，又泄露；几次之后，程序占用内存超过系统限制就会出现`FC`。             \n\n先来说一下`Java`程序运行时的内存分配策略:        \n\n- 静态内存:存放静态数据，这块内存是在编译时就已经分配好的，在程序整个运行期间都存在。\n- 栈内存:程序执行时，局部变量的创建存储区，执行结束后将自动释放。(当时学习java时花的内存分配图，现在都生疏了- -!)\n- 堆内存:存储一些new出来的内存，也叫动态内存分配，这部分内存在不使用时将会有`Java`垃圾回收器来负责回收。    \n\n举一个典型的内存泄漏的例子:     \n``` Vector v = new Vector(100); for (int i = 1; i < 100,; i++) {\n Object o = new Object(); v.add(o); o = null; } ``` 在这个例子中，我们循环申请了`Object`对象，并将所申请的对象放入一个集合中，如果我们仅仅释放引用本身，那么`Vector`仍然引用\n该对象，所以这个对象对`GC`来说是不可回收的。因此，如果对象假如`Vector`后，还必须从`Vector`中删除，最简单的方法就是将\n`Vector`对象设置为`null`.\n\n`Java`和`C++`一个很大的区别就是`Java`有垃圾回收`GC(Garbage Collection)`自动管理内存的回收。但是我们在实际的项目中仍然会遇到内存泄露的问题。\n`Java`中对内存对象得访问是通过引用的方式，通过一个内存对象的引用变量来访问到对应的内存地址中的对象。\n`GC`会从代码栈的引用变量开始追踪，从而判断哪些内存是正在使用，如果无法跟踪到某一块堆内存，那么`GC`就认为这块内存不再使用了。\n\n`Android`手机给应用分配的内存通常是8兆左右，如果处理内存处理不当很容易造成`OutOfMemoryError` `OutOfMemoryError`主要由以下几种情况造成： \n\n1. 数据库`Cursor`没关。  \n    当我们操作完数据库后，一定要调用`close()`释放资源。 \n\n2. 构造`Adapter`没有使用缓存`ContentView`。    \n    ```java\n @Override    public View getView(int position, View convertView, ViewGroup parent) {  \n        ViewHolder vHolder = null;  \n        //如果convertView对象为空则创建新对象，不为空则复用  \n        if (convertView == null) {  \n            convertView = inflater.inflate(..., null);  \n            // 创建 ViewHodler 对象  \n            vHolder = new ViewHolder();  \n            vHolder.img= (ImageView) convertView.findViewById(...);  \n            vHolder.tv= (TextView) convertView  \n                    .findViewById(...);  \n            // 将ViewHodler保存到Tag中  \n            convertView.setTag(vHolder);  \n        } else {  \n            //当convertView不为空时，通过getTag()得到View  \n            vHolder = (ViewHolder) convertView.getTag();  \n        }  \n        // 给对象赋值，修改显示的值  \n        vHolder.img.setImageBitmap(...);  \n        vHolder.tv.setText(...);  \n        return convertView;  \n    }  \n\n    static class ViewHolder {  \n        TextView tv;  \n        ImageView img;  \n    }  \n```   3. 未取消注册广播接收者  \n    `registerReceiver()`和`unregisterReceiver()`要成对出现，通常需要在`Activity`的`onDestory()`方法去取消注册广播接收者。\n\n4. `IO`流未关闭\n    注意用完后及时关闭\n\n5. `Bitmap`使用后未调用`recycle()`。 \n\n6. `Context`泄漏\n    这是一个很隐晦的`OutOfMemoryError`的情况。先看一个Android官网提供的例子： \n\n    ```java\n private static Drawable sBackground;    @Override  \n    protected void onCreate(Bundle state) {  \n       super.onCreate(state);  \n       TextView label = new TextView(this);  \n       label.setText(\"Leaks are bad\");  \n       if (sBackground == null) {  \n          sBackground = getDrawable(R.drawable.large_bitmap);  \n       }  \n       label.setBackgroundDrawable(sBackground);  \n       setContentView(label);  \n    }  \n    ```\n  这段代码效率很快，但同时又是极其错误的：  \n   我们看一下`setBackgroundDrawable(Drawable background)`的源码：\n   ```java\n public void setBackgroundDrawable(Drawable background) { ... background.setCallback(this); } ```  有`background.setCallback(this);`方法，也就是说`Drawable`拥有`TextView`的引用，而`TextView`又拥有`Activity`*(Context类型)*的引用，\n   因为`sBackground`为`static`的，即使`Activity`被销毁，但是`sBackground`的生命周期还没走完，所以内存仍然不会被释放。这样就会有内存泄露了。\n   对，这样想是对的，但是我们看一下`setCallback`的源码：\n   ```java\n public final void setCallback(Callback cb) { mCallback = new WeakReference<Callback>(cb); } ```  我们会发现里面使用了`WeakReference`，所以不会存在内存泄露了，但是官网当时提供的例子明明说有泄露，这是因为在3.0之后，\n   修复了这个内存泄露的问题，在3.0之前`setCallback`，方法是没有使用`WeakReference`的，所以这种泄露的情况在3.0之前会发生，3.0之后已经被修复。\n\n7. 线程\n    线程也是造成内存泄露的一个重要的源头。线程产生内存泄露的主要原因在于线程生命周期的不可控。我们来考虑下面一段代码。\n    ```java\n   public class MyActivity extends Activity {     \n      @Override     \n      public void onCreate(Bundle savedInstanceState) {         \n         super.onCreate(savedInstanceState);         \n         setContentView(R.layout.main);         \n         new MyThread().start();     \n      }       \n      private class MyThread extends Thread{         \n      @Override         \n         public void run() {             \n         super.run();             \n         //耗时的操作       \n         }     \n      } \n   }  \n ```  假设`MyThread`的`run`函数是一个很费时的操作，当调用`finish`的时候`Activity`会销毁掉吗？  \n    事实上由于我们的线程是`Activity`的内部类，所以`MyThread`中保存了`Activity`的一个引用，当`MyThread`的`run`函数没有结束时，`MyThread`是不会被销毁的，\n   因此它所引用的`Activity`也不会被销毁，因此就出现了内存泄露的问题。\n\n11. 单例造成的内存泄漏  \n   由于单例的静态特性使得其生命周期跟应用的生命周期一样长，所以如果使用不恰当的话，很容易造成内存泄漏，比如:      \n   ```java\n public class AppManager { private static AppManager instance; private Context context; private AppManager(Context context) { this.context = context; } public static AppManager getInstance(Context context) { if (instance != null) { instance = new AppManager(context); } return instance; } } ```  这里如果传入的是`Activity`的`Context`，当该`Context`的`Activity`退出后，由于其被单例对象引用，所以会导致`Activity`无法被回收，就造成内存泄漏。\n\n8. 尽量使用`ApplicationContext`\n  **`Context`引用的生命周期超过它本身的生命周期，也会导致`Context`泄漏**。\n   所以如果打算保存一个长时间的对象时尽量使用`Application`这种`Context`类型。\n   例如: \n   ```java\n mStorageManager = (StorageManager) getSystemService(Context.STORAGE_SERVICE); 改成： mStorageManager = (StorageManager) getApplicationContext().getSystemService(Context.STORAGE_SERVICE); ```  按道理来说这种系统服务是不会有问题，但是有些厂商在修改的时候，可能会导致`Context`无法被及时释放。\n\n9. Handler的使用,在Activity退出的时候注意移除(尤其是循环的时候)\n    ```java\n   public class ThreadDemo extends Activity {  \n      private static final String TAG = \"ThreadDemo\";  \n      private int count = 0;  \n      private Handler mHandler =  new Handler();  \n\n      private Runnable mRunnable = new Runnable() {  \n\n         public void run() {  \n            //为了方便 查看，我们用Log打印出来   \n            Log.e(TAG, Thread.currentThread().getName() + \" \" +count);    \n            //每2秒执行一次   \n            mHandler.postDelayed(mRunnable, 2000);  \n         }   \n      };  \n      @Override  \n      public void onCreate(Bundle savedInstanceState) {  \n         super.onCreate(savedInstanceState);  \n         setContentView(R.layout.main);   \n         //通过Handler启动线程   \n         mHandler.post(mRunnable);  \n      } \n   } \n ```  这样在也会引发内存泄露。我们应该在`onDestory`方法中移除`Handler`,代码如下：\n   ```java\n @Override   protected void onDestroy() {  \n      super.onDestroy();  \n      mHandler.removeCallbacks(mRunnable);  \n   } \n``` 10. 由上面的`Handler`可以引伸出来的匿名内部类、非静态内部类和异步现成导致的内存泄漏。  \n    下面看一个非静态内部类创建静态实例导致的内存泄漏\n   ```java\n public class MainActivity extends AppCompatActivity { private static TestResource mResource = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if(mManager == null){ mManager = new TestResource(); } //... } class TestResource { //... } } ```  因为非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态实例，该实例的声明周期与应用的一样长，\n   这就导致了静态实例一直会持有`Activity`的引用而造成内存泄漏。  \n   下面再看一个匿名内部类和异步现成的现象:        \n   ```java\n public class MainActivity extends Activity { ... Runnable ref1 = new MyRunable(); Runnable ref2 = new Runnable() { @Override public void run() {   } }; ... } ```  上面的离职中`ref1`对象是没问题的，但是`ref2`这个匿名类的实现对象中有外部类的引用，如果此时线程的生命周期与`Activity`的不一致时就会造成了泄漏。\n\n10. 集合类泄漏  \n    集合类中如果只有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量(比如类中的静态属性)，那么没有\n   响应的删除机制，很可能导致集合所占用的内存只增不减。\n\n总结一下避免`Contex`t泄漏应该注意的问题：        \n\n- 使用`getApplicationContext()`类型。 \n- 注意对`Context`的引用不要超过它本身的生命周期。 \n- 慎重的使用`static`关键字。 \n- `Activity`里如果有线程或`Handler`时，一定要在`onDestroy()`里及时停掉。 \n\n## [什么情况导致oom-乐视-美团](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0920/3478.html)\n\n1）使用更加轻量的数据结构\n2）Android里面使用Enum\n3）Bitmap对象的内存占用\n4）更大的图片\n5）onDraw方法里面执行对象的创建\n6）StringBuilder\n\n## Handler导致内存泄露分析   有关内存泄露请猛戳[内存泄露](https://github.com/CharonChui/AndroidNote/blob/master/Android%E5%9F%BA%E7%A1%80/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F.md)\n\n```java Handler mHandler = new Handler() {\n @Override public void handleMessage(Message msg) { // do something. } } ``` 当我们这样创建`Handler`的时候`Android Lint`会提示我们这样一个`warning： In Android, Handler classes should be static or leaks might occur.`。       \n\n一直以来没有仔细的去分析泄露的原因，先把主要原因列一下：    \n- `Android`程序第一次创建的时候，默认会创建一个`Looper`对象，`Looper`去处理`Message Queue`中的每个`Message`,主线程的`Looper`存在整个应用程序的生命周期.\n- `Hanlder`在主线程创建时会关联到`Looper`的`Message Queue`,`Message`添加到消息队列中的时候`Message(排队的Message)`会持有当前`Handler`引用，\n当`Looper`处理到当前消息的时候，会调用`Handler#handleMessage(Message)`.就是说在`Looper`处理这个`Message`之前，\n会有一条链`MessageQueue -> Message -> Handler -> Activity`，由于它的引用导致你的`Activity`被持有引用而无法被回收` - **在java中，no-static的内部类会隐式的持有当前类的一个引用。static的内部类则没有。**   ### 具体分析 ```java public class SampleActivity extends Activity {   private final Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { // do something } }   @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 发送一个10分钟后执行的一个消息 mHandler.postDelayed(new Runnable() { @Override public void run() { } }, 600000);   // 结束当前的Activity finish(); } ``` 在`finish()`的时候，该`Message`还没有被处理，`Message`持有`Handler`,`Handler`持有`Activity`,这样会导致该`Activity`不会被回收，就发生了内存泄露.\n\n### 解决方法 - 通过程序逻辑来进行保护。\n  - 如果`Handler`中执行的是耗时的操作，在关闭`Activity`的时候停掉你的后台线程。线程停掉了，就相当于切断了`Handler`和外部连接的线，\n   `Activity`自然会在合适的时候被回收。 \n  - 如果`Handler`是被`delay`的`Message`持有了引用，那么在`Activity`的`onDestroy()`方法要调用`Handler`的`remove*`方法，把消息对象从消息队列移除就行了。 \n     - 关于`Handler.remove*`方法\n         - `removeCallbacks(Runnable r)` ——清除r匹配上的Message。    \n         - `removeC4allbacks(Runnable r, Object token)` ——清除r匹配且匹配token（Message.obj）的Message，token为空时，只匹配r。\n         - `removeCallbacksAndMessages(Object token)` ——清除token匹配上的Message。\n         - `removeMessages(int what)` ——按what来匹配     \n         - `removeMessages(int what, Object object)` ——按what来匹配  \n         我们更多需要的是清除以该`Handler`为`target`的所有`Message(Callback)`就调用如下方法即可`handler.removeCallbacksAndMessages(null)`;\n- 将`Handler`声明为静态类。\n    静态类不持有外部类的对象，所以你的`Activity`可以随意被回收。但是不持有`Activity`的引用，如何去操作`Activity`中的一些对象？ 这里要用到弱引用\n\n```java public class MyActivity extends Activity {\n private MyHandler mHandler;   @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mHandler = new MyHandler(this); }   @Override protected void onDestroy() { // Remove all Runnable and Message. mHandler.removeCallbacksAndMessages(null); super.onDestroy(); }   static class MyHandler extends Handler { // WeakReference to the outer class's instance. private WeakReference<MyActivity> mOuter;   public MyHandler(MyActivity activity) { mOuter = new WeakReference<MyActivity>(activity); }   @Override public void handleMessage(Message msg) { MyActivity outer = mOuter.get(); if (outer != null) { // Do something with outer as your wish. } } } } ``` ## 什么情况导致内存泄漏-美团   1.资源对象没关闭造成的内存泄漏\n\n描述：\n资源性对象比如(Cursor，File文件等)往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于 java虚拟机内，还存在于java虚拟机外。如果我们仅仅是把它的引用设置为null,而不关闭它们，往往会造成内存泄漏。因为有些资源性对象，比如 SQLiteCursor(在析构函数finalize(),如果我们没有关闭它，它自己会调close()关闭)，如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。因此对于资源性对象在不使用的时候，应该调用它的close()函数，将其关闭掉，然后才置为null.在我们的程序退出时一定要确保我们的资源性对象已经关闭。\n程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。\n\n2.构造Adapter时，没有使用缓存的convertView\n\n描述：\n以构造ListView的BaseAdapter为例，在BaseAdapter中提供了方法：\npublic View getView(int position, ViewconvertView, ViewGroup parent)\n来向ListView提供每一个item所需要的view对象。初始时ListView会从BaseAdapter中根据当前的屏幕布局实例化一定数量的 view对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的list item的view对象会被回收，然后被用来构造新出现的最下面的list item。这个构造过程就是由getView()方法完成的，getView()的第二个形参View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是null)。由此可以看出，如果我们不去使用 convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费资源也浪费时间，也会使得内存占用越来越大。 ListView回收list item的view对象的过程可以查看:\nandroid.widget.AbsListView.java --> voidaddScrapView(View scrap) 方法。\n示例代码：\n\n``` public View getView(int position, ViewconvertView, ViewGroup parent) { View view = new Xxx(...); ... ... return view; } ```   修正示例代码：\n\n``` public View getView(int position, ViewconvertView, ViewGroup parent) { View view = null; if (convertView != null) { view = convertView; populate(view, getItem(position)); ... } else { view = new Xxx(...); ... } return view; } ```   3.Bitmap对象不在使用时调用recycle()释放内存\n\n描述：\n有时我们会手工的操作Bitmap对象，如果一个Bitmap对象比较占内存，当它不在被使用的时候，可以调用Bitmap.recycle()方法回收此对象的像素所占用的内存，但这不是必须的，视情况而定。可以看一下代码中的注释：\n\n/** \n•Free up the memory associated with thisbitmap's pixels, and mark the \n•bitmap as \"dead\", meaning itwill throw an exception if getPixels() or \n•setPixels() is called, and will drawnothing. This operation cannot be \n•reversed, so it should only be called ifyou are sure there are no \n•further uses for the bitmap. This is anadvanced call, and normally need \n•not be called, since the normal GCprocess will free up this memory when \n•there are no more references to thisbitmap. \n*/ \n\n4.试着使用关于application的context来替代和activity相关的context\n\n这是一个很隐晦的内存泄漏的情况。有一种简单的方法来避免context相关的内存泄漏。最显著地一个是避免context逃出他自己的范围之外。使用Application context。这个context的生存周期和你的应用的生存周期一样长，而不是取决于activity的生存周期。如果你想保持一个长期生存的对象，并且这个对象需要一个context,记得使用application对象。你可以通过调用 Context.getApplicationContext() or Activity.getApplication()来获得。更多的请看这篇文章如何避免\nAndroid内存泄漏。\n\n5.注册没取消造成的内存泄漏\n\n一些Android程序可能引用我们的Anroid程序的对象(比如注册机制)。即使我们的Android程序已经结束了，但是别的引用程序仍然还有对我们的Android程序的某个对象的引用，泄漏的内存依然不能被垃圾回收。调用registerReceiver后未调用unregisterReceiver。\n比如:假设我们希望在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen中定义一个 PhoneStateListener的对象，同时将它注册到TelephonyManager服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。\n但是如果在释放 LockScreen对象的时候忘记取消我们之前注册的PhoneStateListener对象，则会导致LockScreen无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的LockScreen对象没有办法被回收而引起OutOfMemory,使得system_process 进程挂掉。\n虽然有些系统程序，它本身好像是可以自动取消注册的(当然不及时)，但是我们还是应该在我们的程序中明确的取消注册，程序结束时应该把所有的注册都取消掉。\n\n6.集合中对象没清理造成的内存泄漏\n\n我们通常把一些对象的引用加入到了集合中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。"]],[0,0],[15324,15324]]],[1518596242008,["gengmei_pxf@gengmei123.local",[[1,412,"\n"]],[412,412],[413,413]]],[1518596249269,["gengmei_pxf@gengmei123.local",[[1,702,"\n"]],[702,702],[703,703]]],[1518596252781,["gengmei_pxf@gengmei123.local",[[1,782,"\n"]],[782,782],[783,783]]],[1518596256548,["gengmei_pxf@gengmei123.local",[[1,1099,"\n"]],[1099,1099],[1100,1100]]],[1518596259181,["gengmei_pxf@gengmei123.local",[[1,1179,"\n"]],[1179,1179],[1180,1180]]],[1518596278924,["gengmei_pxf@gengmei123.local",[[1,1601,"\n"]],[1601,1601],[1602,1602]]],[1518596281172,["gengmei_pxf@gengmei123.local",[[1,1610,"\n"]],[1610,1610],[1611,1611]]],[1518596285854,["gengmei_pxf@gengmei123.local",[[1,1616,"\n"]],[1616,1616],[1617,1617]]],[1518596288252,["gengmei_pxf@gengmei123.local",[[1,1685,"\n"]],[1685,1685],[1686,1686]]],[1518596290524,["gengmei_pxf@gengmei123.local",[[1,1788,"\n"]],[1788,1788],[1789,1789]]],[1518596304092,["gengmei_pxf@gengmei123.local",[[-1,0,"Android内存泄漏 === 传统的内存泄漏是由忘记释放分配的内存导致的，而逻辑上的内存泄漏则是由于忘记在对象不再被使用的时候释放对其的引用导致的。\n\n## 静态的Activity\n  activity 类中定义一个 static 变量，并且将其指向一个[运行中的 activity 实例](https://github.com/NimbleDroid/Memory-Leaks/blob/master/app/src/main/java/com/nimbledroid/memoryleaks/MainActivity.java#L110)。如果在 activity 的生命周期结束之前，没有清除这个引用，那它就会泄漏了。这是因为 activity（例如 MainActivity） 的类对象是静态的，一旦加载，就会在 APP 运行时一直常驻内存，因此如果类对象不卸载，其静态成员就不会被垃圾回收。\n\n## 静态View\n 一旦 view 被加入到界面中，它就会持有 context 的强引用，也就是我们的 activity。由于我们通过一个静态成员引用了这个 view，所以我们也就引用了 activity，因此 activity 就发生了泄漏。所以一定不要把加载的 view 赋值给静态变量，如果你真的需要，那一定要确保在 activity 销毁之前[将其从 view 层级中移除](http://developer.android.com/reference/android/view/ViewGroup.html#removeView(android.view.View))。\n\n## 内部类\n 非静态内部类（包括匿名内部类）默认就会持有外部类的引用，当非静态内部类对象的生命周期比外部类对象的生命周期长时，就会导致内存泄露。\n\n## Handlers\n [定义一个匿名的 Runnable 对象并将其提交到 Handler 上](https://github.com/NimbleDroid/Memory-Leaks/blob/master/app/src/main/java/com/nimbledroid/memoryleaks/MainActivity.java#L114)也可能导致 activity 泄漏。Runnable 对象间接地引用了定义它的 activity 对象，而它会被提交到 Handler 的 MessageQueue 中，如果它在 activity 销毁时还没有被处理，那就会导致 activity 泄漏了。\n\n## Threads和Timer Tasks\n 只要它们是通过匿名类创建的，尽管它们在单独的线程被执行，它们也会持有对 activity 的强引用，进而导致内存泄漏。\n\n## Sensor Manager\n 系统服务可以通过 [context.getSystemService](http://developer.android.com/reference/android/content/Context.html#getSystemService(java.lang.String)) 获取，它们负责执行某些后台任务，或者为硬件访问提供接口。如果 context 对象想要在服务内部的事件发生时被通知，那就需要把自己注册到服务的[监听器](https://github.com/NimbleDroid/Memory-Leaks/blob/master/app/src/main/java/com/nimbledroid/memoryleaks/MainActivity.java#L136)中。然而，这会让服务持有 activity 的引用，如果程序员忘记在 activity 销毁时取消注册，那就会导致 activity 泄漏了。\n\n内存泄露 \n===     \n## 定义\n 内存泄露是指无用对象(不再使用的对象)持续占有内存或无用对象的内存得不到及时释放，从而造成的内存空间的浪费称为内存泄露。\n\n## 原因\n 长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，\n这就是`java`中内存泄露的发生场景。\n\n## 危害\n 只有一个，那就是虚拟机占用内存过高，导致`OOM`(内存溢出)。\n对于`Android`应用来说，就是你的用户打开一个`Activity`，使用完之后关闭它，内存泄露；又打开，又关闭，又泄露；几次之后，程序占用内存超过系统限制就会出现`FC`。             \n\n先来说一下`Java`程序运行时的内存分配策略:        \n\n- 静态内存:存放静态数据，这块内存是在编译时就已经分配好的，在程序整个运行期间都存在。\n- 栈内存:程序执行时，局部变量的创建存储区，执行结束后将自动释放。(当时学习java时花的内存分配图，现在都生疏了- -!)\n- 堆内存:存储一些new出来的内存，也叫动态内存分配，这部分内存在不使用时将会有`Java`垃圾回收器来负责回收。    \n\n举一个典型的内存泄漏的例子:     \n``` Vector v = new Vector(100); for (int i = 1; i < 100,; i++) {\n Object o = new Object(); v.add(o); o = null; } ``` 在这个例子中，我们循环申请了`Object`对象，并将所申请的对象放入一个集合中，如果我们仅仅释放引用本身，那么`Vector`仍然引用\n该对象，所以这个对象对`GC`来说是不可回收的。因此，如果对象假如`Vector`后，还必须从`Vector`中删除，最简单的方法就是将\n`Vector`对象设置为`null`.\n\n`Java`和`C++`一个很大的区别就是`Java`有垃圾回收`GC(Garbage Collection)`自动管理内存的回收。但是我们在实际的项目中仍然会遇到内存泄露的问题。\n`Java`中对内存对象得访问是通过引用的方式，通过一个内存对象的引用变量来访问到对应的内存地址中的对象。\n`GC`会从代码栈的引用变量开始追踪，从而判断哪些内存是正在使用，如果无法跟踪到某一块堆内存，那么`GC`就认为这块内存不再使用了。\n\n`Android`手机给应用分配的内存通常是8兆左右，如果处理内存处理不当很容易造成`OutOfMemoryError` `OutOfMemoryError`主要由以下几种情况造成： \n\n1. 数据库`Cursor`没关。  \n    当我们操作完数据库后，一定要调用`close()`释放资源。 \n\n2. 构造`Adapter`没有使用缓存`ContentView`。    \n    ```java\n @Override    public View getView(int position, View convertView, ViewGroup parent) {  \n        ViewHolder vHolder = null;  \n        //如果convertView对象为空则创建新对象，不为空则复用  \n        if (convertView == null) {  \n            convertView = inflater.inflate(..., null);  \n            // 创建 ViewHodler 对象  \n            vHolder = new ViewHolder();  \n            vHolder.img= (ImageView) convertView.findViewById(...);  \n            vHolder.tv= (TextView) convertView  \n                    .findViewById(...);  \n            // 将ViewHodler保存到Tag中  \n            convertView.setTag(vHolder);  \n        } else {  \n            //当convertView不为空时，通过getTag()得到View  \n            vHolder = (ViewHolder) convertView.getTag();  \n        }  \n        // 给对象赋值，修改显示的值  \n        vHolder.img.setImageBitmap(...);  \n        vHolder.tv.setText(...);  \n        return convertView;  \n    }  \n\n    static class ViewHolder {  \n        TextView tv;  \n        ImageView img;  \n    }  \n```   3. 未取消注册广播接收者  \n    `registerReceiver()`和`unregisterReceiver()`要成对出现，通常需要在`Activity`的`onDestory()`方法去取消注册广播接收者。\n\n4. `IO`流未关闭\n    注意用完后及时关闭\n\n5. `Bitmap`使用后未调用`recycle()`。 \n\n6. `Context`泄漏\n    这是一个很隐晦的`OutOfMemoryError`的情况。先看一个Android官网提供的例子： \n\n    ```java\n private static Drawable sBackground;    @Override  \n    protected void onCreate(Bundle state) {  \n       super.onCreate(state);  \n       TextView label = new TextView(this);  \n       label.setText(\"Leaks are bad\");  \n       if (sBackground == null) {  \n          sBackground = getDrawable(R.drawable.large_bitmap);  \n       }  \n       label.setBackgroundDrawable(sBackground);  \n       setContentView(label);  \n    }  \n    ```\n  这段代码效率很快，但同时又是极其错误的：  \n   我们看一下`setBackgroundDrawable(Drawable background)`的源码：\n   ```java\n public void setBackgroundDrawable(Drawable background) { ... background.setCallback(this); } ```  有`background.setCallback(this);`方法，也就是说`Drawable`拥有`TextView`的引用，而`TextView`又拥有`Activity`*(Context类型)*的引用，\n   因为`sBackground`为`static`的，即使`Activity`被销毁，但是`sBackground`的生命周期还没走完，所以内存仍然不会被释放。这样就会有内存泄露了。\n   对，这样想是对的，但是我们看一下`setCallback`的源码：\n   ```java\n public final void setCallback(Callback cb) { mCallback = new WeakReference<Callback>(cb); } ```  我们会发现里面使用了`WeakReference`，所以不会存在内存泄露了，但是官网当时提供的例子明明说有泄露，这是因为在3.0之后，\n   修复了这个内存泄露的问题，在3.0之前`setCallback`，方法是没有使用`WeakReference`的，所以这种泄露的情况在3.0之前会发生，3.0之后已经被修复。\n\n7. 线程\n    线程也是造成内存泄露的一个重要的源头。线程产生内存泄露的主要原因在于线程生命周期的不可控。我们来考虑下面一段代码。\n    ```java\n   public class MyActivity extends Activity {     \n      @Override     \n      public void onCreate(Bundle savedInstanceState) {         \n         super.onCreate(savedInstanceState);         \n         setContentView(R.layout.main);         \n         new MyThread().start();     \n      }       \n      private class MyThread extends Thread{         \n      @Override         \n         public void run() {             \n         super.run();             \n         //耗时的操作       \n         }     \n      } \n   }  \n ```  假设`MyThread`的`run`函数是一个很费时的操作，当调用`finish`的时候`Activity`会销毁掉吗？  \n    事实上由于我们的线程是`Activity`的内部类，所以`MyThread`中保存了`Activity`的一个引用，当`MyThread`的`run`函数没有结束时，`MyThread`是不会被销毁的，\n   因此它所引用的`Activity`也不会被销毁，因此就出现了内存泄露的问题。\n\n11. 单例造成的内存泄漏  \n   由于单例的静态特性使得其生命周期跟应用的生命周期一样长，所以如果使用不恰当的话，很容易造成内存泄漏，比如:      \n   ```java\n public class AppManager { private static AppManager instance; private Context context; private AppManager(Context context) { this.context = context; } public static AppManager getInstance(Context context) { if (instance != null) { instance = new AppManager(context); } return instance; } } ```  这里如果传入的是`Activity`的`Context`，当该`Context`的`Activity`退出后，由于其被单例对象引用，所以会导致`Activity`无法被回收，就造成内存泄漏。\n\n8. 尽量使用`ApplicationContext`\n  **`Context`引用的生命周期超过它本身的生命周期，也会导致`Context`泄漏**。\n   所以如果打算保存一个长时间的对象时尽量使用`Application`这种`Context`类型。\n   例如: \n   ```java\n mStorageManager = (StorageManager) getSystemService(Context.STORAGE_SERVICE); 改成： mStorageManager = (StorageManager) getApplicationContext().getSystemService(Context.STORAGE_SERVICE); ```  按道理来说这种系统服务是不会有问题，但是有些厂商在修改的时候，可能会导致`Context`无法被及时释放。\n\n9. Handler的使用,在Activity退出的时候注意移除(尤其是循环的时候)\n    ```java\n   public class ThreadDemo extends Activity {  \n      private static final String TAG = \"ThreadDemo\";  \n      private int count = 0;  \n      private Handler mHandler =  new Handler();  \n\n      private Runnable mRunnable = new Runnable() {  \n\n         public void run() {  \n            //为了方便 查看，我们用Log打印出来   \n            Log.e(TAG, Thread.currentThread().getName() + \" \" +count);    \n            //每2秒执行一次   \n            mHandler.postDelayed(mRunnable, 2000);  \n         }   \n      };  \n      @Override  \n      public void onCreate(Bundle savedInstanceState) {  \n         super.onCreate(savedInstanceState);  \n         setContentView(R.layout.main);   \n         //通过Handler启动线程   \n         mHandler.post(mRunnable);  \n      } \n   } \n ```  这样在也会引发内存泄露。我们应该在`onDestory`方法中移除`Handler`,代码如下：\n   ```java\n @Override   protected void onDestroy() {  \n      super.onDestroy();  \n      mHandler.removeCallbacks(mRunnable);  \n   } \n``` 10. 由上面的`Handler`可以引伸出来的匿名内部类、非静态内部类和异步现成导致的内存泄漏。  \n    下面看一个非静态内部类创建静态实例导致的内存泄漏\n   ```java\n public class MainActivity extends AppCompatActivity { private static TestResource mResource = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if(mManager == null){ mManager = new TestResource(); } //... } class TestResource { //... } } ```  因为非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态实例，该实例的声明周期与应用的一样长，\n   这就导致了静态实例一直会持有`Activity`的引用而造成内存泄漏。  \n   下面再看一个匿名内部类和异步现成的现象:        \n   ```java\n public class MainActivity extends Activity { ... Runnable ref1 = new MyRunable(); Runnable ref2 = new Runnable() { @Override public void run() {   } }; ... } ```  上面的离职中`ref1`对象是没问题的，但是`ref2`这个匿名类的实现对象中有外部类的引用，如果此时线程的生命周期与`Activity`的不一致时就会造成了泄漏。\n\n10. 集合类泄漏  \n    集合类中如果只有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量(比如类中的静态属性)，那么没有\n   响应的删除机制，很可能导致集合所占用的内存只增不减。\n\n总结一下避免`Contex`t泄漏应该注意的问题：        \n\n- 使用`getApplicationContext()`类型。 \n- 注意对`Context`的引用不要超过它本身的生命周期。 \n- 慎重的使用`static`关键字。 \n- `Activity`里如果有线程或`Handler`时，一定要在`onDestroy()`里及时停掉。 \n\n## [什么情况导致oom-乐视-美团](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0920/3478.html)\n\n1）使用更加轻量的数据结构\n2）Android里面使用Enum\n3）Bitmap对象的内存占用\n4）更大的图片\n5）onDraw方法里面执行对象的创建\n6）StringBuilder\n\n## Handler导致内存泄露分析   有关内存泄露请猛戳[内存泄露](https://github.com/CharonChui/AndroidNote/blob/master/Android%E5%9F%BA%E7%A1%80/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F.md)\n\n```java Handler mHandler = new Handler() {\n @Override public void handleMessage(Message msg) { // do something. } } ``` 当我们这样创建`Handler`的时候`Android Lint`会提示我们这样一个`warning： In Android, Handler classes should be static or leaks might occur.`。       \n\n一直以来没有仔细的去分析泄露的原因，先把主要原因列一下：    \n- `Android`程序第一次创建的时候，默认会创建一个`Looper`对象，`Looper`去处理`Message Queue`中的每个`Message`,主线程的`Looper`存在整个应用程序的生命周期.\n- `Hanlder`在主线程创建时会关联到`Looper`的`Message Queue`,`Message`添加到消息队列中的时候`Message(排队的Message)`会持有当前`Handler`引用，\n当`Looper`处理到当前消息的时候，会调用`Handler#handleMessage(Message)`.就是说在`Looper`处理这个`Message`之前，\n会有一条链`MessageQueue -> Message -> Handler -> Activity`，由于它的引用导致你的`Activity`被持有引用而无法被回收` - **在java中，no-static的内部类会隐式的持有当前类的一个引用。static的内部类则没有。**   ### 具体分析 ```java public class SampleActivity extends Activity {   private final Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { // do something } }   @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 发送一个10分钟后执行的一个消息 mHandler.postDelayed(new Runnable() { @Override public void run() { } }, 600000);   // 结束当前的Activity finish(); } ``` 在`finish()`的时候，该`Message`还没有被处理，`Message`持有`Handler`,`Handler`持有`Activity`,这样会导致该`Activity`不会被回收，就发生了内存泄露.\n\n### 解决方法 - 通过程序逻辑来进行保护。\n  - 如果`Handler`中执行的是耗时的操作，在关闭`Activity`的时候停掉你的后台线程。线程停掉了，就相当于切断了`Handler`和外部连接的线，\n   `Activity`自然会在合适的时候被回收。 \n  - 如果`Handler`是被`delay`的`Message`持有了引用，那么在`Activity`的`onDestroy()`方法要调用`Handler`的`remove*`方法，把消息对象从消息队列移除就行了。 \n     - 关于`Handler.remove*`方法\n         - `removeCallbacks(Runnable r)` ——清除r匹配上的Message。    \n         - `removeC4allbacks(Runnable r, Object token)` ——清除r匹配且匹配token（Message.obj）的Message，token为空时，只匹配r。\n         - `removeCallbacksAndMessages(Object token)` ——清除token匹配上的Message。\n         - `removeMessages(int what)` ——按what来匹配     \n         - `removeMessages(int what, Object object)` ——按what来匹配  \n         我们更多需要的是清除以该`Handler`为`target`的所有`Message(Callback)`就调用如下方法即可`handler.removeCallbacksAndMessages(null)`;\n- 将`Handler`声明为静态类。\n    静态类不持有外部类的对象，所以你的`Activity`可以随意被回收。但是不持有`Activity`的引用，如何去操作`Activity`中的一些对象？ 这里要用到弱引用\n\n```java public class MyActivity extends Activity {\n private MyHandler mHandler;   @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mHandler = new MyHandler(this); }   @Override protected void onDestroy() { // Remove all Runnable and Message. mHandler.removeCallbacksAndMessages(null); super.onDestroy(); }   static class MyHandler extends Handler { // WeakReference to the outer class's instance. private WeakReference<MyActivity> mOuter;   public MyHandler(MyActivity activity) { mOuter = new WeakReference<MyActivity>(activity); }   @Override public void handleMessage(Message msg) { MyActivity outer = mOuter.get(); if (outer != null) { // Do something with outer as your wish. } } } } ``` ## 什么情况导致内存泄漏-美团   1.资源对象没关闭造成的内存泄漏\n\n描述：\n资源性对象比如(Cursor，File文件等)往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于 java虚拟机内，还存在于java虚拟机外。如果我们仅仅是把它的引用设置为null,而不关闭它们，往往会造成内存泄漏。因为有些资源性对象，比如 SQLiteCursor(在析构函数finalize(),如果我们没有关闭它，它自己会调close()关闭)，如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。因此对于资源性对象在不使用的时候，应该调用它的close()函数，将其关闭掉，然后才置为null.在我们的程序退出时一定要确保我们的资源性对象已经关闭。\n程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。\n\n2.构造Adapter时，没有使用缓存的convertView\n\n描述：\n以构造ListView的BaseAdapter为例，在BaseAdapter中提供了方法：\npublic View getView(int position, ViewconvertView, ViewGroup parent)\n来向ListView提供每一个item所需要的view对象。初始时ListView会从BaseAdapter中根据当前的屏幕布局实例化一定数量的 view对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的list item的view对象会被回收，然后被用来构造新出现的最下面的list item。这个构造过程就是由getView()方法完成的，getView()的第二个形参View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是null)。由此可以看出，如果我们不去使用 convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费资源也浪费时间，也会使得内存占用越来越大。 ListView回收list item的view对象的过程可以查看:\nandroid.widget.AbsListView.java --> voidaddScrapView(View scrap) 方法。\n示例代码：\n\n``` public View getView(int position, ViewconvertView, ViewGroup parent) { View view = new Xxx(...); ... ... return view; } ```   修正示例代码：\n\n``` public View getView(int position, ViewconvertView, ViewGroup parent) { View view = null; if (convertView != null) { view = convertView; populate(view, getItem(position)); ... } else { view = new Xxx(...); ... } return view; } ```   3.Bitmap对象不在使用时调用recycle()释放内存\n\n描述：\n有时我们会手工的操作Bitmap对象，如果一个Bitmap对象比较占内存，当它不在被使用的时候，可以调用Bitmap.recycle()方法回收此对象的像素所占用的内存，但这不是必须的，视情况而定。可以看一下代码中的注释：\n\n/** \n•Free up the memory associated with thisbitmap's pixels, and mark the \n•bitmap as \"dead\", meaning itwill throw an exception if getPixels() or \n•setPixels() is called, and will drawnothing. This operation cannot be \n•reversed, so it should only be called ifyou are sure there are no \n•further uses for the bitmap. This is anadvanced call, and normally need \n•not be called, since the normal GCprocess will free up this memory when \n•there are no more references to thisbitmap. \n*/ \n\n4.试着使用关于application的context来替代和activity相关的context\n\n这是一个很隐晦的内存泄漏的情况。有一种简单的方法来避免context相关的内存泄漏。最显著地一个是避免context逃出他自己的范围之外。使用Application context。这个context的生存周期和你的应用的生存周期一样长，而不是取决于activity的生存周期。如果你想保持一个长期生存的对象，并且这个对象需要一个context,记得使用application对象。你可以通过调用 Context.getApplicationContext() or Activity.getApplication()来获得。更多的请看这篇文章如何避免\nAndroid内存泄漏。\n\n5.注册没取消造成的内存泄漏\n\n一些Android程序可能引用我们的Anroid程序的对象(比如注册机制)。即使我们的Android程序已经结束了，但是别的引用程序仍然还有对我们的Android程序的某个对象的引用，泄漏的内存依然不能被垃圾回收。调用registerReceiver后未调用unregisterReceiver。\n比如:假设我们希望在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen中定义一个 PhoneStateListener的对象，同时将它注册到TelephonyManager服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。\n但是如果在释放 LockScreen对象的时候忘记取消我们之前注册的PhoneStateListener对象，则会导致LockScreen无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的LockScreen对象没有办法被回收而引起OutOfMemory,使得system_process 进程挂掉。\n虽然有些系统程序，它本身好像是可以自动取消注册的(当然不及时)，但是我们还是应该在我们的程序中明确的取消注册，程序结束时应该把所有的注册都取消掉。\n\n6.集合中对象没清理造成的内存泄漏\n\n我们通常把一些对象的引用加入到了集合中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。"]],[0,15334],[0,0]]],[1518596325269,["gengmei_pxf@gengmei123.local",[[1,0,"内存泄露\n===\n\n\n## 定义     \n内存泄露是指无用对象(不再使用的对象)持续占有内存或无用对象的内存得不到及时释放，从而造成的内存空间的浪费称为内存泄露。\n\n## 原因      \n长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，\n这就是`java`中内存泄露的发生场景。\n\n## 危害     \n只有一个，那就是虚拟机占用内存过高，导致`OOM`(内存溢出)。\n对于`Android`应用来说，就是你的用户打开一个`Activity`，使用完之后关闭它，内存泄露；又打开，又关闭，又泄露；几次之后，程序占用内存超过系统限制就会出现`FC`。             \n\n\n先来说一下`Java`程序运行时的内存分配策略:        \n\n- 静态内存:存放静态数据，这块内存是在编译时就已经分配好的，在程序整个运行期间都存在。\n- 栈内存:程序执行时，局部变量的创建存储区，执行结束后将自动释放。(当时学习java时花的内存分配图，现在都生疏了- -!)\n- 堆内存:存储一些new出来的内存，也叫动态内存分配，这部分内存在不使用时将会有`Java`垃圾回收器来负责回收。    \n\n举一个典型的内存泄漏的例子:     \n```java\nVector v = new Vector(100);\nfor (int i = 1; i < 100,; i++) {\n\tObject o = new Object();\n\tv.add(o);\n\to = null;\n}\n```\t\n在这个例子中，我们循环申请了`Object`对象，并将所申请的对象放入一个集合中，如果我们仅仅释放引用本身，那么`Vector`仍然引用\n该对象，所以这个对象对`GC`来说是不可回收的。因此，如果对象假如`Vector`后，还必须从`Vector`中删除，最简单的方法就是将\n`Vector`对象设置为`null`.\n\t\t\t\n`Java`和`C++`一个很大的区别就是`Java`有垃圾回收`GC(Garbage Collection)`自动管理内存的回收。但是我们在实际的项目中仍然会遇到内存泄露的问题。\n`Java`中对内存对象得访问是通过引用的方式，通过一个内存对象的引用变量来访问到对应的内存地址中的对象。\n`GC`会从代码栈的引用变量开始追踪，从而判断哪些内存是正在使用，如果无法跟踪到某一块堆内存，那么`GC`就认为这块内存不再使用了。\n\n`Android`手机给应用分配的内存通常是8兆左右，如果处理内存处理不当很容易造成`OutOfMemoryError`\n`OutOfMemoryError`主要由以下几种情况造成： \n\n1. 数据库`Cursor`没关。  \n    当我们操作完数据库后，一定要调用`close()`释放资源。 \n\n2. 构造`Adapter`没有使用缓存`ContentView`。    \n    ```java\n    @Override  \n    public View getView(int position, View convertView, ViewGroup parent) {  \n        ViewHolder vHolder = null;  \n        //如果convertView对象为空则创建新对象，不为空则复用  \n        if (convertView == null) {  \n            convertView = inflater.inflate(..., null);  \n            // 创建 ViewHodler 对象  \n            vHolder = new ViewHolder();  \n            vHolder.img= (ImageView) convertView.findViewById(...);  \n            vHolder.tv= (TextView) convertView  \n                    .findViewById(...);  \n            // 将ViewHodler保存到Tag中  \n            convertView.setTag(vHolder);  \n        } else {  \n            //当convertView不为空时，通过getTag()得到View  \n            vHolder = (ViewHolder) convertView.getTag();  \n        }  \n        // 给对象赋值，修改显示的值  \n        vHolder.img.setImageBitmap(...);  \n        vHolder.tv.setText(...);  \n        return convertView;  \n    }  \n    \n    static class ViewHolder {  \n        TextView tv;  \n        ImageView img;  \n    }  \n    ```\n\n3. 未取消注册广播接收者     \n    `registerReceiver()`和`unregisterReceiver()`要成对出现，通常需要在`Activity`的`onDestory()`方法去取消注册广播接收者。\n\t\n4. `IO`流未关闭\n    注意用完后及时关闭\n\n5. `Bitmap`使用后未调用`recycle()`。 \n\n6. `Context`泄漏\n    这是一个很隐晦的`OutOfMemoryError`的情况。先看一个Android官网提供的例子： \n\n    ```java\n    private static Drawable sBackground;  \n    @Override  \n    protected void onCreate(Bundle state) {  \n    \tsuper.onCreate(state);  \n    \tTextView label = new TextView(this);  \n    \tlabel.setText(\"Leaks are bad\");  \n    \tif (sBackground == null) {  \n    \t\tsBackground = getDrawable(R.drawable.large_bitmap);  \n    \t}  \n    \tlabel.setBackgroundDrawable(sBackground);  \n    \tsetContentView(label);  \n    }  \n    ```\n    这段代码效率很快，但同时又是极其错误的：    \n\t我们看一下`setBackgroundDrawable(Drawable background)`的源码：\n\t```java\n\t public void setBackgroundDrawable(Drawable background) {\n\t\t...\n\t\tbackground.setCallback(this);\n\t }\n\t```\n\t有`background.setCallback(this);`方法，也就是说`Drawable`拥有`TextView`的引用，而`TextView`又拥有`Activity`*(Context类型)*的引用，\n\t因为`sBackground`为`static`的，即使`Activity`被销毁，但是`sBackground`的生命周期还没走完，所以内存仍然不会被释放。这样就会有内存泄露了。\n\t对，这样想是对的，但是我们看一下`setCallback`的源码：\n\t```java\n\t  public final void setCallback(Callback cb) {\n        mCallback = new WeakReference<Callback>(cb);\n    }\n\t```\n\t我们会发现里面使用了`WeakReference`，所以不会存在内存泄露了，但是官网当时提供的例子明明说有泄露，这是因为在3.0之后，\n\t修复了这个内存泄露的问题，在3.0之前`setCallback`，方法是没有使用`WeakReference`的，所以这种泄露的情况在3.0之前会发生，3.0之后已经被修复。\n\t\n7. 线程\n    线程也是造成内存泄露的一个重要的源头。线程产生内存泄露的主要原因在于线程生命周期的不可控。我们来考虑下面一段代码。\n    ```java\n\tpublic class MyActivity extends Activity {     \n\t\t@Override     \n\t\tpublic void onCreate(Bundle savedInstanceState) {         \n\t\t\tsuper.onCreate(savedInstanceState);         \n\t\t\tsetContentView(R.layout.main);         \n\t\t\tnew MyThread().start();     \n\t\t}       \n\t\tprivate class MyThread extends Thread{         \n\t\t@Override         \n\t\t\tpublic void run() {             \n\t\t\tsuper.run();             \n\t\t\t//耗时的操作       \n\t\t\t}     \n\t\t} \n\t}  \n\t```\n    假设`MyThread`的`run`函数是一个很费时的操作，当调用`finish`的时候`Activity`会销毁掉吗？    \n    事实上由于我们的线程是`Activity`的内部类，所以`MyThread`中保存了`Activity`的一个引用，当`MyThread`的`run`函数没有结束时，`MyThread`是不会被销毁的，\n\t因此它所引用的`Activity`也不会被销毁，因此就出现了内存泄露的问题。\n\n11. 单例造成的内存泄漏      \n  \t由于单例的静态特性使得其生命周期跟应用的生命周期一样长，所以如果使用不恰当的话，很容易造成内存泄漏，比如:      \n\t```java\n\tpublic class AppManager {\n\t\tprivate static AppManager instance;\n\t\tprivate Context context;\n\t\tprivate AppManager(Context context) {\n\t\t\tthis.context = context;\n\t\t}\n\t\tpublic static AppManager getInstance(Context context) {\n\t\t\tif (instance != null) {\n\t\t\t\tinstance = new AppManager(context);\n\t\t\t}\n\t\t\treturn instance;\n\t\t}\n\t}\n\t```\n\t这里如果传入的是`Activity`的`Context`，当该`Context`的`Activity`退出后，由于其被单例对象引用，所以会导致`Activity`无法被回收，就造成内存泄漏。\n\t\n8. 尽量使用`ApplicationContext`\n\t**`Context`引用的生命周期超过它本身的生命周期，也会导致`Context`泄漏**。\n\t所以如果打算保存一个长时间的对象时尽量使用`Application`这种`Context`类型。\n\t例如: \n\t```java\n\tmStorageManager = (StorageManager) getSystemService(Context.STORAGE_SERVICE);\n\t改成：\n\tmStorageManager = (StorageManager) getApplicationContext().getSystemService(Context.STORAGE_SERVICE);\n\t```\n\t按道理来说这种系统服务是不会有问题，但是有些厂商在修改的时候，可能会导致`Context`无法被及时释放。\n\t\n9. Handler的使用,在Activity退出的时候注意移除(尤其是循环的时候)\n    ```java\n\tpublic class ThreadDemo extends Activity {  \n\t\tprivate static final String TAG = \"ThreadDemo\";  \n\t\tprivate int count = 0;  \n\t\tprivate Handler mHandler =  new Handler();  \n\t\t  \n\t\tprivate Runnable mRunnable = new Runnable() {  \n\t\t\t  \n\t\t\tpublic void run() {  \n\t\t\t\t//为了方便 查看，我们用Log打印出来   \n\t\t\t\tLog.e(TAG, Thread.currentThread().getName() + \" \" +count);    \n\t\t\t\t//每2秒执行一次   \n\t\t\t\tmHandler.postDelayed(mRunnable, 2000);  \n\t\t\t}   \n\t\t};  \n\t\t@Override  \n\t\tpublic void onCreate(Bundle savedInstanceState) {  \n\t\t\tsuper.onCreate(savedInstanceState);  \n\t\t\tsetContentView(R.layout.main);   \n\t\t\t//通过Handler启动线程   \n\t\t\tmHandler.post(mRunnable);  \n\t\t} \n\t} \n\t```\n\t这样在也会引发内存泄露。我们应该在`onDestory`方法中移除`Handler`,代码如下：\n\t```java\n\t@Override  \n\tprotected void onDestroy() {  \n\t\tsuper.onDestroy();  \n\t\tmHandler.removeCallbacks(mRunnable);  \n\t} \n\t```\n10. 由上面的`Handler`可以引伸出来的匿名内部类、非静态内部类和异步现成导致的内存泄漏。      \n    下面看一个非静态内部类创建静态实例导致的内存泄漏\n\t```java\n\tpublic class MainActivity extends AppCompatActivity {\n\t\tprivate static TestResource mResource = null;\n\t\t@Override\n\t\tprotected void onCreate(Bundle savedInstanceState) {\n\t\t\tsuper.onCreate(savedInstanceState);\n\t\t\tsetContentView(R.layout.activity_main);\n\t\t\tif(mManager == null){\n\t\t\t\tmManager = new TestResource();\n\t\t\t}\n\t\t\t//...\n\t\t}\n\t\tclass TestResource {\n\t\t\t//...\n\t\t}\n\t}\n\t```\n\t因为非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态实例，该实例的声明周期与应用的一样长，\n\t这就导致了静态实例一直会持有`Activity`的引用而造成内存泄漏。             \n\t下面再看一个匿名内部类和异步现成的现象:        \n\t```java\n\tpublic class MainActivity extends Activity {\n\t\t...\n\t\tRunnable ref1 = new MyRunable();\n\t\tRunnable ref2 = new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\n\t\t\t}\n\t\t};\n\t\t...\n\t}\n\t```\n\t上面的离职中`ref1`对象是没问题的，但是`ref2`这个匿名类的实现对象中有外部类的引用，如果此时线程的生命周期与`Activity`的不一致时就会造成了泄漏。\n\t\n10. 集合类泄漏           \n    集合类中如果只有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量(比如类中的静态属性)，那么没有\n\t响应的删除机制，很可能导致集合所占用的内存只增不减。\n\t\n\n总结一下避免`Contex`t泄漏应该注意的问题：        \n\n- 使用`getApplicationContext()`类型。 \n- 注意对`Context`的引用不要超过它本身的生命周期。 \n- 慎重的使用`static`关键字。 \n- `Activity`里如果有线程或`Handler`时，一定要在`onDestroy()`里及时停掉。 \n\n---\n\n- 邮箱 ：charon.chui@gmail.com  \n- Good Luck! "]],[0,0],[7377,7377]]],[1518596355770,["gengmei_pxf@gengmei123.local",[[1,690,"\n"]],[690,690],[691,691]]],[1518596369819,["gengmei_pxf@gengmei123.local",[[1,1163,"### "]],[1163,1163],[1167,1167]]],[1518596381971,["gengmei_pxf@gengmei123.local",[[1,1224,"### "]],[1224,1224],[1228,1228]]],[1518596385808,["gengmei_pxf@gengmei123.local",[[1,2247,"### "]],[2247,2247],[2251,2251]]],[1518596387186,["gengmei_pxf@gengmei123.local",[[1,2368,"### "]],[2368,2368],[2372,2372]]],[1518596388466,["gengmei_pxf@gengmei123.local",[[1,2399,"### "]],[2399,2399],[2403,2403]]],[1518596389594,["gengmei_pxf@gengmei123.local",[[1,2435,"### "]],[2435,2435],[2439,2439]]],[1518596395312,["gengmei_pxf@gengmei123.local",[[1,3653,"### "]],[3653,3653],[3657,3657]]],[1518596399690,["gengmei_pxf@gengmei123.local",[[1,4909,"### "]],[4909,4909],[4913,4913]]],[1518596401946,["gengmei_pxf@gengmei123.local",[[1,5304,"### "]],[5304,5304],[5308,5308]]],[1518596406131,["gengmei_pxf@gengmei123.local",[[1,6183,"### "]],[6183,6183],[6187,6187]]],[1518596414977,["gengmei_pxf@gengmei123.local",[[1,4393,"### "]],[4393,4393],[4397,4397]]],[1518596419258,["gengmei_pxf@gengmei123.local",[[-1,4393,"### 11. 单例造成的内存泄漏      \n  \t由于单例的静态特性使得其生命周期跟应用的生命周期一样长，所以如果使用不恰当的话，很容易造成内存泄漏，比如:      \n\t```java\n\tpublic class AppManager {\n\t\tprivate static AppManager instance;\n\t\tprivate Context context;\n\t\tprivate AppManager(Context context) {\n\t\t\tthis.context = context;\n\t\t}\n\t\tpublic static AppManager getInstance(Context context) {\n\t\t\tif (instance != null) {\n\t\t\t\tinstance = new AppManager(context);\n\t\t\t}\n\t\t\treturn instance;\n\t\t}\n\t}\n\t```\n\t这里如果传入的是`Activity`的`Context`，当该`Context`的`Activity`退出后，由于其被单例对象引用，所以会导致`Activity`无法被回收，就造成内存泄漏。"]],[4393,4910],[4393,4393]]],[1518596419928,["gengmei_pxf@gengmei123.local",[[-1,4393,"\n"]],[4393,4393],[4392,4392]]],[1518596420279,["gengmei_pxf@gengmei123.local",[[-1,4392,"\n"]],[4392,4392],[4391,4391]]],[1518596427255,["gengmei_pxf@gengmei123.local",[[1,6555,"\n"]],[6554,6554],[6555,6555]]],[1518596428238,["gengmei_pxf@gengmei123.local",[[1,6555,"### 11. 单例造成的内存泄漏      \n  \t由于单例的静态特性使得其生命周期跟应用的生命周期一样长，所以如果使用不恰当的话，很容易造成内存泄漏，比如:      \n\t```java\n\tpublic class AppManager {\n\t\tprivate static AppManager instance;\n\t\tprivate Context context;\n\t\tprivate AppManager(Context context) {\n\t\t\tthis.context = context;\n\t\t}\n\t\tpublic static AppManager getInstance(Context context) {\n\t\t\tif (instance != null) {\n\t\t\t\tinstance = new AppManager(context);\n\t\t\t}\n\t\t\treturn instance;\n\t\t}\n\t}\n\t```\n\t这里如果传入的是`Activity`的`Context`，当该`Context`的`Activity`退出后，由于其被单例对象引用，所以会导致`Activity`无法被回收，就造成内存泄漏。"]],[6555,6555],[7072,7072]]],[1518596434910,["gengmei_pxf@gengmei123.local",[[1,7073,"\n"]],[7073,7073],[7074,7074]]],[1518596436378,["gengmei_pxf@gengmei123.local",[[1,7074,"### "]],[7074,7074],[7078,7078]]],[1518596439167,["gengmei_pxf@gengmei123.local",[[-1,7079,"0"]],[7080,7080],[7079,7079]]],[1518596439385,["gengmei_pxf@gengmei123.local",[[1,7079,"2"]],[7079,7079],[7080,7080]]],[1518596448991,["gengmei_pxf@gengmei123.local",[[-1,7378,"---\n\n- 邮箱 ：charon.chui@gmail.com  \n- Good Luck! "]],[7378,7426],[7378,7378]]],[1518596458523,["gengmei_pxf@gengmei123.local",[[-1,7099,"    "]],[7103,7103],[7099,7099]]],[1518596459110,["gengmei_pxf@gengmei123.local",[[1,7099,"\n"]],[7099,7099],[7100,7100]]],[1518596460447,["gengmei_pxf@gengmei123.local",[[-1,7099,"\n"]],[7100,7100],[7099,7099]]],[1518596462350,["gengmei_pxf@gengmei123.local",[[1,7099,"\n"]],[7099,7099],[7100,7100]]],[1518596466358,["gengmei_pxf@gengmei123.local",[[-1,7166,"\t"]],[7166,7167],[7166,7166]]],[1518596469240,["gengmei_pxf@gengmei123.local",[[-1,7195,"\n"]],[7195,7195],[7194,7194]]],[1518596470909,["gengmei_pxf@gengmei123.local",[[-1,7193,"\t"]],[7194,7194],[7193,7193]]],[1518596495180,["gengmei_pxf@gengmei123.local",[[1,1130,"\n"]],[1130,1130],[1131,1131]]],[1518596496831,["gengmei_pxf@gengmei123.local",[[1,1131,"## "]],[1131,1131],[1134,1134]]],[1518596509220,["gengmei_pxf@gengmei123.local",[[-1,1134,"`OutOfMemoryError`主要由以下几种情况造成"]],[1134,1163],[1134,1134]]],[1518596511673,["gengmei_pxf@gengmei123.local",[[1,1134,"`OutOfMemoryError`主要由以下几种情况造成"]],[1134,1134],[1134,1163]]]]],["d306ac0a-df60-4c09-8814-9cfa124bfb72",1518596590581,"内存泄露\n===\n\n\n## 定义     \n内存泄露是指无用对象(不再使用的对象)持续占有内存或无用对象的内存得不到及时释放，从而造成的内存空间的浪费称为内存泄露。\n\n## 原因      \n长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，\n这就是`java`中内存泄露的发生场景。\n\n## 危害     \n只有一个，那就是虚拟机占用内存过高，导致`OOM`(内存溢出)。\n对于`Android`应用来说，就是你的用户打开一个`Activity`，使用完之后关闭它，内存泄露；又打开，又关闭，又泄露；几次之后，程序占用内存超过系统限制就会出现`FC`。             \n\n\n先来说一下`Java`程序运行时的内存分配策略:        \n\n- 静态内存:存放静态数据，这块内存是在编译时就已经分配好的，在程序整个运行期间都存在。\n- 栈内存:程序执行时，局部变量的创建存储区，执行结束后将自动释放。(当时学习java时花的内存分配图，现在都生疏了- -!)\n- 堆内存:存储一些new出来的内存，也叫动态内存分配，这部分内存在不使用时将会有`Java`垃圾回收器来负责回收。    \n\n举一个典型的内存泄漏的例子:     \n```java\nVector v = new Vector(100);\nfor (int i = 1; i < 100,; i++) {\n\tObject o = new Object();\n\tv.add(o);\n\to = null;\n}\n```\n\t\n在这个例子中，我们循环申请了`Object`对象，并将所申请的对象放入一个集合中，如果我们仅仅释放引用本身，那么`Vector`仍然引用\n该对象，所以这个对象对`GC`来说是不可回收的。因此，如果对象假如`Vector`后，还必须从`Vector`中删除，最简单的方法就是将\n`Vector`对象设置为`null`.\n\t\t\t\n`Java`和`C++`一个很大的区别就是`Java`有垃圾回收`GC(Garbage Collection)`自动管理内存的回收。但是我们在实际的项目中仍然会遇到内存泄露的问题。\n`Java`中对内存对象得访问是通过引用的方式，通过一个内存对象的引用变量来访问到对应的内存地址中的对象。\n`GC`会从代码栈的引用变量开始追踪，从而判断哪些内存是正在使用，如果无法跟踪到某一块堆内存，那么`GC`就认为这块内存不再使用了。\n\n`Android`手机给应用分配的内存通常是8兆左右，如果处理内存处理不当很容易造成`OutOfMemoryError`\n\n## `OutOfMemoryError`主要由以下几种情况造成： \n\n### 1. 数据库`Cursor`没关。  \n    当我们操作完数据库后，一定要调用`close()`释放资源。 \n\n### 2. 构造`Adapter`没有使用缓存`ContentView`。    \n    ```java\n    @Override  \n    public View getView(int position, View convertView, ViewGroup parent) {  \n        ViewHolder vHolder = null;  \n        //如果convertView对象为空则创建新对象，不为空则复用  \n        if (convertView == null) {  \n            convertView = inflater.inflate(..., null);  \n            // 创建 ViewHodler 对象  \n            vHolder = new ViewHolder();  \n            vHolder.img= (ImageView) convertView.findViewById(...);  \n            vHolder.tv= (TextView) convertView  \n                    .findViewById(...);  \n            // 将ViewHodler保存到Tag中  \n            convertView.setTag(vHolder);  \n        } else {  \n            //当convertView不为空时，通过getTag()得到View  \n            vHolder = (ViewHolder) convertView.getTag();  \n        }  \n        // 给对象赋值，修改显示的值  \n        vHolder.img.setImageBitmap(...);  \n        vHolder.tv.setText(...);  \n        return convertView;  \n    }  \n    \n    static class ViewHolder {  \n        TextView tv;  \n        ImageView img;  \n    }  \n    ```\n\n### 3. 未取消注册广播接收者     \n    `registerReceiver()`和`unregisterReceiver()`要成对出现，通常需要在`Activity`的`onDestory()`方法去取消注册广播接收者。\n\t\n### 4. `IO`流未关闭\n    注意用完后及时关闭\n\n### 5. `Bitmap`使用后未调用`recycle()`。 \n\n### 6. `Context`泄漏\n    这是一个很隐晦的`OutOfMemoryError`的情况。先看一个Android官网提供的例子： \n\n    ```java\n    private static Drawable sBackground;  \n    @Override  \n    protected void onCreate(Bundle state) {  \n    \tsuper.onCreate(state);  \n    \tTextView label = new TextView(this);  \n    \tlabel.setText(\"Leaks are bad\");  \n    \tif (sBackground == null) {  \n    \t\tsBackground = getDrawable(R.drawable.large_bitmap);  \n    \t}  \n    \tlabel.setBackgroundDrawable(sBackground);  \n    \tsetContentView(label);  \n    }  \n    ```\n    这段代码效率很快，但同时又是极其错误的：    \n\t我们看一下`setBackgroundDrawable(Drawable background)`的源码：\n\t```java\n\t public void setBackgroundDrawable(Drawable background) {\n\t\t...\n\t\tbackground.setCallback(this);\n\t }\n\t```\n\t有`background.setCallback(this);`方法，也就是说`Drawable`拥有`TextView`的引用，而`TextView`又拥有`Activity`*(Context类型)*的引用，\n\t因为`sBackground`为`static`的，即使`Activity`被销毁，但是`sBackground`的生命周期还没走完，所以内存仍然不会被释放。这样就会有内存泄露了。\n\t对，这样想是对的，但是我们看一下`setCallback`的源码：\n\t```java\n\t  public final void setCallback(Callback cb) {\n        mCallback = new WeakReference<Callback>(cb);\n    }\n\t```\n\t我们会发现里面使用了`WeakReference`，所以不会存在内存泄露了，但是官网当时提供的例子明明说有泄露，这是因为在3.0之后，\n\t修复了这个内存泄露的问题，在3.0之前`setCallback`，方法是没有使用`WeakReference`的，所以这种泄露的情况在3.0之前会发生，3.0之后已经被修复。\n\t\n### 7. 线程\n    线程也是造成内存泄露的一个重要的源头。线程产生内存泄露的主要原因在于线程生命周期的不可控。我们来考虑下面一段代码。\n    ```java\n\tpublic class MyActivity extends Activity {     \n\t\t@Override     \n\t\tpublic void onCreate(Bundle savedInstanceState) {         \n\t\t\tsuper.onCreate(savedInstanceState);         \n\t\t\tsetContentView(R.layout.main);         \n\t\t\tnew MyThread().start();     \n\t\t}       \n\t\tprivate class MyThread extends Thread{         \n\t\t@Override         \n\t\t\tpublic void run() {             \n\t\t\tsuper.run();             \n\t\t\t//耗时的操作       \n\t\t\t}     \n\t\t} \n\t}  \n\t```\n    假设`MyThread`的`run`函数是一个很费时的操作，当调用`finish`的时候`Activity`会销毁掉吗？    \n    事实上由于我们的线程是`Activity`的内部类，所以`MyThread`中保存了`Activity`的一个引用，当`MyThread`的`run`函数没有结束时，`MyThread`是不会被销毁的，\n\t因此它所引用的`Activity`也不会被销毁，因此就出现了内存泄露的问题。\n\t\n### 8. 尽量使用`ApplicationContext`\n\t**`Context`引用的生命周期超过它本身的生命周期，也会导致`Context`泄漏**。\n\t所以如果打算保存一个长时间的对象时尽量使用`Application`这种`Context`类型。\n\t例如: \n\t```java\n\tmStorageManager = (StorageManager) getSystemService(Context.STORAGE_SERVICE);\n\t改成：\n\tmStorageManager = (StorageManager) getApplicationContext().getSystemService(Context.STORAGE_SERVICE);\n\t```\n\t按道理来说这种系统服务是不会有问题，但是有些厂商在修改的时候，可能会导致`Context`无法被及时释放。\n\t\n### 9. Handler的使用,在Activity退出的时候注意移除(尤其是循环的时候)\n    ```java\n\tpublic class ThreadDemo extends Activity {  \n\t\tprivate static final String TAG = \"ThreadDemo\";  \n\t\tprivate int count = 0;  \n\t\tprivate Handler mHandler =  new Handler();  \n\t\t  \n\t\tprivate Runnable mRunnable = new Runnable() {  \n\t\t\t  \n\t\t\tpublic void run() {  \n\t\t\t\t//为了方便 查看，我们用Log打印出来   \n\t\t\t\tLog.e(TAG, Thread.currentThread().getName() + \" \" +count);    \n\t\t\t\t//每2秒执行一次   \n\t\t\t\tmHandler.postDelayed(mRunnable, 2000);  \n\t\t\t}   \n\t\t};  \n\t\t@Override  \n\t\tpublic void onCreate(Bundle savedInstanceState) {  \n\t\t\tsuper.onCreate(savedInstanceState);  \n\t\t\tsetContentView(R.layout.main);   \n\t\t\t//通过Handler启动线程   \n\t\t\tmHandler.post(mRunnable);  \n\t\t} \n\t} \n\t```\n\t这样在也会引发内存泄露。我们应该在`onDestory`方法中移除`Handler`,代码如下：\n\t```java\n\t@Override  \n\tprotected void onDestroy() {  \n\t\tsuper.onDestroy();  \n\t\tmHandler.removeCallbacks(mRunnable);  \n\t} \n\t```\n### 10. 由上面的`Handler`可以引伸出来的匿名内部类、非静态内部类和异步现成导致的内存泄漏。      \n    下面看一个非静态内部类创建静态实例导致的内存泄漏\n\t```java\n\tpublic class MainActivity extends AppCompatActivity {\n\t\tprivate static TestResource mResource = null;\n\t\t@Override\n\t\tprotected void onCreate(Bundle savedInstanceState) {\n\t\t\tsuper.onCreate(savedInstanceState);\n\t\t\tsetContentView(R.layout.activity_main);\n\t\t\tif(mManager == null){\n\t\t\t\tmManager = new TestResource();\n\t\t\t}\n\t\t\t//...\n\t\t}\n\t\tclass TestResource {\n\t\t\t//...\n\t\t}\n\t}\n\t```\n\t因为非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态实例，该实例的声明周期与应用的一样长，\n\t这就导致了静态实例一直会持有`Activity`的引用而造成内存泄漏。             \n\t下面再看一个匿名内部类和异步现成的现象:        \n\t```java\n\tpublic class MainActivity extends Activity {\n\t\t...\n\t\tRunnable ref1 = new MyRunable();\n\t\tRunnable ref2 = new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\n\t\t\t}\n\t\t};\n\t\t...\n\t}\n\t```\n\t上面的离职中`ref1`对象是没问题的，但是`ref2`这个匿名类的实现对象中有外部类的引用，如果此时线程的生命周期与`Activity`的不一致时就会造成了泄漏。\n\t\n### 11. 单例造成的内存泄漏      \n  \t由于单例的静态特性使得其生命周期跟应用的生命周期一样长，所以如果使用不恰当的话，很容易造成内存泄漏，比如:      \n\t```java\n\tpublic class AppManager {\n\t\tprivate static AppManager instance;\n\t\tprivate Context context;\n\t\tprivate AppManager(Context context) {\n\t\t\tthis.context = context;\n\t\t}\n\t\tpublic static AppManager getInstance(Context context) {\n\t\t\tif (instance != null) {\n\t\t\t\tinstance = new AppManager(context);\n\t\t\t}\n\t\t\treturn instance;\n\t\t}\n\t}\n\t```\n\t这里如果传入的是`Activity`的`Context`，当该`Context`的`Activity`退出后，由于其被单例对象引用，所以会导致`Activity`无法被回收，就造成内存泄漏。\n\n### 12. 集合类泄漏           \n\n集合类中如果只有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量(比如类中的静态属性)，那么没有\n响应的删除机制，很可能导致集合所占用的内存只增不减。\n\n总结一下避免`Contex`t泄漏应该注意的问题：        \n\n- 使用`getApplicationContext()`类型。 \n- 注意对`Context`的引用不要超过它本身的生命周期。 \n- 慎重的使用`static`关键字。 \n- `Activity`里如果有线程或`Handler`时，一定要在`onDestroy()`里及时停掉。 \n\n",[[1518596555715,["gengmei_pxf@gengmei123.local",[[1,5672,"\n"]],[5671,5671],[5672,5672]]],[1518596555882,["gengmei_pxf@gengmei123.local",[[1,5673,"\n"]],[5672,5672],[5673,5673]]],[1518596556642,["gengmei_pxf@gengmei123.local",[[1,5674,"\n"]],[5673,5673],[5674,5674]]],[1518596557868,["gengmei_pxf@gengmei123.local",[[1,5673,"Handler导致内存泄露分析\n===\n\n有关内存泄露请猛戳[内存泄露](https://github.com/CharonChui/AndroidNote/blob/master/Android%E5%9F%BA%E7%A1%80/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F.md)\n\n```java\nHandler mHandler = new Handler() {\n    @Override\n    public void handleMessage(Message msg) {\n\t    // do something.\n    }\n}\n```\n当我们这样创建`Handler`的时候`Android Lint`会提示我们这样一个`warning： In Android, Handler classes should be static or leaks might occur.`。       \n     \n一直以来没有仔细的去分析泄露的原因，先把主要原因列一下：    \n- `Android`程序第一次创建的时候，默认会创建一个`Looper`对象，`Looper`去处理`Message Queue`中的每个`Message`,主线程的`Looper`存在整个应用程序的生命周期.\n- `Hanlder`在主线程创建时会关联到`Looper`的`Message Queue`,`Message`添加到消息队列中的时候`Message(排队的Message)`会持有当前`Handler`引用，\n当`Looper`处理到当前消息的时候，会调用`Handler#handleMessage(Message)`.就是说在`Looper`处理这个`Message`之前，\n会有一条链`MessageQueue -> Message -> Handler -> Activity`，由于它的引用导致你的`Activity`被持有引用而无法被回收`\n- **在java中，no-static的内部类会隐式的持有当前类的一个引用。static的内部类则没有。**\n\n##具体分析\n```java\npublic class SampleActivity extends Activity {\n\n  private final Handler mHandler = new Handler() {\n\t\t@Override\n\t\tpublic void handleMessage(Message msg) {\n\t\t  // do something\n\t\t}\n  }\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\t// 发送一个10分钟后执行的一个消息\n\tmHandler.postDelayed(new Runnable() {\n\t  @Override\n\t  public void run() { }\n\t}, 600000);\n\n\t// 结束当前的Activity\n\tfinish();\n}\n```\n在`finish()`的时候，该`Message`还没有被处理，`Message`持有`Handler`,`Handler`持有`Activity`,这样会导致该`Activity`不会被回收，就发生了内存泄露.\n\n##解决方法 \n- 通过程序逻辑来进行保护。\n    - 如果`Handler`中执行的是耗时的操作，在关闭`Activity`的时候停掉你的后台线程。线程停掉了，就相当于切断了`Handler`和外部连接的线，\n\t`Activity`自然会在合适的时候被回收。 \n    - 如果`Handler`是被`delay`的`Message`持有了引用，那么在`Activity`的`onDestroy()`方法要调用`Handler`的`remove*`方法，把消息对象从消息队列移除就行了。 \n\t    - 关于`Handler.remove*`方法\n\t\t\t- `removeCallbacks(Runnable r)` ——清除r匹配上的Message。    \n\t\t\t- `removeC4allbacks(Runnable r, Object token)` ——清除r匹配且匹配token（Message.obj）的Message，token为空时，只匹配r。\n\t\t\t- `removeCallbacksAndMessages(Object token)` ——清除token匹配上的Message。\n\t\t\t- `removeMessages(int what)` ——按what来匹配     \n\t\t\t- `removeMessages(int what, Object object)` ——按what来匹配      \n\t\t\t我们更多需要的是清除以该`Handler`为`target`的所有`Message(Callback)`就调用如下方法即可`handler.removeCallbacksAndMessages(null)`;\n- 将`Handler`声明为静态类。\n    静态类不持有外部类的对象，所以你的`Activity`可以随意被回收。但是不持有`Activity`的引用，如何去操作`Activity`中的一些对象？ 这里要用到弱引用\n\t\n```java\npublic class MyActivity extends Activity {\n\tprivate MyHandler mHandler;\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tmHandler = new MyHandler(this);\n\t}\n\n\t@Override\n\tprotected void onDestroy() {\n\t\t// Remove all Runnable and Message.\n\t\tmHandler.removeCallbacksAndMessages(null);\n\t\tsuper.onDestroy();\n\t}\n\n\tstatic class MyHandler extends Handler {\n\t\t// WeakReference to the outer class's instance.\n\t\tprivate WeakReference<MyActivity> mOuter;\n\n\t\tpublic MyHandler(MyActivity activity) {\n\t\t\tmOuter = new WeakReference<MyActivity>(activity);\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleMessage(Message msg) {\n\t\t\tMyActivity outer = mOuter.get();\n\t\t\tif (outer != null) {\n\t\t\t\t// Do something with outer as your wish.\n\t\t\t}\n\t\t}\n\t}\n}\n```\n"]],[5673,5673],[8760,8760]]],[1518596563035,["gengmei_pxf@gengmei123.local",[[-1,5689,"===\n"]],[5689,5693],[5689,5689]]],[1518596563762,["gengmei_pxf@gengmei123.local",[[-1,5689,"\n"]],[5689,5689],[5688,5688]]],[1518596607547,["gengmei_pxf@gengmei123.local",[[-1,5673,"Handler导致内存泄露分析"]],[5673,5688],[5673,5673]]],[1518596608017,["gengmei_pxf@gengmei123.local",[[-1,5673,"\n"]],[5673,5673],[5672,5672]]],[1518596608625,["gengmei_pxf@gengmei123.local",[[-1,5672,"\n"]],[5672,5672],[5671,5671]]],[1518596614226,["gengmei_pxf@gengmei123.local",[[1,4799,"Handler导致内存泄露分析"]],[4799,4799],[4814,4814]]],[1518596615456,["gengmei_pxf@gengmei123.local",[[1,4814,"\n"]],[4814,4814],[4815,4815]]],[1518596631512,["gengmei_pxf@gengmei123.local",[[-1,4798,"."]],[4799,4799],[4798,4798]]],[1518596632825,["gengmei_pxf@gengmei123.local",[[1,4798,"."]],[4798,4798],[4799,4799]]],[1518596634287,["gengmei_pxf@gengmei123.local",[[-1,4798,"."]],[4799,4799],[4798,4798]]],[1518596635362,["gengmei_pxf@gengmei123.local",[[1,4798,"。"]],[4798,4798],[4799,4799]]],[1518596637120,["gengmei_pxf@gengmei123.local",[[-1,4798,"。"]],[4799,4799],[4798,4798]]],[1518596637554,["gengmei_pxf@gengmei123.local",[[1,4798,"。"]],[4798,4798],[4799,4799]]],[1518596638193,["gengmei_pxf@gengmei123.local",[[-1,4798,"。"]],[4799,4799],[4798,4798]]],[1518596638906,["gengmei_pxf@gengmei123.local",[[1,4798,"."]],[4798,4798],[4799,4799]]],[1518596645711,["gengmei_pxf@gengmei123.local",[[1,4856,"\n"]],[4855,4855],[4856,4856]]],[1518596658103,["gengmei_pxf@gengmei123.local",[[-1,4857,"    ```java"]],[4868,4868],[4857,4857]]],[1518596658790,["gengmei_pxf@gengmei123.local",[[-1,4857,"\n"]],[4857,4857],[4856,4856]]],[1518596660685,["gengmei_pxf@gengmei123.local",[[1,4856,"```"]],[4856,4856],[4859,4859]]],[1518596668438,["gengmei_pxf@gengmei123.local",[[1,5680,"\n"]],[5680,5680],[5681,5681]]],[1518596671270,["gengmei_pxf@gengmei123.local",[[-1,5822,"java"]],[5822,5826],[5822,5822]]],[1518596677206,["gengmei_pxf@gengmei123.local",[[1,5947,"\n"]],[5946,5946],[5947,5947]]],[1518596706085,["gengmei_pxf@gengmei123.local",[[-1,4856,"```\n\tpublic class ThreadDemo extends Activity {  \n\t\tprivate static final String TAG = \"ThreadDemo\";  \n\t\tprivate int count = 0;  \n\t\tprivate Handler mHandler =  new Handler();  \n\t\t  \n\t\tprivate Runnable mRunnable = new Runnable() {  \n\t\t\t  \n\t\t\tpublic void run() {  \n\t\t\t\t//为了方便 查看，我们用Log打印出来   \n\t\t\t\tLog.e(TAG, Thread.currentThread().getName() + \" \" +count);    \n\t\t\t\t//每2秒执行一次   \n\t\t\t\tmHandler.postDelayed(mRunnable, 2000);  \n\t\t\t}   \n\t\t};  \n\t\t@Override  \n\t\tpublic void onCreate(Bundle savedInstanceState) {  \n\t\t\tsuper.onCreate(savedInstanceState);  \n\t\t\tsetContentView(R.layout.main);   \n\t\t\t//通过Handler启动线程   \n\t\t\tmHandler.post(mRunnable);  \n\t\t} \n\t} \n\t```\n\t这样在也会引发内存泄露。我们应该在`onDestory`方法中移除`Handler`,代码如下：\n\t```java\n\t@Override  \n\tprotected void onDestroy() {  \n\t\tsuper.onDestroy();  \n\t\tmHandler.removeCallbacks(mRunnable);  \n\t} \n\t```\n"]],[4856,5680],[4856,4856]]],[1518596707178,["gengmei_pxf@gengmei123.local",[[-1,4856,"\n"]],[4856,4856],[4855,4855]]],[1518596739587,["gengmei_pxf@gengmei123.local",[[1,9625,"\n"]],[9624,9624],[9625,9625]]],[1518596740060,["gengmei_pxf@gengmei123.local",[[1,9625,"#### 什么情况导致oom-乐视-美团\n\nhttp://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0920/3478.html\n\n1）使用更加轻量的数据结构\n2）Android里面使用Enum\n3）Bitmap对象的内存占用\n4）更大的图片\n5）onDraw方法里面执行对象的创建\n6）StringBuilder"]],[9625,9625],[9813,9813]]],[1518596748027,["gengmei_pxf@gengmei123.local",[[-1,9627,"##"]],[9628,9628],[9627,9627]]],[1518596801062,["gengmei_pxf@gengmei123.local",[[1,9812,"\n"]],[9811,9811],[9812,9812]]],[1518596801550,["gengmei_pxf@gengmei123.local",[[1,9813,"\n"]],[9812,9812],[9813,9813]]],[1518596801977,["gengmei_pxf@gengmei123.local",[[1,9813,"## 静态的Activity\n activity 类中定义一个 static 变量，并且将其指向一个[运行中的 activity 实例](https://github.com/NimbleDroid/Memory-Leaks/blob/master/app/src/main/java/com/nimbledroid/memoryleaks/MainActivity.java#L110)。如果在 activity 的生命周期结束之前，没有清除这个引用，那它就会泄漏了。这是因为 activity（例如 MainActivity） 的类对象是静态的，一旦加载，就会在 APP 运行时一直常驻内存，因此如果类对象不卸载，其静态成员就不会被垃圾回收。\n\n## 静态View\n一旦 view 被加入到界面中，它就会持有 context 的强引用，也就是我们的 activity。由于我们通过一个静态成员引用了这个 view，所以我们也就引用了 activity，因此 activity 就发生了泄漏。所以一定不要把加载的 view 赋值给静态变量，如果你真的需要，那一定要确保在 activity 销毁之前[将其从 view 层级中移除](http://developer.android.com/reference/android/view/ViewGroup.html#removeView(android.view.View))。\n\n## 内部类\n非静态内部类（包括匿名内部类）默认就会持有外部类的引用，当非静态内部类对象的生命周期比外部类对象的生命周期长时，就会导致内存泄露。\n\n## Handlers\n[定义一个匿名的 Runnable 对象并将其提交到 Handler 上](https://github.com/NimbleDroid/Memory-Leaks/blob/master/app/src/main/java/com/nimbledroid/memoryleaks/MainActivity.java#L114)也可能导致 activity 泄漏。Runnable 对象间接地引用了定义它的 activity 对象，而它会被提交到 Handler 的 MessageQueue 中，如果它在 activity 销毁时还没有被处理，那就会导致 activity 泄漏了。\n\n## Threads和Timer Tasks\n只要它们是通过匿名类创建的，尽管它们在单独的线程被执行，它们也会持有对 activity 的强引用，进而导致内存泄漏。\n\n## Sensor Manager\n系统服务可以通过 [context.getSystemService](http://developer.android.com/reference/android/content/Context.html#getSystemService(java.lang.String)) 获取，它们负责执行某些后台任务，或者为硬件访问提供接口。如果 context 对象想要在服务内部的事件发生时被通知，那就需要把自己注册到服务的[监听器](https://github.com/NimbleDroid/Memory-Leaks/blob/master/app/src/main/java/com/nimbledroid/memoryleaks/MainActivity.java#L136)中。然而，这会让服务持有 activity 的引用，如果程序员忘记在 activity 销毁时取消注册，那就会导致 activity 泄漏了。"]],[9813,9813],[11324,11324]]]]],["c9bd20f4-fd36-45f1-be87-108c66d22879",1518596875419,"内存泄露\n===\n\n\n## 定义     \n内存泄露是指无用对象(不再使用的对象)持续占有内存或无用对象的内存得不到及时释放，从而造成的内存空间的浪费称为内存泄露。\n\n## 原因      \n长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，\n这就是`java`中内存泄露的发生场景。\n\n## 危害     \n只有一个，那就是虚拟机占用内存过高，导致`OOM`(内存溢出)。\n对于`Android`应用来说，就是你的用户打开一个`Activity`，使用完之后关闭它，内存泄露；又打开，又关闭，又泄露；几次之后，程序占用内存超过系统限制就会出现`FC`。             \n\n\n先来说一下`Java`程序运行时的内存分配策略:        \n\n- 静态内存:存放静态数据，这块内存是在编译时就已经分配好的，在程序整个运行期间都存在。\n- 栈内存:程序执行时，局部变量的创建存储区，执行结束后将自动释放。(当时学习java时花的内存分配图，现在都生疏了- -!)\n- 堆内存:存储一些new出来的内存，也叫动态内存分配，这部分内存在不使用时将会有`Java`垃圾回收器来负责回收。    \n\n举一个典型的内存泄漏的例子:     \n```java\nVector v = new Vector(100);\nfor (int i = 1; i < 100,; i++) {\n\tObject o = new Object();\n\tv.add(o);\n\to = null;\n}\n```\n\t\n在这个例子中，我们循环申请了`Object`对象，并将所申请的对象放入一个集合中，如果我们仅仅释放引用本身，那么`Vector`仍然引用\n该对象，所以这个对象对`GC`来说是不可回收的。因此，如果对象假如`Vector`后，还必须从`Vector`中删除，最简单的方法就是将\n`Vector`对象设置为`null`.\n\t\t\t\n`Java`和`C++`一个很大的区别就是`Java`有垃圾回收`GC(Garbage Collection)`自动管理内存的回收。但是我们在实际的项目中仍然会遇到内存泄露的问题。\n`Java`中对内存对象得访问是通过引用的方式，通过一个内存对象的引用变量来访问到对应的内存地址中的对象。\n`GC`会从代码栈的引用变量开始追踪，从而判断哪些内存是正在使用，如果无法跟踪到某一块堆内存，那么`GC`就认为这块内存不再使用了。\n\n`Android`手机给应用分配的内存通常是8兆左右，如果处理内存处理不当很容易造成`OutOfMemoryError`\n\n## `OutOfMemoryError`主要由以下几种情况造成： \n\n### 1. 数据库`Cursor`没关。  \n    当我们操作完数据库后，一定要调用`close()`释放资源。 \n\n### 2. 构造`Adapter`没有使用缓存`ContentView`。    \n    ```java\n    @Override  \n    public View getView(int position, View convertView, ViewGroup parent) {  \n        ViewHolder vHolder = null;  \n        //如果convertView对象为空则创建新对象，不为空则复用  \n        if (convertView == null) {  \n            convertView = inflater.inflate(..., null);  \n            // 创建 ViewHodler 对象  \n            vHolder = new ViewHolder();  \n            vHolder.img= (ImageView) convertView.findViewById(...);  \n            vHolder.tv= (TextView) convertView  \n                    .findViewById(...);  \n            // 将ViewHodler保存到Tag中  \n            convertView.setTag(vHolder);  \n        } else {  \n            //当convertView不为空时，通过getTag()得到View  \n            vHolder = (ViewHolder) convertView.getTag();  \n        }  \n        // 给对象赋值，修改显示的值  \n        vHolder.img.setImageBitmap(...);  \n        vHolder.tv.setText(...);  \n        return convertView;  \n    }  \n    \n    static class ViewHolder {  \n        TextView tv;  \n        ImageView img;  \n    }  \n    ```\n\n### 3. 未取消注册广播接收者     \n    `registerReceiver()`和`unregisterReceiver()`要成对出现，通常需要在`Activity`的`onDestory()`方法去取消注册广播接收者。\n\t\n### 4. `IO`流未关闭\n    注意用完后及时关闭\n\n### 5. `Bitmap`使用后未调用`recycle()`。 \n\n### 6. `Context`泄漏\n    这是一个很隐晦的`OutOfMemoryError`的情况。先看一个Android官网提供的例子： \n\n    ```java\n    private static Drawable sBackground;  \n    @Override  \n    protected void onCreate(Bundle state) {  \n    \tsuper.onCreate(state);  \n    \tTextView label = new TextView(this);  \n    \tlabel.setText(\"Leaks are bad\");  \n    \tif (sBackground == null) {  \n    \t\tsBackground = getDrawable(R.drawable.large_bitmap);  \n    \t}  \n    \tlabel.setBackgroundDrawable(sBackground);  \n    \tsetContentView(label);  \n    }  \n    ```\n    这段代码效率很快，但同时又是极其错误的：    \n\t我们看一下`setBackgroundDrawable(Drawable background)`的源码：\n\t```java\n\t public void setBackgroundDrawable(Drawable background) {\n\t\t...\n\t\tbackground.setCallback(this);\n\t }\n\t```\n\t有`background.setCallback(this);`方法，也就是说`Drawable`拥有`TextView`的引用，而`TextView`又拥有`Activity`*(Context类型)*的引用，\n\t因为`sBackground`为`static`的，即使`Activity`被销毁，但是`sBackground`的生命周期还没走完，所以内存仍然不会被释放。这样就会有内存泄露了。\n\t对，这样想是对的，但是我们看一下`setCallback`的源码：\n\t```java\n\t  public final void setCallback(Callback cb) {\n        mCallback = new WeakReference<Callback>(cb);\n    }\n\t```\n\t我们会发现里面使用了`WeakReference`，所以不会存在内存泄露了，但是官网当时提供的例子明明说有泄露，这是因为在3.0之后，\n\t修复了这个内存泄露的问题，在3.0之前`setCallback`，方法是没有使用`WeakReference`的，所以这种泄露的情况在3.0之前会发生，3.0之后已经被修复。\n\t\n### 7. 线程\n    线程也是造成内存泄露的一个重要的源头。线程产生内存泄露的主要原因在于线程生命周期的不可控。我们来考虑下面一段代码。\n    ```java\n\tpublic class MyActivity extends Activity {     \n\t\t@Override     \n\t\tpublic void onCreate(Bundle savedInstanceState) {         \n\t\t\tsuper.onCreate(savedInstanceState);         \n\t\t\tsetContentView(R.layout.main);         \n\t\t\tnew MyThread().start();     \n\t\t}       \n\t\tprivate class MyThread extends Thread{         \n\t\t@Override         \n\t\t\tpublic void run() {             \n\t\t\tsuper.run();             \n\t\t\t//耗时的操作       \n\t\t\t}     \n\t\t} \n\t}  \n\t```\n    假设`MyThread`的`run`函数是一个很费时的操作，当调用`finish`的时候`Activity`会销毁掉吗？    \n    事实上由于我们的线程是`Activity`的内部类，所以`MyThread`中保存了`Activity`的一个引用，当`MyThread`的`run`函数没有结束时，`MyThread`是不会被销毁的，\n\t因此它所引用的`Activity`也不会被销毁，因此就出现了内存泄露的问题。\n\t\n### 8. 尽量使用`ApplicationContext`\n\t**`Context`引用的生命周期超过它本身的生命周期，也会导致`Context`泄漏**。\n\t所以如果打算保存一个长时间的对象时尽量使用`Application`这种`Context`类型。\n\t例如: \n\t```java\n\tmStorageManager = (StorageManager) getSystemService(Context.STORAGE_SERVICE);\n\t改成：\n\tmStorageManager = (StorageManager) getApplicationContext().getSystemService(Context.STORAGE_SERVICE);\n\t```\n\t按道理来说这种系统服务是不会有问题，但是有些厂商在修改的时候，可能会导致`Context`无法被及时释放。\n\t\n### 9.Handler导致内存泄露分析\n Handler的使用,在Activity退出的时候注意移除(尤其是循环的时候)\n有关内存泄露请猛戳[内存泄露](https://github.com/CharonChui/AndroidNote/blob/master/Android%E5%9F%BA%E7%A1%80/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F.md)\n\n```\nHandler mHandler = new Handler() {\n    @Override\n    public void handleMessage(Message msg) {\n\t    // do something.\n    }\n}\n\n```\n当我们这样创建`Handler`的时候`Android Lint`会提示我们这样一个`warning： In Android, Handler classes should be static or leaks might occur.`。       \n     \n一直以来没有仔细的去分析泄露的原因，先把主要原因列一下：    \n- `Android`程序第一次创建的时候，默认会创建一个`Looper`对象，`Looper`去处理`Message Queue`中的每个`Message`,主线程的`Looper`存在整个应用程序的生命周期.\n- `Hanlder`在主线程创建时会关联到`Looper`的`Message Queue`,`Message`添加到消息队列中的时候`Message(排队的Message)`会持有当前`Handler`引用，\n当`Looper`处理到当前消息的时候，会调用`Handler#handleMessage(Message)`.就是说在`Looper`处理这个`Message`之前，\n会有一条链`MessageQueue -> Message -> Handler -> Activity`，由于它的引用导致你的`Activity`被持有引用而无法被回收`\n- **在java中，no-static的内部类会隐式的持有当前类的一个引用。static的内部类则没有。**\n\n##具体分析\n```java\npublic class SampleActivity extends Activity {\n\n  private final Handler mHandler = new Handler() {\n\t\t@Override\n\t\tpublic void handleMessage(Message msg) {\n\t\t  // do something\n\t\t}\n  }\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\t// 发送一个10分钟后执行的一个消息\n\tmHandler.postDelayed(new Runnable() {\n\t  @Override\n\t  public void run() { }\n\t}, 600000);\n\n\t// 结束当前的Activity\n\tfinish();\n}\n```\n在`finish()`的时候，该`Message`还没有被处理，`Message`持有`Handler`,`Handler`持有`Activity`,这样会导致该`Activity`不会被回收，就发生了内存泄露.\n\n##解决方法 \n- 通过程序逻辑来进行保护。\n    - 如果`Handler`中执行的是耗时的操作，在关闭`Activity`的时候停掉你的后台线程。线程停掉了，就相当于切断了`Handler`和外部连接的线，\n\t`Activity`自然会在合适的时候被回收。 \n    - 如果`Handler`是被`delay`的`Message`持有了引用，那么在`Activity`的`onDestroy()`方法要调用`Handler`的`remove*`方法，把消息对象从消息队列移除就行了。 \n\t    - 关于`Handler.remove*`方法\n\t\t\t- `removeCallbacks(Runnable r)` ——清除r匹配上的Message。    \n\t\t\t- `removeC4allbacks(Runnable r, Object token)` ——清除r匹配且匹配token（Message.obj）的Message，token为空时，只匹配r。\n\t\t\t- `removeCallbacksAndMessages(Object token)` ——清除token匹配上的Message。\n\t\t\t- `removeMessages(int what)` ——按what来匹配     \n\t\t\t- `removeMessages(int what, Object object)` ——按what来匹配      \n\t\t\t我们更多需要的是清除以该`Handler`为`target`的所有`Message(Callback)`就调用如下方法即可`handler.removeCallbacksAndMessages(null)`;\n- 将`Handler`声明为静态类。\n    静态类不持有外部类的对象，所以你的`Activity`可以随意被回收。但是不持有`Activity`的引用，如何去操作`Activity`中的一些对象？ 这里要用到弱引用\n\t\n```java\npublic class MyActivity extends Activity {\n\tprivate MyHandler mHandler;\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tmHandler = new MyHandler(this);\n\t}\n\n\t@Override\n\tprotected void onDestroy() {\n\t\t// Remove all Runnable and Message.\n\t\tmHandler.removeCallbacksAndMessages(null);\n\t\tsuper.onDestroy();\n\t}\n\n\tstatic class MyHandler extends Handler {\n\t\t// WeakReference to the outer class's instance.\n\t\tprivate WeakReference<MyActivity> mOuter;\n\n\t\tpublic MyHandler(MyActivity activity) {\n\t\t\tmOuter = new WeakReference<MyActivity>(activity);\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleMessage(Message msg) {\n\t\t\tMyActivity outer = mOuter.get();\n\t\t\tif (outer != null) {\n\t\t\t\t// Do something with outer as your wish.\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n### 10. 由上面的`Handler`可以引伸出来的匿名内部类、非静态内部类和异步现成导致的内存泄漏。      \n    下面看一个非静态内部类创建静态实例导致的内存泄漏\n\t```java\n\tpublic class MainActivity extends AppCompatActivity {\n\t\tprivate static TestResource mResource = null;\n\t\t@Override\n\t\tprotected void onCreate(Bundle savedInstanceState) {\n\t\t\tsuper.onCreate(savedInstanceState);\n\t\t\tsetContentView(R.layout.activity_main);\n\t\t\tif(mManager == null){\n\t\t\t\tmManager = new TestResource();\n\t\t\t}\n\t\t\t//...\n\t\t}\n\t\tclass TestResource {\n\t\t\t//...\n\t\t}\n\t}\n\t```\n\t因为非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态实例，该实例的声明周期与应用的一样长，\n\t这就导致了静态实例一直会持有`Activity`的引用而造成内存泄漏。             \n\t下面再看一个匿名内部类和异步现成的现象:        \n\t```java\n\tpublic class MainActivity extends Activity {\n\t\t...\n\t\tRunnable ref1 = new MyRunable();\n\t\tRunnable ref2 = new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\n\t\t\t}\n\t\t};\n\t\t...\n\t}\n\t```\n\t上面的离职中`ref1`对象是没问题的，但是`ref2`这个匿名类的实现对象中有外部类的引用，如果此时线程的生命周期与`Activity`的不一致时就会造成了泄漏。\n\t\n### 11. 单例造成的内存泄漏      \n  \t由于单例的静态特性使得其生命周期跟应用的生命周期一样长，所以如果使用不恰当的话，很容易造成内存泄漏，比如:      \n\t```java\n\tpublic class AppManager {\n\t\tprivate static AppManager instance;\n\t\tprivate Context context;\n\t\tprivate AppManager(Context context) {\n\t\t\tthis.context = context;\n\t\t}\n\t\tpublic static AppManager getInstance(Context context) {\n\t\t\tif (instance != null) {\n\t\t\t\tinstance = new AppManager(context);\n\t\t\t}\n\t\t\treturn instance;\n\t\t}\n\t}\n\t```\n\t这里如果传入的是`Activity`的`Context`，当该`Context`的`Activity`退出后，由于其被单例对象引用，所以会导致`Activity`无法被回收，就造成内存泄漏。\n\n### 12. 集合类泄漏           \n\n集合类中如果只有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量(比如类中的静态属性)，那么没有\n响应的删除机制，很可能导致集合所占用的内存只增不减。\n\n总结一下避免`Contex`t泄漏应该注意的问题：        \n\n- 使用`getApplicationContext()`类型。 \n- 注意对`Context`的引用不要超过它本身的生命周期。 \n- 慎重的使用`static`关键字。 \n- `Activity`里如果有线程或`Handler`时，一定要在`onDestroy()`里及时停掉。 \n\n## 什么情况导致oom-乐视-美团\n\nhttp://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0920/3478.html\n\n1）使用更加轻量的数据结构\n2）Android里面使用Enum\n3）Bitmap对象的内存占用\n4）更大的图片\n5）onDraw方法里面执行对象的创建\n6）StringBuilder\n\n## 静态的Activity\n activity 类中定义一个 static 变量，并且将其指向一个[运行中的 activity 实例](https://github.com/NimbleDroid/Memory-Leaks/blob/master/app/src/main/java/com/nimbledroid/memoryleaks/MainActivity.java#L110)。如果在 activity 的生命周期结束之前，没有清除这个引用，那它就会泄漏了。这是因为 activity（例如 MainActivity） 的类对象是静态的，一旦加载，就会在 APP 运行时一直常驻内存，因此如果类对象不卸载，其静态成员就不会被垃圾回收。\n\n## 静态View\n一旦 view 被加入到界面中，它就会持有 context 的强引用，也就是我们的 activity。由于我们通过一个静态成员引用了这个 view，所以我们也就引用了 activity，因此 activity 就发生了泄漏。所以一定不要把加载的 view 赋值给静态变量，如果你真的需要，那一定要确保在 activity 销毁之前[将其从 view 层级中移除](http://developer.android.com/reference/android/view/ViewGroup.html#removeView(android.view.View))。\n\n## 内部类\n非静态内部类（包括匿名内部类）默认就会持有外部类的引用，当非静态内部类对象的生命周期比外部类对象的生命周期长时，就会导致内存泄露。\n\n## Handlers\n[定义一个匿名的 Runnable 对象并将其提交到 Handler 上](https://github.com/NimbleDroid/Memory-Leaks/blob/master/app/src/main/java/com/nimbledroid/memoryleaks/MainActivity.java#L114)也可能导致 activity 泄漏。Runnable 对象间接地引用了定义它的 activity 对象，而它会被提交到 Handler 的 MessageQueue 中，如果它在 activity 销毁时还没有被处理，那就会导致 activity 泄漏了。\n\n## Threads和Timer Tasks\n只要它们是通过匿名类创建的，尽管它们在单独的线程被执行，它们也会持有对 activity 的强引用，进而导致内存泄漏。\n\n## Sensor Manager\n系统服务可以通过 [context.getSystemService](http://developer.android.com/reference/android/content/Context.html#getSystemService(java.lang.String)) 获取，它们负责执行某些后台任务，或者为硬件访问提供接口。如果 context 对象想要在服务内部的事件发生时被通知，那就需要把自己注册到服务的[监听器](https://github.com/NimbleDroid/Memory-Leaks/blob/master/app/src/main/java/com/nimbledroid/memoryleaks/MainActivity.java#L136)中。然而，这会让服务持有 activity 的引用，如果程序员忘记在 activity 销毁时取消注册，那就会导致 activity 泄漏了。\n",[[1518596843237,["gengmei_pxf@gengmei123.local",[[1,4815,"\n"]],[4814,4814],[4815,4815]]],[1518596843405,["gengmei_pxf@gengmei123.local",[[1,4816,"\n"]],[4815,4815],[4816,4816]]],[1518596845629,["gengmei_pxf@gengmei123.local",[[1,4817,"\n"]],[4815,4815],[4816,4816]]],[1518596845950,["gengmei_pxf@gengmei123.local",[[1,4816,"[定义一个匿名的 Runnable 对象并将其提交到 Handler 上](https://github.com/NimbleDroid/Memory-Leaks/blob/master/app/src/main/java/com/nimbledroid/memoryleaks/MainActivity.java#L114)也可能导致 activity 泄漏。Runnable 对象间接地引用了定义它的 activity 对象，而它会被提交到 Handler 的 MessageQueue 中，如果它在 activity 销毁时还没有被处理，那就会导致 activity 泄漏了。"]],[4816,4816],[5107,5107]]],[1518596857751,["gengmei_pxf@gengmei123.local",[[-1,10107,"## 静态的Activity\n activity 类中定义一个 static 变量，并且将其指向一个[运行中的 activity 实例](https://github.com/NimbleDroid/Memory-Leaks/blob/master/app/src/main/java/com/nimbledroid/memoryleaks/MainActivity.java#L110)。如果在 activity 的生命周期结束之前，没有清除这个引用，那它就会泄漏了。这是因为 activity（例如 MainActivity） 的类对象是静态的，一旦加载，就会在 APP 运行时一直常驻内存，因此如果类对象不卸载，其静态成员就不会被垃圾回收。\n\n## 静态View\n一旦 view 被加入到界面中，它就会持有 context 的强引用，也就是我们的 activity。由于我们通过一个静态成员引用了这个 view，所以我们也就引用了 activity，因此 activity 就发生了泄漏。所以一定不要把加载的 view 赋值给静态变量，如果你真的需要，那一定要确保在 activity 销毁之前[将其从 view 层级中移除](http://developer.android.com/reference/android/view/ViewGroup.html#removeView(android.view.View))。\n\n## 内部类\n非静态内部类（包括匿名内部类）默认就会持有外部类的引用，当非静态内部类对象的生命周期比外部类对象的生命周期长时，就会导致内存泄露。\n\n## Handlers\n[定义一个匿名的 Runnable 对象并将其提交到 Handler 上](https://github.com/NimbleDroid/Memory-Leaks/blob/master/app/src/main/java/com/nimbledroid/memoryleaks/MainActivity.java#L114)也可能导致 activity 泄漏。Runnable 对象间接地引用了定义它的 activity 对象，而它会被提交到 Handler 的 MessageQueue 中，如果它在 activity 销毁时还没有被处理，那就会导致 activity 泄漏了。\n\n## Threads和Timer Tasks\n只要它们是通过匿名类创建的，尽管它们在单独的线程被执行，它们也会持有对 activity 的强引用，进而导致内存泄漏。\n\n## Sensor Manager\n系统服务可以通过 [context.getSystemService](http://developer.android.com/reference/android/content/Context.html#getSystemService(java.lang.String)) 获取，它们负责执行某些后台任务，或者为硬件访问提供接口。如果 context 对象想要在服务内部的事件发生时被通知，那就需要把自己注册到服务的[监听器](https://github.com/NimbleDroid/Memory-Leaks/blob/master/app/src/main/java/com/nimbledroid/memoryleaks/MainActivity.java#L136)中。然而，这会让服务持有 activity 的引用，如果程序员忘记在 activity 销毁时取消注册，那就会导致 activity 泄漏了。"]],[10107,11618],[10107,10107]]],[1518596858292,["gengmei_pxf@gengmei123.local",[[-1,10107,"\n"]],[10107,10107],[10106,10106]]],[1518596858844,["gengmei_pxf@gengmei123.local",[[-1,10106,"\n"]],[10106,10106],[10105,10105]]],[1518596862404,["gengmei_pxf@gengmei123.local",[[1,9919,"\n"]],[9917,9917],[9918,9918]]],[1518596862980,["gengmei_pxf@gengmei123.local",[[1,9920,"\n"]],[9918,9918],[9919,9919]]],[1518596864007,["gengmei_pxf@gengmei123.local",[[1,9919,"## 静态的Activity\n activity 类中定义一个 static 变量，并且将其指向一个[运行中的 activity 实例](https://github.com/NimbleDroid/Memory-Leaks/blob/master/app/src/main/java/com/nimbledroid/memoryleaks/MainActivity.java#L110)。如果在 activity 的生命周期结束之前，没有清除这个引用，那它就会泄漏了。这是因为 activity（例如 MainActivity） 的类对象是静态的，一旦加载，就会在 APP 运行时一直常驻内存，因此如果类对象不卸载，其静态成员就不会被垃圾回收。\n\n## 静态View\n一旦 view 被加入到界面中，它就会持有 context 的强引用，也就是我们的 activity。由于我们通过一个静态成员引用了这个 view，所以我们也就引用了 activity，因此 activity 就发生了泄漏。所以一定不要把加载的 view 赋值给静态变量，如果你真的需要，那一定要确保在 activity 销毁之前[将其从 view 层级中移除](http://developer.android.com/reference/android/view/ViewGroup.html#removeView(android.view.View))。\n\n## 内部类\n非静态内部类（包括匿名内部类）默认就会持有外部类的引用，当非静态内部类对象的生命周期比外部类对象的生命周期长时，就会导致内存泄露。\n\n## Handlers\n[定义一个匿名的 Runnable 对象并将其提交到 Handler 上](https://github.com/NimbleDroid/Memory-Leaks/blob/master/app/src/main/java/com/nimbledroid/memoryleaks/MainActivity.java#L114)也可能导致 activity 泄漏。Runnable 对象间接地引用了定义它的 activity 对象，而它会被提交到 Handler 的 MessageQueue 中，如果它在 activity 销毁时还没有被处理，那就会导致 activity 泄漏了。\n\n## Threads和Timer Tasks\n只要它们是通过匿名类创建的，尽管它们在单独的线程被执行，它们也会持有对 activity 的强引用，进而导致内存泄漏。\n\n## Sensor Manager\n系统服务可以通过 [context.getSystemService](http://developer.android.com/reference/android/content/Context.html#getSystemService(java.lang.String)) 获取，它们负责执行某些后台任务，或者为硬件访问提供接口。如果 context 对象想要在服务内部的事件发生时被通知，那就需要把自己注册到服务的[监听器](https://github.com/NimbleDroid/Memory-Leaks/blob/master/app/src/main/java/com/nimbledroid/memoryleaks/MainActivity.java#L136)中。然而，这会让服务持有 activity 的引用，如果程序员忘记在 activity 销毁时取消注册，那就会导致 activity 泄漏了。"]],[9919,9919],[11430,11430]]],[1518596866752,["gengmei_pxf@gengmei123.local",[[1,9921,"#"]],[9921,9921],[9922,9922]]],[1518596872743,["gengmei_pxf@gengmei123.local",[[1,9923,"13."]],[9923,9923],[9926,9926]]],[1518596878255,["gengmei_pxf@gengmei123.local",[[1,10250,"3"]],[10250,10250],[10251,10251]]],[1518596882340,["gengmei_pxf@gengmei123.local",[[-1,10250,"3"]],[10251,10251],[10250,10250]]],[1518596882807,["gengmei_pxf@gengmei123.local",[[1,10250,"3"]],[10250,10250],[10251,10251]]],[1518596885278,["gengmei_pxf@gengmei123.local",[[1,10252,"14."]],[10252,10252],[10255,10255]]],[1518596888179,["gengmei_pxf@gengmei123.local",[[-1,10250,"3"]],[10251,10251],[10250,10250]]],[1518596889470,["gengmei_pxf@gengmei123.local",[[1,10250,"#"]],[10250,10250],[10251,10251]]],[1518596892943,["gengmei_pxf@gengmei123.local",[[1,10546,"#"]],[10546,10546],[10547,10547]]],[1518596895307,["gengmei_pxf@gengmei123.local",[[1,10548,"15."]],[10548,10548],[10551,10551]]],[1518596900500,["gengmei_pxf@gengmei123.local",[[-1,10622,"## Handlers\n[定义一个匿名的 Runnable 对象并将其提交到 Handler 上](https://github.com/NimbleDroid/Memory-Leaks/blob/master/app/src/main/java/com/nimbledroid/memoryleaks/MainActivity.java#L114)也可能导致 activity 泄漏。Runnable 对象间接地引用了定义它的 activity 对象，而它会被提交到 Handler 的 MessageQueue 中，如果它在 activity 销毁时还没有被处理，那就会导致 activity 泄漏了。"]],[10622,10925],[10622,10622]]],[1518596900987,["gengmei_pxf@gengmei123.local",[[-1,10623,"\n"]],[10622,10622],[10621,10621]]],[1518596901257,["gengmei_pxf@gengmei123.local",[[-1,10622,"\n"]],[10621,10621],[10620,10620]]],[1518596905230,["gengmei_pxf@gengmei123.local",[[1,10624,"# "]],[10624,10624],[10626,10626]]],[1518596906843,["gengmei_pxf@gengmei123.local",[[-1,10626," "]],[10627,10627],[10626,10626]]],[1518596908270,["gengmei_pxf@gengmei123.local",[[1,10626,"16."]],[10626,10626],[10629,10629]]],[1518596910982,["gengmei_pxf@gengmei123.local",[[1,10712,"#"]],[10712,10712],[10713,10713]]],[1518596913523,["gengmei_pxf@gengmei123.local",[[1,10714,"17."]],[10714,10714],[10717,10717]]],[1518596939778,["gengmei_pxf@gengmei123.local",[[-1,1134,"`OutOfMemoryError`"]],[1134,1152],[1134,1134]]]]]]}