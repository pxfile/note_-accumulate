{"compress":true,"commitItems":[["12b7a721-df52-4741-a341-3720b4d42815",1520506360049,"",[[1520506326914,["gengmei_pxf@gengmei123.local",[[1,0,"动态加载技术（也叫插件化技术）在技术驱动型的公司中扮演着相当重要的角色，当项目越来越庞大的时候，需要通过插件化来减轻应用的内存和CPU占用，还可以实现热插拔，即在不发布新版本的情况下更新某些模块。动态加载是一项很复杂的技术，这里主要介绍动态加载技术中的三个基础性问题，至于完整的动态加载技术的实现请参考笔者发起的[开源插件化框架DL](https://github.com/singwhatiwanna/dynamic-load-apk)：。项目期间有多位开发人员一起贡献代码。\n\n不同的插件化方案各有各的特色，但是它们都必须要解决三个基础性问题：资源访问、Activity生命周期的管理和ClassLoader的管理。在介绍它们之前，首先要明白宿主和插件的概念，宿主是指普通的apk，而插件一般是指经过处理的dex或者apk，在主流的插件化框架中多采用经过特殊处理的apk来作为插件，处理方式往往和编译以及打包环节有关，另外很多插件化框架都需要用到代理Activity的概念，插件Activity的启动大多数是借助一个代理Activity来实现的。\n\n### 1．资源访问\n\n我们知道，宿主程序调起未安装的插件apk，一个很大的问题就是资源如何访问，具体来说就是插件中凡是以R开头的资源都不能访问了。这是因为宿主程序中并没有插件的资源，所以通过R来加载插件的资源是行不通的，程序会抛出异常：无法找到某某id所对应的资源。\n\n针对这个问题，有人提出了将插件中的资源在宿主程序中也预置一份，这虽然能解决问题，但是这样就会产生一些弊端。首先，这样就需要宿主和插件同时持有一份相同的资源，增加了宿主apk的大小；其次，在这种模式下，每次发布一个插件都需要将资源复制到宿主程序中，这意味着每发布一个插件都要更新一下宿主程序，这就和插件化的思想相违背了。\n\n因为插件化的目的就是要减小宿主程序apk包的大小，同时降低宿主程序的更新频率并做到自由装载模块，所以这种方法不可取，它限制了插件的线上更新这一重要特性。还有人提供了另一种方式，首先将插件中的资源解压出来，然后通过文件流去读取资源，这样做理论上是可行的，但是实际操作起来还是有很大难度的。首先不同资源有不同的文件流格式，比如图片、XML等，其次针对不同设备加载的资源可能是不一样的，如何选择合适的资源也是一个需要解决的问题，基于这两点，这种方法也不建议使用，因为它实现起来有较大难度。为了方便地对插件进行资源管理，下面给出一种合理的方式。\n\n我们知道，Activity的工作主要是通过ContextImpl来完成的， Activity中有一个叫mBase的成员变量，它的类型就是ContextImpl。注意到Context中有如下两个抽象方法，看起来是和资源有关的，实际上Context就是通过它们来获取资源的。这两个抽象方法的真正实现在ContextImpl中，也就是说，只要实现这两个方法，就可以解决资源问题了。\n\n```java\n/** Return an AssetManager instance for your application's package. */\n\npublic abstract AssetManager getAssets();\n\n/** Return a Resources instance for your application's package. */\n\npublic abstract Resources getResources();\n```\n\n下面给出具体的实现方式，首先要加载apk中的资源，如下所示。\n\n```java\nprotected void loadResources() {\n\ttry {\n\t\tAssetManager assetManager = AssetManager.class.newInstance();\n\t\tMethod addAssetPath = assetManager.getClass().getMethod(\"addAssetPath\", String.class);\n\t\taddAssetPath.invoke(assetManager, mDexPath);\n\t\tmAssetManager = assetManager;\n\t} catch (Exception e) {\n\t\te.printStackTrace();\n\t}\n\tResources superRes = super.getResources();\n\tmResources = new Resources(mAssetManager, superRes.getDisplayMetrics(),\n\t\t\tsuperRes.getConfiguration());\n\tmTheme = mResources.newTheme();\n\tmTheme.setTo(super.getTheme());\n}\n\n```\n\n从loadResources()的实现可以看出，加载资源的方法是通过反射，通过调用AssetManager中的addAssetPath方法，我们可以将一个apk中的资源加载到Resources对象中，由于addAssetPath是隐藏API我们无法直接调用，所以只能通过反射。下面是它的声明，通过注释我们可以看出，传递的路径可以是zip文件也可以是一个资源目录，而apk就是一个zip，所以直接将apk的路径传给它，资源就加载到AssetManager中了。然后再通过AssetManager来创建一个新的Resources对象，通过这个对象我们就可以访问插件apk中的资源了，这样一来问题就解决了。\n\n```java\n/**\n\n * Add an additional set of assets to the asset manager.  This can be\n\n * either a directory or ZIP file.  Not for use by applications.  Returns\n\n * the cookie of the added asset, or 0 on failure.\n\n * {@hide}\n\n */\n\npublic final int addAssetPath(String path) {\n\n    synchronized (this) {\n\n        int res = addAssetPathNative(path);\n\n        makeStringBlocks(mStringBlocks);\n\n        return res;\n\n    }\n\n}\n```\n\n接着在代理Activity中实现getAssets()和getResources()，如下所示。关于代理Activity的含义请参看DL开源插件化框架的实现细节，这里不再详细描述了。\n\n```java\n@Override\n\npublic AssetManager getAssets() {\n\n    return mAssetManager == null ? super.getAssets() : mAssetManager;\n\n}\n\n@Override\n\npublic Resources getResources() {\n\n    return mResources == null ? super.getResources() : mResources;\n\n}\n```\n\n通过上述这两个步骤，就可以通过R来访问插件中的资源了。\n\n### 2．Activity生命周期的管理\n\n管理Activity生命周期的方式各种各样，这里只介绍两种：反射方式和接口方式。反射的方式很好理解，首先通过Java的反射去获取Activity的各种生命周期方法，比如onCreate、onStart、onResume等，然后在代理Activity中去调用插件Activity对应的生命周期方法即可，如下所示。\n\n```java\n@Override\n\nprotected void onResume() {\n\n    super.onResume();\n\n    Method onResume = mActivityLifecircleMethods.get(\"onResume\");\n\n    if (onResume != null) {\n\n        try {\n\n            onResume.invoke(mRemoteActivity, new Object[] { });\n\n        } catch (Exception e) {\n\n            e.printStackTrace();\n\n        }\n\n    }\n\n}\n\n@Override\n\nprotected void onPause() {\n\n    Method onPause = mActivityLifecircleMethods.get(\"onPause\");\n\n    if (onPause != null) {\n\n        try {\n\n            onPause.invoke(mRemoteActivity, new Object[] { });\n\n        } catch (Exception e) {\n\n            e.printStackTrace();\n\n        }\n\n    }\n\n    super.onPause();\n\n}\n```\n\n使用反射来管理插件Activity的生命周期是有缺点的，一方面是反射代码写起来比较复杂，另一方面是过多使用反射会有一定的性能开销。下面介绍接口方式，接口方式很好地解决了反射方式的不足之处，这种方式将Activity的生命周期方法提取出来作为一个接口（比如叫DLPlugin），然后通过代理Activity去调用插件Activity的生命周期方法，这样就完成了插件Activity的生命周期管理，并且没有采用反射，这就解决了性能问题。同时接口的声明也比较简单，下面是DLPlugin的声明：\n\n```java\npublic interface DLPlugin {\n\n    public void onStart();\n\n    public void onRestart();\n\n    public void onActivityResult(int requestCode, int resultCode, Intent\n\n    data);\n\n    public void onResume();\n\n    public void onPause();\n\n    public void onStop();\n\n    public void onDestroy();\n\n    public void onCreate(Bundle savedInstanceState);\n\n    public void setProxy(Activity proxyActivity, String dexPath);\n\n    public void onSaveInstanceState(Bundle outState);\n\n    public void onNewIntent(Intent intent);\n\n    public void onRestoreInstanceState(Bundle savedInstanceState);\n\n    public boolean onTouchEvent(MotionEvent event);\n\n    public boolean onKeyUp(int keyCode, KeyEvent event);\n\n    public void onWindowAttributesChanged(LayoutParams params);\n\n    public void onWindowFocusChanged(boolean hasFocus);\n\npublic void onBackPressed();\n\n…\n\n}\n```\n\n在代理Activity中只需要按如下方式即可调用插件Activity的生命周期方法，这就完成了插件Activity的生命周期的管理。\n\n```java\n...\n\n@Override\n\nprotected void onStart() {\n\n    mRemoteActivity.onStart();\n\n    super.onStart();\n\n}\n\n@Override\n\nprotected void onRestart() {\n\n    mRemoteActivity.onRestart();\n\n    super.onRestart();\n\n}\n\n@Override\n\nprotected void onResume() {\n\n    mRemoteActivity.onResume();\n\n    super.onResume();\n\n}\n\n...\n```\n\n通过上述代码应该不难理解接口方式对插件Activity生命周期的管理思想，其中mRemoteActivity就是DLPlugin的实现。\n\n### 3．插件ClassLoader的管理\n\n为了更好地对多插件进行支持，需要合理地去管理各个插件的DexClassLoader，这样同一个插件就可以采用同一个ClassLoader去加载类，从而避免了多个ClassLoader加载同一个类时所引发的类型转换错误。在下面的代码中，通过将不同插件的ClassLoader存储在一个HashMap中，这样就可以保证不同插件中的类彼此互不干扰。\n\n```java\npublic class DLClassLoader extends DexClassLoader {\n\n    private static final String TAG = \"DLClassLoader\";\n\n    private static final HashMap<String, DLClassLoader> mPluginClassLoaders\n\n    = new HashMap<String, DLClassLoader>();\n\n    protected DLClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) {\n\n        super(dexPath, optimizedDirectory, libraryPath, parent);\n\n    }\n\n    /**\n\n     * return a available classloader which belongs to different apk\n\n     */\n\n    public static DLClassLoader getClassLoader(String dexPath, Context\n\n    context, ClassLoader parentLoader) {\n\n        DLClassLoader dLClassLoader = mPluginClassLoaders.get(dexPath);\n\n        if (dLClassLoader != null)\n\n            return dLClassLoader;\n\n        File dexOutputDir = context.getDir(\"dex\", Context.MODE_PRIVATE);\n\n        final String dexOutputPath = dexOutputDir.getAbsolutePath();\n\n        dLClassLoader = new DLClassLoader(dexPath, dexOutputPath, null,\n\n        parentLoader);\n\n        mPluginClassLoaders.put(dexPath, dLClassLoader);\n\n        return dLClassLoader;\n\n    }\n\n}\n```\n\n事实上插件化的技术细节非常多，这绝非一个章节的内容所能描述清楚的，另外插件化作为一种核心技术，需要开发者有较深的开发功底才能够很好地理解，因此本节的内容更多是让读者对插件化开发有一个感性的了解，细节上还需要读者自己去钻研，也可以通过DL插件化框架去深入地学习。"]],[0,0],[6997,6997]]],[1520506342970,["gengmei_pxf@gengmei123.local",[[-1,479,"#"]],[480,480],[479,479]]],[1520506356168,["gengmei_pxf@gengmei123.local",[[-1,3155,"#"]],[3156,3156],[3155,3155]]],[1520506362968,["gengmei_pxf@gengmei123.local",[[-1,5554,"#"]],[5554,5554],[5553,5553]]],[1520506372760,["gengmei_pxf@gengmei123.local",[[1,0,"\n"]],[0,0],[1,1]]],[1520506380785,["gengmei_pxf@gengmei123.local",[[1,0,"Android动态加载"]],[0,0],[11,11]]],[1520506381119,["gengmei_pxf@gengmei123.local",[[1,12,"\n"]],[11,11],[12,12]]],[1520506382673,["gengmei_pxf@gengmei123.local",[[1,12,"=="]],[12,12],[14,14]]],[1520506383687,["gengmei_pxf@gengmei123.local",[[1,15,"\n"]],[14,14],[15,15]]],[1520506395126,["gengmei_pxf@gengmei123.local",[[1,16,"\n"]],[15,15],[16,16]]],[1520506401297,["gengmei_pxf@gengmei123.local",[[1,16,"## 什么是动态加载"]],[16,16],[26,26]]],[1520506401742,["gengmei_pxf@gengmei123.local",[[1,27,"\n"]],[26,26],[27,27]]]]],["7d7bb5fa-41e9-4b00-9042-28a4c7eeaa33",1520508313267,"Android动态加载\n==\n\n## 什么是动态加载\n\n动态加载技术（也叫插件化技术）在技术驱动型的公司中扮演着相当重要的角色，当项目越来越庞大的时候，需要通过插件化来减轻应用的内存和CPU占用，还可以实现热插拔，即在不发布新版本的情况下更新某些模块。动态加载是一项很复杂的技术，这里主要介绍动态加载技术中的三个基础性问题，至于完整的动态加载技术的实现请参考笔者发起的[开源插件化框架DL](https://github.com/singwhatiwanna/dynamic-load-apk)：。项目期间有多位开发人员一起贡献代码。\n\n不同的插件化方案各有各的特色，但是它们都必须要解决三个基础性问题：资源访问、Activity生命周期的管理和ClassLoader的管理。在介绍它们之前，首先要明白宿主和插件的概念，宿主是指普通的apk，而插件一般是指经过处理的dex或者apk，在主流的插件化框架中多采用经过特殊处理的apk来作为插件，处理方式往往和编译以及打包环节有关，另外很多插件化框架都需要用到代理Activity的概念，插件Activity的启动大多数是借助一个代理Activity来实现的。\n\n## 1．资源访问\n\n我们知道，宿主程序调起未安装的插件apk，一个很大的问题就是资源如何访问，具体来说就是插件中凡是以R开头的资源都不能访问了。这是因为宿主程序中并没有插件的资源，所以通过R来加载插件的资源是行不通的，程序会抛出异常：无法找到某某id所对应的资源。\n\n针对这个问题，有人提出了将插件中的资源在宿主程序中也预置一份，这虽然能解决问题，但是这样就会产生一些弊端。首先，这样就需要宿主和插件同时持有一份相同的资源，增加了宿主apk的大小；其次，在这种模式下，每次发布一个插件都需要将资源复制到宿主程序中，这意味着每发布一个插件都要更新一下宿主程序，这就和插件化的思想相违背了。\n\n因为插件化的目的就是要减小宿主程序apk包的大小，同时降低宿主程序的更新频率并做到自由装载模块，所以这种方法不可取，它限制了插件的线上更新这一重要特性。还有人提供了另一种方式，首先将插件中的资源解压出来，然后通过文件流去读取资源，这样做理论上是可行的，但是实际操作起来还是有很大难度的。首先不同资源有不同的文件流格式，比如图片、XML等，其次针对不同设备加载的资源可能是不一样的，如何选择合适的资源也是一个需要解决的问题，基于这两点，这种方法也不建议使用，因为它实现起来有较大难度。为了方便地对插件进行资源管理，下面给出一种合理的方式。\n\n我们知道，Activity的工作主要是通过ContextImpl来完成的， Activity中有一个叫mBase的成员变量，它的类型就是ContextImpl。注意到Context中有如下两个抽象方法，看起来是和资源有关的，实际上Context就是通过它们来获取资源的。这两个抽象方法的真正实现在ContextImpl中，也就是说，只要实现这两个方法，就可以解决资源问题了。\n\n```java\n/** Return an AssetManager instance for your application's package. */\n\npublic abstract AssetManager getAssets();\n\n/** Return a Resources instance for your application's package. */\n\npublic abstract Resources getResources();\n```\n\n下面给出具体的实现方式，首先要加载apk中的资源，如下所示。\n\n```java\nprotected void loadResources() {\n\ttry {\n\t\tAssetManager assetManager = AssetManager.class.newInstance();\n\t\tMethod addAssetPath = assetManager.getClass().getMethod(\"addAssetPath\", String.class);\n\t\taddAssetPath.invoke(assetManager, mDexPath);\n\t\tmAssetManager = assetManager;\n\t} catch (Exception e) {\n\t\te.printStackTrace();\n\t}\n\tResources superRes = super.getResources();\n\tmResources = new Resources(mAssetManager, superRes.getDisplayMetrics(),\n\t\t\tsuperRes.getConfiguration());\n\tmTheme = mResources.newTheme();\n\tmTheme.setTo(super.getTheme());\n}\n\n```\n\n从loadResources()的实现可以看出，加载资源的方法是通过反射，通过调用AssetManager中的addAssetPath方法，我们可以将一个apk中的资源加载到Resources对象中，由于addAssetPath是隐藏API我们无法直接调用，所以只能通过反射。下面是它的声明，通过注释我们可以看出，传递的路径可以是zip文件也可以是一个资源目录，而apk就是一个zip，所以直接将apk的路径传给它，资源就加载到AssetManager中了。然后再通过AssetManager来创建一个新的Resources对象，通过这个对象我们就可以访问插件apk中的资源了，这样一来问题就解决了。\n\n```java\n/**\n\n * Add an additional set of assets to the asset manager.  This can be\n\n * either a directory or ZIP file.  Not for use by applications.  Returns\n\n * the cookie of the added asset, or 0 on failure.\n\n * {@hide}\n\n */\n\npublic final int addAssetPath(String path) {\n\n    synchronized (this) {\n\n        int res = addAssetPathNative(path);\n\n        makeStringBlocks(mStringBlocks);\n\n        return res;\n\n    }\n\n}\n```\n\n接着在代理Activity中实现getAssets()和getResources()，如下所示。关于代理Activity的含义请参看DL开源插件化框架的实现细节，这里不再详细描述了。\n\n```java\n@Override\n\npublic AssetManager getAssets() {\n\n    return mAssetManager == null ? super.getAssets() : mAssetManager;\n\n}\n\n@Override\n\npublic Resources getResources() {\n\n    return mResources == null ? super.getResources() : mResources;\n\n}\n```\n\n通过上述这两个步骤，就可以通过R来访问插件中的资源了。\n\n## 2．Activity生命周期的管理\n\n管理Activity生命周期的方式各种各样，这里只介绍两种：反射方式和接口方式。反射的方式很好理解，首先通过Java的反射去获取Activity的各种生命周期方法，比如onCreate、onStart、onResume等，然后在代理Activity中去调用插件Activity对应的生命周期方法即可，如下所示。\n\n```java\n@Override\n\nprotected void onResume() {\n\n    super.onResume();\n\n    Method onResume = mActivityLifecircleMethods.get(\"onResume\");\n\n    if (onResume != null) {\n\n        try {\n\n            onResume.invoke(mRemoteActivity, new Object[] { });\n\n        } catch (Exception e) {\n\n            e.printStackTrace();\n\n        }\n\n    }\n\n}\n\n@Override\n\nprotected void onPause() {\n\n    Method onPause = mActivityLifecircleMethods.get(\"onPause\");\n\n    if (onPause != null) {\n\n        try {\n\n            onPause.invoke(mRemoteActivity, new Object[] { });\n\n        } catch (Exception e) {\n\n            e.printStackTrace();\n\n        }\n\n    }\n\n    super.onPause();\n\n}\n```\n\n使用反射来管理插件Activity的生命周期是有缺点的，一方面是反射代码写起来比较复杂，另一方面是过多使用反射会有一定的性能开销。下面介绍接口方式，接口方式很好地解决了反射方式的不足之处，这种方式将Activity的生命周期方法提取出来作为一个接口（比如叫DLPlugin），然后通过代理Activity去调用插件Activity的生命周期方法，这样就完成了插件Activity的生命周期管理，并且没有采用反射，这就解决了性能问题。同时接口的声明也比较简单，下面是DLPlugin的声明：\n\n```java\npublic interface DLPlugin {\n\n    public void onStart();\n\n    public void onRestart();\n\n    public void onActivityResult(int requestCode, int resultCode, Intent\n\n    data);\n\n    public void onResume();\n\n    public void onPause();\n\n    public void onStop();\n\n    public void onDestroy();\n\n    public void onCreate(Bundle savedInstanceState);\n\n    public void setProxy(Activity proxyActivity, String dexPath);\n\n    public void onSaveInstanceState(Bundle outState);\n\n    public void onNewIntent(Intent intent);\n\n    public void onRestoreInstanceState(Bundle savedInstanceState);\n\n    public boolean onTouchEvent(MotionEvent event);\n\n    public boolean onKeyUp(int keyCode, KeyEvent event);\n\n    public void onWindowAttributesChanged(LayoutParams params);\n\n    public void onWindowFocusChanged(boolean hasFocus);\n\npublic void onBackPressed();\n\n…\n\n}\n```\n\n在代理Activity中只需要按如下方式即可调用插件Activity的生命周期方法，这就完成了插件Activity的生命周期的管理。\n\n```java\n...\n\n@Override\n\nprotected void onStart() {\n\n    mRemoteActivity.onStart();\n\n    super.onStart();\n\n}\n\n@Override\n\nprotected void onRestart() {\n\n    mRemoteActivity.onRestart();\n\n    super.onRestart();\n\n}\n\n@Override\n\nprotected void onResume() {\n\n    mRemoteActivity.onResume();\n\n    super.onResume();\n\n}\n\n...\n```\n\n通过上述代码应该不难理解接口方式对插件Activity生命周期的管理思想，其中mRemoteActivity就是DLPlugin的实现。\n\n## 3．插件ClassLoader的管理\n\n为了更好地对多插件进行支持，需要合理地去管理各个插件的DexClassLoader，这样同一个插件就可以采用同一个ClassLoader去加载类，从而避免了多个ClassLoader加载同一个类时所引发的类型转换错误。在下面的代码中，通过将不同插件的ClassLoader存储在一个HashMap中，这样就可以保证不同插件中的类彼此互不干扰。\n\n```java\npublic class DLClassLoader extends DexClassLoader {\n\n    private static final String TAG = \"DLClassLoader\";\n\n    private static final HashMap<String, DLClassLoader> mPluginClassLoaders\n\n    = new HashMap<String, DLClassLoader>();\n\n    protected DLClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) {\n\n        super(dexPath, optimizedDirectory, libraryPath, parent);\n\n    }\n\n    /**\n\n     * return a available classloader which belongs to different apk\n\n     */\n\n    public static DLClassLoader getClassLoader(String dexPath, Context\n\n    context, ClassLoader parentLoader) {\n\n        DLClassLoader dLClassLoader = mPluginClassLoaders.get(dexPath);\n\n        if (dLClassLoader != null)\n\n            return dLClassLoader;\n\n        File dexOutputDir = context.getDir(\"dex\", Context.MODE_PRIVATE);\n\n        final String dexOutputPath = dexOutputDir.getAbsolutePath();\n\n        dLClassLoader = new DLClassLoader(dexPath, dexOutputPath, null,\n\n        parentLoader);\n\n        mPluginClassLoaders.put(dexPath, dLClassLoader);\n\n        return dLClassLoader;\n\n    }\n\n}\n```\n\n事实上插件化的技术细节非常多，这绝非一个章节的内容所能描述清楚的，另外插件化作为一种核心技术，需要开发者有较深的开发功底才能够很好地理解，因此本节的内容更多是让读者对插件化开发有一个感性的了解，细节上还需要读者自己去钻研，也可以通过DL插件化框架去深入地学习。",[[1520508268941,["gengmei_pxf@gengmei123.local",[[1,7022,"\n\n"]],[7022,7022],[7023,7023]]],[1520508269245,["gengmei_pxf@gengmei123.local",[[1,7024,"\n"]],[7023,7023],[7024,7024]]],[1520508279847,["gengmei_pxf@gengmei123.local",[[-1,7024,"\n"],[1,7025,"## 参考"]],[7024,7024],[7029,7029]]],[1520508281764,["gengmei_pxf@gengmei123.local",[[1,7029,"\n\n"]],[7029,7029],[7030,7030]]],[1520508284751,["gengmei_pxf@gengmei123.local",[[-1,7030,"\n"],[1,7031,"[]()"]],[7030,7030],[7034,7034]]],[1520508296119,["gengmei_pxf@gengmei123.local",[[1,7033,"http://www.infoq.com/cn/articles/android-dynamic-loading"]],[7033,7033],[7089,7089]]],[1520508309086,["gengmei_pxf@gengmei123.local",[[1,7031,"# Android动态加载技术三个关键问题详解"]],[7031,7031],[7054,7054]]],[1520508311652,["gengmei_pxf@gengmei123.local",[[-1,7031,"# "]],[7033,7033],[7031,7031]]]]],["3c7f723b-0868-486d-bd1e-03abefbe730a",1521435101117,"Android动态加载\n==\n\n## 什么是动态加载\n\n动态加载技术（也叫插件化技术）在技术驱动型的公司中扮演着相当重要的角色，当项目越来越庞大的时候，需要通过插件化来减轻应用的内存和CPU占用，还可以实现热插拔，即在不发布新版本的情况下更新某些模块。动态加载是一项很复杂的技术，这里主要介绍动态加载技术中的三个基础性问题，至于完整的动态加载技术的实现请参考笔者发起的[开源插件化框架DL](https://github.com/singwhatiwanna/dynamic-load-apk)：。项目期间有多位开发人员一起贡献代码。\n\n不同的插件化方案各有各的特色，但是它们都必须要解决三个基础性问题：资源访问、Activity生命周期的管理和ClassLoader的管理。在介绍它们之前，首先要明白宿主和插件的概念，宿主是指普通的apk，而插件一般是指经过处理的dex或者apk，在主流的插件化框架中多采用经过特殊处理的apk来作为插件，处理方式往往和编译以及打包环节有关，另外很多插件化框架都需要用到代理Activity的概念，插件Activity的启动大多数是借助一个代理Activity来实现的。\n\n## 1．资源访问\n\n我们知道，宿主程序调起未安装的插件apk，一个很大的问题就是资源如何访问，具体来说就是插件中凡是以R开头的资源都不能访问了。这是因为宿主程序中并没有插件的资源，所以通过R来加载插件的资源是行不通的，程序会抛出异常：无法找到某某id所对应的资源。\n\n针对这个问题，有人提出了将插件中的资源在宿主程序中也预置一份，这虽然能解决问题，但是这样就会产生一些弊端。首先，这样就需要宿主和插件同时持有一份相同的资源，增加了宿主apk的大小；其次，在这种模式下，每次发布一个插件都需要将资源复制到宿主程序中，这意味着每发布一个插件都要更新一下宿主程序，这就和插件化的思想相违背了。\n\n因为插件化的目的就是要减小宿主程序apk包的大小，同时降低宿主程序的更新频率并做到自由装载模块，所以这种方法不可取，它限制了插件的线上更新这一重要特性。还有人提供了另一种方式，首先将插件中的资源解压出来，然后通过文件流去读取资源，这样做理论上是可行的，但是实际操作起来还是有很大难度的。首先不同资源有不同的文件流格式，比如图片、XML等，其次针对不同设备加载的资源可能是不一样的，如何选择合适的资源也是一个需要解决的问题，基于这两点，这种方法也不建议使用，因为它实现起来有较大难度。为了方便地对插件进行资源管理，下面给出一种合理的方式。\n\n我们知道，Activity的工作主要是通过ContextImpl来完成的， Activity中有一个叫mBase的成员变量，它的类型就是ContextImpl。注意到Context中有如下两个抽象方法，看起来是和资源有关的，实际上Context就是通过它们来获取资源的。这两个抽象方法的真正实现在ContextImpl中，也就是说，只要实现这两个方法，就可以解决资源问题了。\n\n```java\n/** Return an AssetManager instance for your application's package. */\n\npublic abstract AssetManager getAssets();\n\n/** Return a Resources instance for your application's package. */\n\npublic abstract Resources getResources();\n```\n\n下面给出具体的实现方式，首先要加载apk中的资源，如下所示。\n\n```java\nprotected void loadResources() {\n\ttry {\n\t\tAssetManager assetManager = AssetManager.class.newInstance();\n\t\tMethod addAssetPath = assetManager.getClass().getMethod(\"addAssetPath\", String.class);\n\t\taddAssetPath.invoke(assetManager, mDexPath);\n\t\tmAssetManager = assetManager;\n\t} catch (Exception e) {\n\t\te.printStackTrace();\n\t}\n\tResources superRes = super.getResources();\n\tmResources = new Resources(mAssetManager, superRes.getDisplayMetrics(),\n\t\t\tsuperRes.getConfiguration());\n\tmTheme = mResources.newTheme();\n\tmTheme.setTo(super.getTheme());\n}\n\n```\n\n从loadResources()的实现可以看出，加载资源的方法是通过反射，通过调用AssetManager中的addAssetPath方法，我们可以将一个apk中的资源加载到Resources对象中，由于addAssetPath是隐藏API我们无法直接调用，所以只能通过反射。下面是它的声明，通过注释我们可以看出，传递的路径可以是zip文件也可以是一个资源目录，而apk就是一个zip，所以直接将apk的路径传给它，资源就加载到AssetManager中了。然后再通过AssetManager来创建一个新的Resources对象，通过这个对象我们就可以访问插件apk中的资源了，这样一来问题就解决了。\n\n```java\n/**\n\n * Add an additional set of assets to the asset manager.  This can be\n\n * either a directory or ZIP file.  Not for use by applications.  Returns\n\n * the cookie of the added asset, or 0 on failure.\n\n * {@hide}\n\n */\n\npublic final int addAssetPath(String path) {\n\n    synchronized (this) {\n\n        int res = addAssetPathNative(path);\n\n        makeStringBlocks(mStringBlocks);\n\n        return res;\n\n    }\n\n}\n```\n\n接着在代理Activity中实现getAssets()和getResources()，如下所示。关于代理Activity的含义请参看DL开源插件化框架的实现细节，这里不再详细描述了。\n\n```java\n@Override\n\npublic AssetManager getAssets() {\n\n    return mAssetManager == null ? super.getAssets() : mAssetManager;\n\n}\n\n@Override\n\npublic Resources getResources() {\n\n    return mResources == null ? super.getResources() : mResources;\n\n}\n```\n\n通过上述这两个步骤，就可以通过R来访问插件中的资源了。\n\n## 2．Activity生命周期的管理\n\n管理Activity生命周期的方式各种各样，这里只介绍两种：反射方式和接口方式。反射的方式很好理解，首先通过Java的反射去获取Activity的各种生命周期方法，比如onCreate、onStart、onResume等，然后在代理Activity中去调用插件Activity对应的生命周期方法即可，如下所示。\n\n```java\n@Override\n\nprotected void onResume() {\n\n    super.onResume();\n\n    Method onResume = mActivityLifecircleMethods.get(\"onResume\");\n\n    if (onResume != null) {\n\n        try {\n\n            onResume.invoke(mRemoteActivity, new Object[] { });\n\n        } catch (Exception e) {\n\n            e.printStackTrace();\n\n        }\n\n    }\n\n}\n\n@Override\n\nprotected void onPause() {\n\n    Method onPause = mActivityLifecircleMethods.get(\"onPause\");\n\n    if (onPause != null) {\n\n        try {\n\n            onPause.invoke(mRemoteActivity, new Object[] { });\n\n        } catch (Exception e) {\n\n            e.printStackTrace();\n\n        }\n\n    }\n\n    super.onPause();\n\n}\n```\n\n使用反射来管理插件Activity的生命周期是有缺点的，一方面是反射代码写起来比较复杂，另一方面是过多使用反射会有一定的性能开销。下面介绍接口方式，接口方式很好地解决了反射方式的不足之处，这种方式将Activity的生命周期方法提取出来作为一个接口（比如叫DLPlugin），然后通过代理Activity去调用插件Activity的生命周期方法，这样就完成了插件Activity的生命周期管理，并且没有采用反射，这就解决了性能问题。同时接口的声明也比较简单，下面是DLPlugin的声明：\n\n```java\npublic interface DLPlugin {\n\n    public void onStart();\n\n    public void onRestart();\n\n    public void onActivityResult(int requestCode, int resultCode, Intent\n\n    data);\n\n    public void onResume();\n\n    public void onPause();\n\n    public void onStop();\n\n    public void onDestroy();\n\n    public void onCreate(Bundle savedInstanceState);\n\n    public void setProxy(Activity proxyActivity, String dexPath);\n\n    public void onSaveInstanceState(Bundle outState);\n\n    public void onNewIntent(Intent intent);\n\n    public void onRestoreInstanceState(Bundle savedInstanceState);\n\n    public boolean onTouchEvent(MotionEvent event);\n\n    public boolean onKeyUp(int keyCode, KeyEvent event);\n\n    public void onWindowAttributesChanged(LayoutParams params);\n\n    public void onWindowFocusChanged(boolean hasFocus);\n\npublic void onBackPressed();\n\n…\n\n}\n```\n\n在代理Activity中只需要按如下方式即可调用插件Activity的生命周期方法，这就完成了插件Activity的生命周期的管理。\n\n```java\n...\n\n@Override\n\nprotected void onStart() {\n\n    mRemoteActivity.onStart();\n\n    super.onStart();\n\n}\n\n@Override\n\nprotected void onRestart() {\n\n    mRemoteActivity.onRestart();\n\n    super.onRestart();\n\n}\n\n@Override\n\nprotected void onResume() {\n\n    mRemoteActivity.onResume();\n\n    super.onResume();\n\n}\n\n...\n```\n\n通过上述代码应该不难理解接口方式对插件Activity生命周期的管理思想，其中mRemoteActivity就是DLPlugin的实现。\n\n## 3．插件ClassLoader的管理\n\n为了更好地对多插件进行支持，需要合理地去管理各个插件的DexClassLoader，这样同一个插件就可以采用同一个ClassLoader去加载类，从而避免了多个ClassLoader加载同一个类时所引发的类型转换错误。在下面的代码中，通过将不同插件的ClassLoader存储在一个HashMap中，这样就可以保证不同插件中的类彼此互不干扰。\n\n```java\npublic class DLClassLoader extends DexClassLoader {\n\n    private static final String TAG = \"DLClassLoader\";\n\n    private static final HashMap<String, DLClassLoader> mPluginClassLoaders\n\n    = new HashMap<String, DLClassLoader>();\n\n    protected DLClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) {\n\n        super(dexPath, optimizedDirectory, libraryPath, parent);\n\n    }\n\n    /**\n\n     * return a available classloader which belongs to different apk\n\n     */\n\n    public static DLClassLoader getClassLoader(String dexPath, Context\n\n    context, ClassLoader parentLoader) {\n\n        DLClassLoader dLClassLoader = mPluginClassLoaders.get(dexPath);\n\n        if (dLClassLoader != null)\n\n            return dLClassLoader;\n\n        File dexOutputDir = context.getDir(\"dex\", Context.MODE_PRIVATE);\n\n        final String dexOutputPath = dexOutputDir.getAbsolutePath();\n\n        dLClassLoader = new DLClassLoader(dexPath, dexOutputPath, null,\n\n        parentLoader);\n\n        mPluginClassLoaders.put(dexPath, dLClassLoader);\n\n        return dLClassLoader;\n\n    }\n\n}\n```\n\n事实上插件化的技术细节非常多，这绝非一个章节的内容所能描述清楚的，另外插件化作为一种核心技术，需要开发者有较深的开发功底才能够很好地理解，因此本节的内容更多是让读者对插件化开发有一个感性的了解，细节上还需要读者自己去钻研，也可以通过DL插件化框架去深入地学习。\n\n## 参考\n[Android动态加载技术三个关键问题详解](http://www.infoq.com/cn/articles/android-dynamic-loading)",[[1521435097947,["gengmei_pxf@gengmei123.local",[[1,7111,"\n\n[Android apk动态加载机制的研究（二）：资源加载和activity生命周期管理](http://blog.csdn.net/singwhatiwanna/article/details/23387079)"]],[7111,7111],[7219,7219]]]]]]}