{"compress":true,"commitItems":[["9adc674d-2003-4334-9256-775d61128596",1520057603484,"",[[1520057586232,["gengmei_pxf@gengmei123.lan",[[1,0,"JVM\n===\n\n\n## 一. 类的加载过程，Person person = new Person();为例进行说明。\n\n1).因为new用到了Person.class，所以会先找到Person.class文件，并加载到内存中;\n\n2).执行该类中的static代码块，如果有的话，给Person.class类进行初始化;\n\n3).在堆内存中开辟空间分配内存地址;\n\n4).在堆内存中建立对象的特有属性，并进行默认初始化;\n\n5).对属性进行显示初始化;\n\n6).对对象进行构造代码块初始化;\n\n7).对对象进行与之对应的构造函数进行初始化;\n\n8).将内存地址付给栈内存中的p变量\n\n## 二. JVM相关知识，GC机制。\n\n**JVM基本构成**\n\n![](http://upload-images.jianshu.io/upload_images/4642697-bbcb5924cdaf30f8.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/473)\n\n从上图可知，JVM主要包括四个部分：\n\n    1.类加载器（ClassLoader）:在JVM启动时或者在类运行时将需要的class加载到JVM中。（下图表示了从java源文件到JVM的整个过程，可配合理解。 \n\n![](http://upload-images.jianshu.io/upload_images/4642697-1cf5f815751beeab.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/400)\n\n    2.执行引擎：负责执行class文件中包含的字节码指令；\n\n    3.内存区（也叫运行时数据区）：是在JVM运行的时候操作所分配的内存区。运行时内存区主要可以划分为5个区域，如图：\n\n![](http://upload-images.jianshu.io/upload_images/4642697-160b9ba3bfeaf8f5.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/376)\n\n*   方法区(Method Area)：用于存储类结构信息的地方，包括常量池、静态变量、构造函数等。虽然JVM规范把方法区描述为堆的一个逻辑部分， 但它却有个别名non-heap（非堆），所以大家不要搞混淆了。方法区还包含一个运行时常量池。\n\n*   java堆(Heap)：存储java实例或者对象的地方。这块是GC的主要区域。从存储的内容我们可以很容易知道，方法区和堆是被所有java线程共享的。\n\n*   java栈(Stack)：java栈总是和线程关联在一起，每当创建一个线程时，JVM就会为这个线程创建一个对应的java栈。在这个java栈中又会包含多个栈帧，每运行一个方法就创建一个栈帧，用于存储局部变量表、操作栈、方法返回值等。每一个方法从调用直至执行完成的过程，就对应一个栈帧在java栈中入栈到出栈的过程。所以java栈是现成私有的。\n\n*   程序计数器(PC Register)：用于保存当前线程执行的内存地址。由于JVM程序是多线程执行的（线程轮流切换），所以为了保证线程切换回来后，还能恢复到原先状态，就需要一个独立的计数器，记录之前中断的地方，可见程序计数器也是线程私有的。\n\n*   本地方法栈(Native Method Stack)：和java栈的作用差不多，只不过是为JVM使用到的native方法服务的。\n\n        4.本地方法接口：主要是调用C或C++实现的本地方法及返回结果。\n\n**GC机制**\n\n    垃圾收集器一般必须完成两件事：检测出垃圾；回收垃圾。怎么检测出垃圾？一般有以下几种方法：\n\n**_引用计数法：_**\n\n    给一个对象添加引用计数器，每当有个地方引用它，计数器就加1；引用失效就减1。好了，问题来了，如果我有两个对象A和B，互相引用，除此之外，没有其他任何对象引用它们，实际上这两个对象已经无法访问，即是我们说的垃圾对象。但是互相引用，计数不为0，导致无法回收，所以还有另一种方法：\n\n**_可达性分析算法：_**\n\n    以根集对象为起始点进行搜索，如果有对象不可达的话，即是垃圾对象。这里的根集一般包括java栈中引用的对象、方法区常良池中引用的对象、本地方法中引用的对象等。\n\n    总之，JVM在做垃圾回收的时候，会检查堆中的所有对象是否会被这些根集对象引用，不能够被引用的对象就会被垃圾收集器回收。一般回收算法也有如下几种：\n\n1).标记-清除（Mark-sweep）\n\n2).复制（Copying\n\n3).标记-整理（Mark-Compact）\n\n4).分代收集算法\n\n具体的解释可以参考本篇文章[还不点我?](https://link.jianshu.com?t=http://blog.csdn.net/tonytfjing/article/details/44278233)\n\n## 三. 类的加载器，双亲机制，Android的类加载器。\n\n**类的加载器**\n\n    大家都知道，当我们写好一个Java程序之后，不是管是CS还是BS应用，都是由若干个.class文件组织而成的一个完整的Java应用程序，当程序在运行时，即会调用该程序的一个入口函数来调用系统的相关功能，而这些功能都被封装在不同的class文件当中，所以经常要从这个class文件中要调用另外一个class文件中的方法，如果另外一个文件不存在的，则会引发系统异常。而程序在启动的时候，并不会一次性加载程序所要用的所有class文件，而是根据程序的需要，通过Java的类加载机制（ClassLoader）来动态加载某个class文件到内存当中的，从而只有class文件被载入到了内存之后，才能被其它class所引用。所以ClassLoader就是用来动态加载class文件到内存当中用的。\n\n**双亲机制**\n\n**_1、原理介绍_**\n\n    ClassLoader使用的是双亲委托模型来搜索类的，每个ClassLoader实例都有一个父类加载器的引用（不是继承的关系，是一个包含的关系），虚拟机内置的类加载器（Bootstrap ClassLoader）本身没有父类加载器，但可以用作其它ClassLoader实例的的父类加载器。当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。\n\n**_2、为什么要使用双亲委托这种模型呢？_**\n\n    因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法。\n\n**_3、但是JVM在搜索类的时候，又是如何判定两个class是相同的呢？_**\n\n    JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。比如网络上的一个Java类org.classloader.simple.NetClassLoaderSimple，javac编译之后生成字节码文件NetClassLoaderSimple.class，ClassLoaderA和ClassLoaderB这两个类加载器并读取了NetClassLoaderSimple.class文件，并分别定义出了java.lang.Class实例来表示这个类，对于JVM来说，它们是两个不同的实例对象，但它们确实是同一份字节码文件，如果试图将这个Class实例生成具体的对象进行转换时，就会抛运行时异常java.lang.ClassCaseException，提示这是两个不同的类型。\n\n**Android类加载器**\n\n    对于Android而言，最终的apk文件包含的是dex类型的文件，dex文件是将class文件重新打包，打包的规则又不是简单地压缩，而是完全对class文件内部的各种函数表，变量表进行优化，产生一个新的文件，即dex文件。因此加载这种特殊的Class文件就需要特殊的类加载器DexClassLoader。"]],[0,0],[3987,3987]]],[1520063040829,["gengmei_pxf@gengmei123.lan",[[-1,1503,"        "]],[1511,1511],[1503,1503]]],[1520063051797,["gengmei_pxf@gengmei123.lan",[[1,1503,"    "]],[1503,1503],[1507,1507]]],[1520063056014,["gengmei_pxf@gengmei123.lan",[[-1,1506," "]],[1507,1507],[1506,1506]]],[1520063083485,["gengmei_pxf@gengmei123.lan",[[1,314,"### "]],[314,314],[318,318]]],[1520063095493,["gengmei_pxf@gengmei123.lan",[[1,487,"#### "]],[487,487],[492,492]]],[1520063101818,["gengmei_pxf@gengmei123.lan",[[-1,483,"    "]],[487,487],[483,483]]],[1520063109458,["gengmei_pxf@gengmei123.lan",[[-1,704,"    "]],[708,708],[704,704]]],[1520063112132,["gengmei_pxf@gengmei123.lan",[[1,704,"#### "]],[704,704],[709,709]]],[1520063134401,["gengmei_pxf@gengmei123.lan",[[-1,739,"    "]],[743,743],[739,739]]],[1520063135849,["gengmei_pxf@gengmei123.lan",[[-1,738,"\n"]],[739,739],[738,738]]],[1520063137609,["gengmei_pxf@gengmei123.lan",[[1,738,"\n"]],[738,738],[739,739]]],[1520063139826,["gengmei_pxf@gengmei123.lan",[[1,739,"#### "]],[739,739],[744,744]]],[1520063155151,["gengmei_pxf@gengmei123.lan",[[1,939,"**"]],[939,939],[941,941]]],[1520063158491,["gengmei_pxf@gengmei123.lan",[[1,957,"**"]],[957,957],[959,959]]],[1520063162514,["gengmei_pxf@gengmei123.lan",[[1,1066,"**"]],[1066,1066],[1068,1068]]],[1520063165354,["gengmei_pxf@gengmei123.lan",[[1,1079,"**"]],[1079,1079],[1081,1081]]],[1520063170993,["gengmei_pxf@gengmei123.lan",[[1,1150,"**"]],[1150,1150],[1152,1152]]],[1520063173866,["gengmei_pxf@gengmei123.lan",[[1,1164,"**"]],[1164,1164],[1166,1166]]],[1520063177890,["gengmei_pxf@gengmei123.lan",[[1,1331,"**"]],[1331,1331],[1333,1333]]],[1520063180265,["gengmei_pxf@gengmei123.lan",[[1,1351,"**"]],[1351,1351],[1353,1353]]],[1520063183727,["gengmei_pxf@gengmei123.lan",[[1,1460,"**"]],[1460,1460],[1462,1462]]],[1520063186625,["gengmei_pxf@gengmei123.lan",[[1,1488,"**"]],[1488,1488],[1490,1490]]],[1520063191919,["gengmei_pxf@gengmei123.lan",[[-1,1530,"   "]],[1533,1533],[1530,1530]]],[1520063194288,["gengmei_pxf@gengmei123.lan",[[1,1530,"#### "]],[1530,1530],[1535,1535]]],[1520063208191,["gengmei_pxf@gengmei123.lan",[[1,1569,"### "]],[1569,1569],[1573,1573]]],[1520063227263,["gengmei_pxf@gengmei123.lan",[[1,1633,"#### "]],[1633,1633],[1638,1638]]],[1520063327667,["gengmei_pxf@gengmei123.lan",[[1,1795,"#### "]],[1795,1795],[1800,1800]]],[1520063535770,["gengmei_pxf@gengmei123.lan",[[1,2189,"####  "]],[2189,2189],[2195,2195]]],[1520063537150,["gengmei_pxf@gengmei123.lan",[[-1,2194," "]],[2195,2195],[2194,2194]]],[1520063538911,["gengmei_pxf@gengmei123.lan",[[-1,2192,"#"]],[2193,2193],[2192,2192]]],[1520063545338,["gengmei_pxf@gengmei123.lan",[[1,2552,"#### "]],[2552,2552],[2557,2557]]],[1520063546952,["gengmei_pxf@gengmei123.lan",[[-1,2555,"#"]],[2555,2555],[2554,2554]]],[1520063549898,["gengmei_pxf@gengmei123.lan",[[1,3860,"#### "]],[3860,3860],[3865,3865]]],[1520063552120,["gengmei_pxf@gengmei123.lan",[[-1,3863,"#"]],[3864,3864],[3863,3863]]],[1520064765157,["gengmei_pxf@gengmei123.lan",[[1,3,"相关"]],[3,3],[5,5]]]]]]}