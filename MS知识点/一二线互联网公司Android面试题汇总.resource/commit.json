{"compress":true,"commitItems":[["cc7a30d5-512f-41bf-a0ef-d4c62f2353ef",1519971263768,"",[[1519971236963,["gengmei_pxf@gengmei123.local",[[1,0,"一二线互联网公司Android面试题汇总\n===\n\n\n## **阿里巴巴**\n\n*   LRUCache原理\n\n*   图片加载原理\n\n*   模块化实现（好处，原因）\n\n*   JVM\n\n*   视频加密传输\n\n*   统计启动时长,标准\n\n*   如何保持应用的稳定性\n\n*   ThreadLocal 原理\n\n*   谈谈classloader\n\n*   动态布局\n\n*   热修复,插件化\n\n*   HashMap源码,SpareArray原理\n\n*   性能优化,怎么保证应用启动不卡顿\n\n*   怎么去除重复代码\n\n*   SP是进程同步的吗?有什么方法做到同步\n\n*   介绍下SurfView\n\n*   HashMap实现原理，ConcurrentHashMap 的实现原理\n\n*   BroadcastReceiver，LocalBroadcastReceiver 区别\n\n*   Bundle 机制\n\n*   Handler 机制\n\n*   android 事件传递机制\n\n*   线程间 操作 List\n\n*   App启动流程，从点击桌面开始\n\n*   动态加载\n\n*   类加载器\n\n*   OSGI\n\n*   Https请求慢的解决办法，DNS，携带数据，直接访问IP\n\n*   GC回收策略\n\n*   画出 Android 的大体架构图\n\n*   描述清点击 Android Studio 的 build 按钮后发生了什么\n\n*   大体说清一个应用程序安装到手机上时发生了什么；\n\n*   对 Dalvik、ART 虚拟机有基本的了解；\n\n*   Android 上的 Inter-Process-Communication 跨进程通信时如何工作的；\n\n*   App 是如何沙箱化，为什么要这么做；\n\n*   权限管理系统（底层的权限是如何进行 grant 的）\n\n*   进程和 Application 的生命周期；\n\n*   系统启动流程 Zygote进程 –> SystemServer进程 –> 各种系统服务 –> 应用进程\n\n*   recycleview listview 的区别,性能\n\n*   排序，快速排序的实现\n\n*   树：B+树的介绍\n\n*   图：有向无环图的解释\n\n*   TCP/UDP的区别\n\n*   synchronized与Lock的区别\n\n*   volatile\n\n*   Java线程池\n\n*   Java中对象的生命周期\n\n*   类加载机制\n\n*   双亲委派模型\n\n*   Android事件分发机制\n\n*   MVP模式\n\n*   RxJava\n\n*   抽象类和接口的区别\n\n*   集合 Set实现 Hash 怎么防止碰撞\n\n*   JVM 内存区域 开线程影响哪块内存\n\n*   垃圾收集机制 对象创建，新生代与老年代\n\n*   二叉树 深度遍历与广度遍历\n\n*   B树、B+树\n\n*   消息机制\n\n*   进程调度\n\n*   进程与线程\n\n*   死锁\n\n*   进程状态\n\n*   JVM内存模型\n\n*   并发集合了解哪些\n\n*   ConCurrentHashMap实现\n\n*   CAS介绍\n\n*   开启线程的三种方式,run()和start()方法区别\n\n*   线程池\n\n*   常用数据结构简介\n\n*   判断环（猜测应该是链表环）\n\n*   排序，堆排序实现\n\n*   链表反转\n\n## **腾讯**\n\n*   synchronized用法\n\n*   volatile用法\n\n*   动态权限适配方案，权限组的概念\n\n*   网络请求缓存处理，okhttp如何处理网络缓存的\n\n*   图片加载库相关，bitmap如何处理大图，如一张30M的大图，如何预防OOM\n\n*   进程保活\n\n*   listview图片加载错乱的原理和解决方案\n\n*   https相关，如何验证证书的合法性，https中哪里用了对称加密，哪里用了非对称加密，对加密算法（如RSA）等是否有了解\n\n## **滴滴**\n\n*   MVP\n\n*   广播（动态注册和静态注册区别，有序广播和标准广播）\n\n*   service生命周期\n\n*   handler实现机制（很多细节需要关注：如线程如何建立和退出消息循环等等）\n\n*   多线程（关于AsyncTask缺陷引发的思考）\n\n*   数据库数据迁移问题\n\n*   设计模式相关（例如Android中哪里使用了观察者模式，单例模式相关）\n\n*   x个苹果，一天只能吃一个、两个、或者三个，问多少天可以吃完\n\n*   TCP与UDP区别与应用（三次握手和四次挥手）涉及到部分细节（如client如何确定自己发送的消息被server收到） HTTP相关 提到过Websocket 问了WebSocket相关以及与socket的区别\n\n*   是否熟悉Android jni开发，jni如何调用java层代码\n\n*   进程间通信的方式\n\n*   java注解\n\n*   计算一个view的嵌套层级\n\n*   项目组件化的理解\n\n*   多线程断点续传原理\n\n*   Android系统为什么会设计ContentProvider，进程共享和线程安全问题\n\n*   jvm相关\n\n*   Android相关优化（如内存优化、网络优化、布局优化、电量优化、业务优化）\n\n*   EventBus实现原理\n\n## **美团**\n\n*   static synchronized 方法的多线程访问和作用，同一个类里面两个synchronized方法，两个线程同时访问的问题\n\n*   内部类和静态内部类和匿名内部类，以及项目中的应用\n\n*   handler发消息给子线程，looper怎么启动\n\n*   View事件传递\n\n*   activity栈\n\n*   封装view的时候怎么知道view的大小\n\n*   arraylist和linkedlist的区别，以及应用场景\n\n*   怎么启动service，service和activity怎么进行数据交互\n\n*   下拉状态栏是不是影响activity的生命周期，如果在onStop的时候做了网络请求，onResume的时候怎么恢复\n\n*   view渲染\n\n## **今日头条**\n\n*   数据结构中堆的概念，堆排序\n\n*   死锁的概念，怎么避免死锁\n\n*   ReentrantLock 、synchronized和volatile（n面）\n\n*   HashMap\n\n*   singleTask启动模式\n\n*   用到的一些开源框架，介绍一个看过源码的，内部实现过程。\n\n*   消息机制实现\n\n*   ReentrantLock的内部实现\n\n*   App启动崩溃异常捕捉\n\n*   事件传递机制的介绍\n\n*   ListView的优化\n\n*   二叉树，给出根节点和目标节点，找出从根节点到目标节点的路径\n\n*   模式MVP，MVC介绍\n\n*   断点续传的实现\n\n*   集合的接口和具体实现类，介绍\n\n*   TreeMap具体实现\n\n*   synchronized与ReentrantLock\n\n*   手写生产者/消费者模式\n\n*   逻辑地址与物理地址，为什么使用逻辑地址\n\n*   一个无序，不重复数组，输出N个元素，使得N个元素的和相加为M，给出时间复杂度、空间复杂度。手写算法\n\n*   .Android进程分类\n\n*   前台切换到后台，然后再回到前台，Activity生命周期回调方法。弹出Dialog，生命值周期回调方法。\n\n*   Activity的启动模式\n\n## **爱奇艺**\n\n*   RxJava的功能与原理实现\n\n*   RecycleView的使用，原理，RecycleView优化\n\n*   ANR的原因\n\n*   四大组件\n\n*   Service的开启方式\n\n*   Activity与Service通信的方式\n\n*   Activity之间的通信方式\n\n*   HashMap的实现，与HashSet的区别\n\n*   JVM内存模型，内存区域\n\n*   Java中同步使用的关键字，死锁\n\n*   MVP模式\n\n*   Java设计模式，观察者模式\n\n*   Activity与Fragment之间生命周期比较\n\n*   广播的使用场景\n\n** 百度**\n\n* * *\n\n*   Bitmap 使用时候注意什么？\n\n*   Oom 是否可以try catch ？\n\n*   内存泄露如何产生？\n\n*   适配器模式，装饰者模式，外观模式的异同？\n\n*   ANR 如何产生？\n\n*   String buffer 与string builder 的区别？\n\n*   如何保证线程安全？\n\n*   java四中引用\n\n*   Jni 用过么？\n\n*   多进程场景遇见过么？\n\n*   关于handler，在任何地方new handler 都是什么线程下\n\n*   sqlite升级，增加字段的语句\n\n*   bitmap recycler 相关\n\n*   强引用置为null，会不会被回收？\n\n*   glide 使用什么缓存？\n\n*   Glide 内存缓存如何控制大小？\n\n*   如何保证多线程读写文件的安全？\n\n## **携程**\n\n*   Activity启动模式\n\n*   广播的使用方式，场景\n\n*   App中唤醒其他进程的实现方式\n\n*   AndroidManifest的作用与理解\n\n*   List,Set,Map的区别\n\n*   HashSet与HashMap怎么判断集合元素重复\n\n*   Java中内存区域与垃圾回收机制\n\n*   EventBus作用，实现方式，代替EventBus的方式\n\n*   Android中开启摄像头的主要步骤\n\n## **网易**\n\n*   集合\n\n*   concurrenthashmap\n\n*   volatile\n\n*   synchronized与Lock\n\n*   Java线程池\n\n*   wait/notify\n\n*   NIO\n\n*   垃圾收集器\n\n*   Activity生命周期\n\n*   AlertDialog,popupWindow,Activity区别\n\n## **小米**\n\n*   String 为什么要设计成不可变的？\n\n*   fragment 各种情况下的生命周期\n\n*   Activity 上有 Dialog 的时候按 home 键时的生命周期\n\n*   横竖屏切换的时候，Activity 各种情况下的生命周期\n\n*   Application 和 Activity 的 context 对象的区别\n\n*   序列化的作用，以及 Android 两种序列化的区别。\n\n*   List 和 Map 的实现方式以及存储方式。\n\n*   静态内部类的设计意图。\n\n*   线程如何关闭，以及如何防止线程的内存泄漏\n\n## **360**\n\n*   软引用、弱引用区别\n\n*   垃圾回收\n\n*   多线程：怎么用、有什么问题要注意；Android线程有没有上限，然后提到线程池的上限\n\n*   JVM\n\n*   锁\n\n*   OOM，内存泄漏\n\n*   ANR怎么分析解决\n\n*   LinearLayout、RelativeLayout、FrameLayout的特性、使用场景\n\n*   如何实现Fragment的滑动\n\n*   ViewPager使用细节，如何设置成每次只初始化当前的Fragment，其他的不初始化\n\n*   ListView重用的是什么\n\n*   进程间通信的机制\n\n*   AIDL机制\n\n*   AsyncTask机制\n\n*   如何取消AsyncTask\n\n*   序列化\n\n*   Android为什么引入Parcelable\n\n*   有没有尝试简化Parcelable的使用\n\n*   AIDL机制\n\n*   项目：拉活怎么做的\n\n*   应用安装过程\n\n## **某海外直播公司**\n\n*   线程和进程的区别？\n\n*   为什么要有线程，而不是仅仅用进程？\n\n*   算法判断单链表成环与否？\n\n*   如何实现线程同步？\n\n*   hashmap数据结构？\n\n*   arraylist 与 linkedlist 异同？\n\n*   object类的equal 和hashcode 方法重写，为什么？\n\n*   hashmap如何put数据（从hashmap源码角度讲解）？\n\n*   简述IPC？\n\n*   fragment之间传递数据的方式？\n\n*   简述tcp四次挥手?\n\n*   threadlocal原理\n\n*   内存泄漏的可能原因？\n\n*   用IDE如何分析内存泄漏？\n\n*   OOM的可能原因？\n\n*   线程死锁的4个条件？\n\n*   差值器&估值器\n\n*   简述消息机制相关\n\n*   进程间通信方式？\n\n*   Binder相关？\n\n*   触摸事件的分发？\n\n*   简述Activity启动全部过程？\n\n*   okhttp源码？\n\n*   RxJava简介及其源码解读？\n\n*   性能优化如何分析systrace？\n\n*   广播的分类？\n\n*   点击事件被拦截，但是相传到下面的view，如何操作？\n\n*   Glide源码？\n\n*   ActicityThread相关？\n\n*   volatile的原理\n\n*   synchronize的原理\n\n*   lock原理\n\n*   翻转一个单项链表\n\n*   string to integer\n\n*   合并多个单有序链表（假设都是递增的）\n\n## **其他公司**\n\n*   四大组件\n\n*   Android中数据存储方式\n\n*   微信主页面的实现方式\n\n*   微信上消息小红点的原理\n\n*   两个不重复的数组集合中，求共同的元素。\n\n*   上一问扩展，海量数据，内存中放不下，怎么求出。\n\n*   Java中String的了解。\n\n*   ArrayList与LinkedList区别\n\n*   堆排序过程，时间复杂度，空间复杂度\n\n*   快速排序的时间复杂度，空间复杂度\n\n*   RxJava的作用，与平时使用的异步操作来比，优势\n\n*   Android消息机制原理\n\n*   Binder机制介绍\n\n*   为什么不能在子线程更新UI\n\n*   JVM内存模型\n\n*   Android中进程内存的分配，能不能自己分配定额内存\n\n*   垃圾回收机制与调用System.gc()区别\n\n*   Android事件分发机制\n\n*   断点续传的实现\n\n*   RxJava的作用，优缺点"]],[0,0],[6149,6149]]],[1519971260048,["gengmei_pxf@gengmei123.local",[[1,40,"#"],[-1,3499," "],[1,3500," ## "]],[40,40],[44,44]]],[1519971290105,[null,[[1,41,"## "],[-1,3500," ##"]],[41,41],[3500,3500]]],[1519971290105,[null,[[-1,41,"## "],[1,3503," ##"]],[3500,3500],[41,41]]],[1519971267686,["gengmei_pxf@gengmei123.local",[[-1,44,"*   "]],[48,48],[44,44]]],[1519971276477,["gengmei_pxf@gengmei123.local",[[1,56,"\n"]],[55,55],[56,56]]],[1519971277965,["gengmei_pxf@gengmei123.local",[[1,57,"\n"]],[56,56],[57,57]]],[1519971283685,["gengmei_pxf@gengmei123.local",[[-1,58,"* "]],[59,60],[58,58]]],[1519971284352,["gengmei_pxf@gengmei123.local",[[1,58,"###"]],[58,58],[61,61]]],[1519971285964,["gengmei_pxf@gengmei123.local",[[-1,62," "]],[62,62],[61,61]]]]],["48b503c9-db63-4e72-b78d-87071e4f4921",1519978728302,"一二线互联网公司Android面试题汇总\n===\n\n\n## **阿里巴巴**\n\n### LRUCache原理\n\n\n\n### 图片加载原理\n\n*   模块化实现（好处，原因）\n\n*   JVM\n\n*   视频加密传输\n\n*   统计启动时长,标准\n\n*   如何保持应用的稳定性\n\n*   ThreadLocal 原理\n\n*   谈谈classloader\n\n*   动态布局\n\n*   热修复,插件化\n\n*   HashMap源码,SpareArray原理\n\n*   性能优化,怎么保证应用启动不卡顿\n\n*   怎么去除重复代码\n\n*   SP是进程同步的吗?有什么方法做到同步\n\n*   介绍下SurfView\n\n*   HashMap实现原理，ConcurrentHashMap 的实现原理\n\n*   BroadcastReceiver，LocalBroadcastReceiver 区别\n\n*   Bundle 机制\n\n*   Handler 机制\n\n*   android 事件传递机制\n\n*   线程间 操作 List\n\n*   App启动流程，从点击桌面开始\n\n*   动态加载\n\n*   类加载器\n\n*   OSGI\n\n*   Https请求慢的解决办法，DNS，携带数据，直接访问IP\n\n*   GC回收策略\n\n*   画出 Android 的大体架构图\n\n*   描述清点击 Android Studio 的 build 按钮后发生了什么\n\n*   大体说清一个应用程序安装到手机上时发生了什么；\n\n*   对 Dalvik、ART 虚拟机有基本的了解；\n\n*   Android 上的 Inter-Process-Communication 跨进程通信时如何工作的；\n\n*   App 是如何沙箱化，为什么要这么做；\n\n*   权限管理系统（底层的权限是如何进行 grant 的）\n\n*   进程和 Application 的生命周期；\n\n*   系统启动流程 Zygote进程 –> SystemServer进程 –> 各种系统服务 –> 应用进程\n\n*   recycleview listview 的区别,性能\n\n*   排序，快速排序的实现\n\n*   树：B+树的介绍\n\n*   图：有向无环图的解释\n\n*   TCP/UDP的区别\n\n*   synchronized与Lock的区别\n\n*   volatile\n\n*   Java线程池\n\n*   Java中对象的生命周期\n\n*   类加载机制\n\n*   双亲委派模型\n\n*   Android事件分发机制\n\n*   MVP模式\n\n*   RxJava\n\n*   抽象类和接口的区别\n\n*   集合 Set实现 Hash 怎么防止碰撞\n\n*   JVM 内存区域 开线程影响哪块内存\n\n*   垃圾收集机制 对象创建，新生代与老年代\n\n*   二叉树 深度遍历与广度遍历\n\n*   B树、B+树\n\n*   消息机制\n\n*   进程调度\n\n*   进程与线程\n\n*   死锁\n\n*   进程状态\n\n*   JVM内存模型\n\n*   并发集合了解哪些\n\n*   ConCurrentHashMap实现\n\n*   CAS介绍\n\n*   开启线程的三种方式,run()和start()方法区别\n\n*   线程池\n\n*   常用数据结构简介\n\n*   判断环（猜测应该是链表环）\n\n*   排序，堆排序实现\n\n*   链表反转\n\n## **腾讯**\n\n*   synchronized用法\n\n*   volatile用法\n\n*   动态权限适配方案，权限组的概念\n\n*   网络请求缓存处理，okhttp如何处理网络缓存的\n\n*   图片加载库相关，bitmap如何处理大图，如一张30M的大图，如何预防OOM\n\n*   进程保活\n\n*   listview图片加载错乱的原理和解决方案\n\n*   https相关，如何验证证书的合法性，https中哪里用了对称加密，哪里用了非对称加密，对加密算法（如RSA）等是否有了解\n\n## **滴滴**\n\n*   MVP\n\n*   广播（动态注册和静态注册区别，有序广播和标准广播）\n\n*   service生命周期\n\n*   handler实现机制（很多细节需要关注：如线程如何建立和退出消息循环等等）\n\n*   多线程（关于AsyncTask缺陷引发的思考）\n\n*   数据库数据迁移问题\n\n*   设计模式相关（例如Android中哪里使用了观察者模式，单例模式相关）\n\n*   x个苹果，一天只能吃一个、两个、或者三个，问多少天可以吃完\n\n*   TCP与UDP区别与应用（三次握手和四次挥手）涉及到部分细节（如client如何确定自己发送的消息被server收到） HTTP相关 提到过Websocket 问了WebSocket相关以及与socket的区别\n\n*   是否熟悉Android jni开发，jni如何调用java层代码\n\n*   进程间通信的方式\n\n*   java注解\n\n*   计算一个view的嵌套层级\n\n*   项目组件化的理解\n\n*   多线程断点续传原理\n\n*   Android系统为什么会设计ContentProvider，进程共享和线程安全问题\n\n*   jvm相关\n\n*   Android相关优化（如内存优化、网络优化、布局优化、电量优化、业务优化）\n\n*   EventBus实现原理\n\n## **美团**\n\n*   static synchronized 方法的多线程访问和作用，同一个类里面两个synchronized方法，两个线程同时访问的问题\n\n*   内部类和静态内部类和匿名内部类，以及项目中的应用\n\n*   handler发消息给子线程，looper怎么启动\n\n*   View事件传递\n\n*   activity栈\n\n*   封装view的时候怎么知道view的大小\n\n*   arraylist和linkedlist的区别，以及应用场景\n\n*   怎么启动service，service和activity怎么进行数据交互\n\n*   下拉状态栏是不是影响activity的生命周期，如果在onStop的时候做了网络请求，onResume的时候怎么恢复\n\n*   view渲染\n\n## **今日头条**\n\n*   数据结构中堆的概念，堆排序\n\n*   死锁的概念，怎么避免死锁\n\n*   ReentrantLock 、synchronized和volatile（n面）\n\n*   HashMap\n\n*   singleTask启动模式\n\n*   用到的一些开源框架，介绍一个看过源码的，内部实现过程。\n\n*   消息机制实现\n\n*   ReentrantLock的内部实现\n\n*   App启动崩溃异常捕捉\n\n*   事件传递机制的介绍\n\n*   ListView的优化\n\n*   二叉树，给出根节点和目标节点，找出从根节点到目标节点的路径\n\n*   模式MVP，MVC介绍\n\n*   断点续传的实现\n\n*   集合的接口和具体实现类，介绍\n\n*   TreeMap具体实现\n\n*   synchronized与ReentrantLock\n\n*   手写生产者/消费者模式\n\n*   逻辑地址与物理地址，为什么使用逻辑地址\n\n*   一个无序，不重复数组，输出N个元素，使得N个元素的和相加为M，给出时间复杂度、空间复杂度。手写算法\n\n*   .Android进程分类\n\n*   前台切换到后台，然后再回到前台，Activity生命周期回调方法。弹出Dialog，生命值周期回调方法。\n\n*   Activity的启动模式\n\n## **爱奇艺**\n\n*   RxJava的功能与原理实现\n\n*   RecycleView的使用，原理，RecycleView优化\n\n*   ANR的原因\n\n*   四大组件\n\n*   Service的开启方式\n\n*   Activity与Service通信的方式\n\n*   Activity之间的通信方式\n\n*   HashMap的实现，与HashSet的区别\n\n*   JVM内存模型，内存区域\n\n*   Java中同步使用的关键字，死锁\n\n*   MVP模式\n\n*   Java设计模式，观察者模式\n\n*   Activity与Fragment之间生命周期比较\n\n*   广播的使用场景\n\n** 百度**\n\n* * *\n\n*   Bitmap 使用时候注意什么？\n\n*   Oom 是否可以try catch ？\n\n*   内存泄露如何产生？\n\n*   适配器模式，装饰者模式，外观模式的异同？\n\n*   ANR 如何产生？\n\n*   String buffer 与string builder 的区别？\n\n*   如何保证线程安全？\n\n*   java四中引用\n\n*   Jni 用过么？\n\n*   多进程场景遇见过么？\n\n*   关于handler，在任何地方new handler 都是什么线程下\n\n*   sqlite升级，增加字段的语句\n\n*   bitmap recycler 相关\n\n*   强引用置为null，会不会被回收？\n\n*   glide 使用什么缓存？\n\n*   Glide 内存缓存如何控制大小？\n\n*   如何保证多线程读写文件的安全？\n\n## **携程**\n\n*   Activity启动模式\n\n*   广播的使用方式，场景\n\n*   App中唤醒其他进程的实现方式\n\n*   AndroidManifest的作用与理解\n\n*   List,Set,Map的区别\n\n*   HashSet与HashMap怎么判断集合元素重复\n\n*   Java中内存区域与垃圾回收机制\n\n*   EventBus作用，实现方式，代替EventBus的方式\n\n*   Android中开启摄像头的主要步骤\n\n## **网易**\n\n*   集合\n\n*   concurrenthashmap\n\n*   volatile\n\n*   synchronized与Lock\n\n*   Java线程池\n\n*   wait/notify\n\n*   NIO\n\n*   垃圾收集器\n\n*   Activity生命周期\n\n*   AlertDialog,popupWindow,Activity区别\n\n## **小米**\n\n*   String 为什么要设计成不可变的？\n\n*   fragment 各种情况下的生命周期\n\n*   Activity 上有 Dialog 的时候按 home 键时的生命周期\n\n*   横竖屏切换的时候，Activity 各种情况下的生命周期\n\n*   Application 和 Activity 的 context 对象的区别\n\n*   序列化的作用，以及 Android 两种序列化的区别。\n\n*   List 和 Map 的实现方式以及存储方式。\n\n*   静态内部类的设计意图。\n\n*   线程如何关闭，以及如何防止线程的内存泄漏\n\n## **360**\n\n*   软引用、弱引用区别\n\n*   垃圾回收\n\n*   多线程：怎么用、有什么问题要注意；Android线程有没有上限，然后提到线程池的上限\n\n*   JVM\n\n*   锁\n\n*   OOM，内存泄漏\n\n*   ANR怎么分析解决\n\n*   LinearLayout、RelativeLayout、FrameLayout的特性、使用场景\n\n*   如何实现Fragment的滑动\n\n*   ViewPager使用细节，如何设置成每次只初始化当前的Fragment，其他的不初始化\n\n*   ListView重用的是什么\n\n*   进程间通信的机制\n\n*   AIDL机制\n\n*   AsyncTask机制\n\n*   如何取消AsyncTask\n\n*   序列化\n\n*   Android为什么引入Parcelable\n\n*   有没有尝试简化Parcelable的使用\n\n*   AIDL机制\n\n*   项目：拉活怎么做的\n\n*   应用安装过程\n\n## **某海外直播公司**\n\n*   线程和进程的区别？\n\n*   为什么要有线程，而不是仅仅用进程？\n\n*   算法判断单链表成环与否？\n\n*   如何实现线程同步？\n\n*   hashmap数据结构？\n\n*   arraylist 与 linkedlist 异同？\n\n*   object类的equal 和hashcode 方法重写，为什么？\n\n*   hashmap如何put数据（从hashmap源码角度讲解）？\n\n*   简述IPC？\n\n*   fragment之间传递数据的方式？\n\n*   简述tcp四次挥手?\n\n*   threadlocal原理\n\n*   内存泄漏的可能原因？\n\n*   用IDE如何分析内存泄漏？\n\n*   OOM的可能原因？\n\n*   线程死锁的4个条件？\n\n*   差值器&估值器\n\n*   简述消息机制相关\n\n*   进程间通信方式？\n\n*   Binder相关？\n\n*   触摸事件的分发？\n\n*   简述Activity启动全部过程？\n\n*   okhttp源码？\n\n*   RxJava简介及其源码解读？\n\n*   性能优化如何分析systrace？\n\n*   广播的分类？\n\n*   点击事件被拦截，但是相传到下面的view，如何操作？\n\n*   Glide源码？\n\n*   ActicityThread相关？\n\n*   volatile的原理\n\n*   synchronize的原理\n\n*   lock原理\n\n*   翻转一个单项链表\n\n*   string to integer\n\n*   合并多个单有序链表（假设都是递增的）\n\n## **其他公司**\n\n*   四大组件\n\n*   Android中数据存储方式\n\n*   微信主页面的实现方式\n\n*   微信上消息小红点的原理\n\n*   两个不重复的数组集合中，求共同的元素。\n\n*   上一问扩展，海量数据，内存中放不下，怎么求出。\n\n*   Java中String的了解。\n\n*   ArrayList与LinkedList区别\n\n*   堆排序过程，时间复杂度，空间复杂度\n\n*   快速排序的时间复杂度，空间复杂度\n\n*   RxJava的作用，与平时使用的异步操作来比，优势\n\n*   Android消息机制原理\n\n*   Binder机制介绍\n\n*   为什么不能在子线程更新UI\n\n*   JVM内存模型\n\n*   Android中进程内存的分配，能不能自己分配定额内存\n\n*   垃圾回收机制与调用System.gc()区别\n\n*   Android事件分发机制\n\n*   断点续传的实现\n\n*   RxJava的作用，优缺点",[[1519978715854,["gengmei_pxf@gengmei123.local",[[-1,40,"###"],[1,43,"*"]],[40,43],[41,41]]],[1519978719006,["gengmei_pxf@gengmei123.local",[[-1,56,"### 图片"],[1,62,"*"]],[56,62],[57,57]]],[1519978720642,["gengmei_pxf@gengmei123.local",[[-1,55,"\n"]],[54,54],[53,53]]],[1519978721089,["gengmei_pxf@gengmei123.local",[[-1,54,"\n"]],[53,53],[52,52]]],[1519978724587,["gengmei_pxf@gengmei123.local",[[1,55,"  "]],[55,55],[57,57]]],[1519978726105,["gengmei_pxf@gengmei123.local",[[-1,56," "]],[57,57],[56,56]]],[1519978730922,["gengmei_pxf@gengmei123.local",[[1,42,"  "]],[42,42],[44,44]]],[1519978732315,["gengmei_pxf@gengmei123.local",[[1,58,"  "]],[58,58],[60,60]]],[1519978797944,["gengmei_pxf@gengmei123.local",[[1,60,"图片"]],[60,64],[66,66]]]]],["1f580da8-466a-4b1e-a168-ad33ce171a45",1521540379519,"一二线互联网公司Android面试题汇总\n===\n\n\n## **阿里巴巴**\n\n*   LRUCache原理\n\n*   图片加载原理\n\n*   模块化实现（好处，原因）\n\n*   JVM\n\n*   视频加密传输\n\n*   统计启动时长,标准\n\n*   如何保持应用的稳定性\n\n*   ThreadLocal 原理\n\n*   谈谈classloader\n\n*   动态布局\n\n*   热修复,插件化\n\n*   HashMap源码,SpareArray原理\n\n*   性能优化,怎么保证应用启动不卡顿\n\n*   怎么去除重复代码\n\n*   SP是进程同步的吗?有什么方法做到同步\n\n*   介绍下SurfView\n\n*   HashMap实现原理，ConcurrentHashMap 的实现原理\n\n*   BroadcastReceiver，LocalBroadcastReceiver 区别\n\n*   Bundle 机制\n\n*   Handler 机制\n\n*   android 事件传递机制\n\n*   线程间 操作 List\n\n*   App启动流程，从点击桌面开始\n\n*   动态加载\n\n*   类加载器\n\n*   OSGI\n\n*   Https请求慢的解决办法，DNS，携带数据，直接访问IP\n\n*   GC回收策略\n\n*   画出 Android 的大体架构图\n\n*   描述清点击 Android Studio 的 build 按钮后发生了什么\n\n*   大体说清一个应用程序安装到手机上时发生了什么；\n\n*   对 Dalvik、ART 虚拟机有基本的了解；\n\n*   Android 上的 Inter-Process-Communication 跨进程通信时如何工作的；\n\n*   App 是如何沙箱化，为什么要这么做；\n\n*   权限管理系统（底层的权限是如何进行 grant 的）\n\n*   进程和 Application 的生命周期；\n\n*   系统启动流程 Zygote进程 –> SystemServer进程 –> 各种系统服务 –> 应用进程\n\n*   recycleview listview 的区别,性能\n\n*   排序，快速排序的实现\n\n*   树：B+树的介绍\n\n*   图：有向无环图的解释\n\n*   TCP/UDP的区别\n\n*   synchronized与Lock的区别\n\n*   volatile\n\n*   Java线程池\n\n*   Java中对象的生命周期\n\n*   类加载机制\n\n*   双亲委派模型\n\n*   Android事件分发机制\n\n*   MVP模式\n\n*   RxJava\n\n*   抽象类和接口的区别\n\n*   集合 Set实现 Hash 怎么防止碰撞\n\n*   JVM 内存区域 开线程影响哪块内存\n\n*   垃圾收集机制 对象创建，新生代与老年代\n\n*   二叉树 深度遍历与广度遍历\n\n*   B树、B+树\n\n*   消息机制\n\n*   进程调度\n\n*   进程与线程\n\n*   死锁\n\n*   进程状态\n\n*   JVM内存模型\n\n*   并发集合了解哪些\n\n*   ConCurrentHashMap实现\n\n*   CAS介绍\n\n*   开启线程的三种方式,run()和start()方法区别\n\n*   线程池\n\n*   常用数据结构简介\n\n*   判断环（猜测应该是链表环）\n\n*   排序，堆排序实现\n\n*   链表反转\n\n## **腾讯**\n\n*   synchronized用法\n\n*   volatile用法\n\n*   动态权限适配方案，权限组的概念\n\n*   网络请求缓存处理，okhttp如何处理网络缓存的\n\n*   图片加载库相关，bitmap如何处理大图，如一张30M的大图，如何预防OOM\n\n*   进程保活\n\n*   listview图片加载错乱的原理和解决方案\n\n*   https相关，如何验证证书的合法性，https中哪里用了对称加密，哪里用了非对称加密，对加密算法（如RSA）等是否有了解\n\n## **滴滴**\n\n*   MVP\n\n*   广播（动态注册和静态注册区别，有序广播和标准广播）\n\n*   service生命周期\n\n*   handler实现机制（很多细节需要关注：如线程如何建立和退出消息循环等等）\n\n*   多线程（关于AsyncTask缺陷引发的思考）\n\n*   数据库数据迁移问题\n\n*   设计模式相关（例如Android中哪里使用了观察者模式，单例模式相关）\n\n*   x个苹果，一天只能吃一个、两个、或者三个，问多少天可以吃完\n\n*   TCP与UDP区别与应用（三次握手和四次挥手）涉及到部分细节（如client如何确定自己发送的消息被server收到） HTTP相关 提到过Websocket 问了WebSocket相关以及与socket的区别\n\n*   是否熟悉Android jni开发，jni如何调用java层代码\n\n*   进程间通信的方式\n\n*   java注解\n\n*   计算一个view的嵌套层级\n\n*   项目组件化的理解\n\n*   多线程断点续传原理\n\n*   Android系统为什么会设计ContentProvider，进程共享和线程安全问题\n\n*   jvm相关\n\n*   Android相关优化（如内存优化、网络优化、布局优化、电量优化、业务优化）\n\n*   EventBus实现原理\n\n## **美团**\n\n*   static synchronized 方法的多线程访问和作用，同一个类里面两个synchronized方法，两个线程同时访问的问题\n\n*   内部类和静态内部类和匿名内部类，以及项目中的应用\n\n*   handler发消息给子线程，looper怎么启动\n\n*   View事件传递\n\n*   activity栈\n\n*   封装view的时候怎么知道view的大小\n\n*   arraylist和linkedlist的区别，以及应用场景\n\n*   怎么启动service，service和activity怎么进行数据交互\n\n*   下拉状态栏是不是影响activity的生命周期，如果在onStop的时候做了网络请求，onResume的时候怎么恢复\n\n*   view渲染\n\n## **今日头条**\n\n*   数据结构中堆的概念，堆排序\n\n*   死锁的概念，怎么避免死锁\n\n*   ReentrantLock 、synchronized和volatile（n面）\n\n*   HashMap\n\n*   singleTask启动模式\n\n*   用到的一些开源框架，介绍一个看过源码的，内部实现过程。\n\n*   消息机制实现\n\n*   ReentrantLock的内部实现\n\n*   App启动崩溃异常捕捉\n\n*   事件传递机制的介绍\n\n*   ListView的优化\n\n*   二叉树，给出根节点和目标节点，找出从根节点到目标节点的路径\n\n*   模式MVP，MVC介绍\n\n*   断点续传的实现\n\n*   集合的接口和具体实现类，介绍\n\n*   TreeMap具体实现\n\n*   synchronized与ReentrantLock\n\n*   手写生产者/消费者模式\n\n*   逻辑地址与物理地址，为什么使用逻辑地址\n\n*   一个无序，不重复数组，输出N个元素，使得N个元素的和相加为M，给出时间复杂度、空间复杂度。手写算法\n\n*   .Android进程分类\n\n*   前台切换到后台，然后再回到前台，Activity生命周期回调方法。弹出Dialog，生命值周期回调方法。\n\n*   Activity的启动模式\n\n## **爱奇艺**\n\n*   RxJava的功能与原理实现\n\n*   RecycleView的使用，原理，RecycleView优化\n\n*   ANR的原因\n\n*   四大组件\n\n*   Service的开启方式\n\n*   Activity与Service通信的方式\n\n*   Activity之间的通信方式\n\n*   HashMap的实现，与HashSet的区别\n\n*   JVM内存模型，内存区域\n\n*   Java中同步使用的关键字，死锁\n\n*   MVP模式\n\n*   Java设计模式，观察者模式\n\n*   Activity与Fragment之间生命周期比较\n\n*   广播的使用场景\n\n** 百度**\n\n* * *\n\n*   Bitmap 使用时候注意什么？\n\n*   Oom 是否可以try catch ？\n\n*   内存泄露如何产生？\n\n*   适配器模式，装饰者模式，外观模式的异同？\n\n*   ANR 如何产生？\n\n*   String buffer 与string builder 的区别？\n\n*   如何保证线程安全？\n\n*   java四中引用\n\n*   Jni 用过么？\n\n*   多进程场景遇见过么？\n\n*   关于handler，在任何地方new handler 都是什么线程下\n\n*   sqlite升级，增加字段的语句\n\n*   bitmap recycler 相关\n\n*   强引用置为null，会不会被回收？\n\n*   glide 使用什么缓存？\n\n*   Glide 内存缓存如何控制大小？\n\n*   如何保证多线程读写文件的安全？\n\n## **携程**\n\n*   Activity启动模式\n\n*   广播的使用方式，场景\n\n*   App中唤醒其他进程的实现方式\n\n*   AndroidManifest的作用与理解\n\n*   List,Set,Map的区别\n\n*   HashSet与HashMap怎么判断集合元素重复\n\n*   Java中内存区域与垃圾回收机制\n\n*   EventBus作用，实现方式，代替EventBus的方式\n\n*   Android中开启摄像头的主要步骤\n\n## **网易**\n\n*   集合\n\n*   concurrenthashmap\n\n*   volatile\n\n*   synchronized与Lock\n\n*   Java线程池\n\n*   wait/notify\n\n*   NIO\n\n*   垃圾收集器\n\n*   Activity生命周期\n\n*   AlertDialog,popupWindow,Activity区别\n\n## **小米**\n\n*   String 为什么要设计成不可变的？\n\n*   fragment 各种情况下的生命周期\n\n*   Activity 上有 Dialog 的时候按 home 键时的生命周期\n\n*   横竖屏切换的时候，Activity 各种情况下的生命周期\n\n*   Application 和 Activity 的 context 对象的区别\n\n*   序列化的作用，以及 Android 两种序列化的区别。\n\n*   List 和 Map 的实现方式以及存储方式。\n\n*   静态内部类的设计意图。\n\n*   线程如何关闭，以及如何防止线程的内存泄漏\n\n## **360**\n\n*   软引用、弱引用区别\n\n*   垃圾回收\n\n*   多线程：怎么用、有什么问题要注意；Android线程有没有上限，然后提到线程池的上限\n\n*   JVM\n\n*   锁\n\n*   OOM，内存泄漏\n\n*   ANR怎么分析解决\n\n*   LinearLayout、RelativeLayout、FrameLayout的特性、使用场景\n\n*   如何实现Fragment的滑动\n\n*   ViewPager使用细节，如何设置成每次只初始化当前的Fragment，其他的不初始化\n\n*   ListView重用的是什么\n\n*   进程间通信的机制\n\n*   AIDL机制\n\n*   AsyncTask机制\n\n*   如何取消AsyncTask\n\n*   序列化\n\n*   Android为什么引入Parcelable\n\n*   有没有尝试简化Parcelable的使用\n\n*   AIDL机制\n\n*   项目：拉活怎么做的\n\n*   应用安装过程\n\n## **某海外直播公司**\n\n*   线程和进程的区别？\n\n*   为什么要有线程，而不是仅仅用进程？\n\n*   算法判断单链表成环与否？\n\n*   如何实现线程同步？\n\n*   hashmap数据结构？\n\n*   arraylist 与 linkedlist 异同？\n\n*   object类的equal 和hashcode 方法重写，为什么？\n\n*   hashmap如何put数据（从hashmap源码角度讲解）？\n\n*   简述IPC？\n\n*   fragment之间传递数据的方式？\n\n*   简述tcp四次挥手?\n\n*   threadlocal原理\n\n*   内存泄漏的可能原因？\n\n*   用IDE如何分析内存泄漏？\n\n*   OOM的可能原因？\n\n*   线程死锁的4个条件？\n\n*   差值器&估值器\n\n*   简述消息机制相关\n\n*   进程间通信方式？\n\n*   Binder相关？\n\n*   触摸事件的分发？\n\n*   简述Activity启动全部过程？\n\n*   okhttp源码？\n\n*   RxJava简介及其源码解读？\n\n*   性能优化如何分析systrace？\n\n*   广播的分类？\n\n*   点击事件被拦截，但是相传到下面的view，如何操作？\n\n*   Glide源码？\n\n*   ActicityThread相关？\n\n*   volatile的原理\n\n*   synchronize的原理\n\n*   lock原理\n\n*   翻转一个单项链表\n\n*   string to integer\n\n*   合并多个单有序链表（假设都是递增的）\n\n## **其他公司**\n\n*   四大组件\n\n*   Android中数据存储方式\n\n*   微信主页面的实现方式\n\n*   微信上消息小红点的原理\n\n*   两个不重复的数组集合中，求共同的元素。\n\n*   上一问扩展，海量数据，内存中放不下，怎么求出。\n\n*   Java中String的了解。\n\n*   ArrayList与LinkedList区别\n\n*   堆排序过程，时间复杂度，空间复杂度\n\n*   快速排序的时间复杂度，空间复杂度\n\n*   RxJava的作用，与平时使用的异步操作来比，优势\n\n*   Android消息机制原理\n\n*   Binder机制介绍\n\n*   为什么不能在子线程更新UI\n\n*   JVM内存模型\n\n*   Android中进程内存的分配，能不能自己分配定额内存\n\n*   垃圾回收机制与调用System.gc()区别\n\n*   Android事件分发机制\n\n*   断点续传的实现\n\n*   RxJava的作用，优缺点",[[1521540323762,["gengmei_pxf@gengmei123.local",[[1,6149,"\n\n"]],[6149,6149],[6150,6150]]],[1521540323945,["gengmei_pxf@gengmei123.local",[[1,6151,"\n"]],[6150,6150],[6151,6151]]],[1521540324627,["gengmei_pxf@gengmei123.local",[[1,6151,"问得最多的是自定义 View 基本每家都问，问 View 的绘制流程，自定义View的步骤，有时会涉及到细节比如 PhoneWindow 实例是在哪个类哪个方法中实例化的，Selector 是怎么实现的，View 动画是怎么实现的为什么移动后点击事件还在原来的位置，属性动画的原理机制。Android 系统源码部分，事件拦截和分发，进程间的通信方式，应用的创建启动流程，Handler 是怎么导致内存泄露的。第三方库的源码，Glide、OkHttp 和 Retrofit 问得比较多，MVC，MVP和 MVVM 开发模式优缺点，常用设计模式理解问得也多，大公司 Binder 驱动和虚拟机方面问得比较多。数据结构和算法，Java 的常用集合实现原理，比如 ArrayList ，LinkedHashMap 的实现原理，缓存淘汰策略，红黑树和二叉树，最短路径规划，海量数据筛选，很荣幸的是面试官目前还没有要我手写算法。性能优化，如何检测一段代码的执行时间，界面卡顿如何修复，滑动不流畅怎么处理， 50fps 有什么办法可以提高到 60fps，内存泄露怎么检测，leakcanay 的原理。线程和线程池，wait() 和 sleep() 的区别，同步锁，线程池的参数详解，AsyncTask 源码参数详解，我能记得的大概就这些了。最后还啰嗦一下，有很多公司标明了，你必须要会 C 和 C++， OpenGL 或 OpenCv 或音视频编解码。选工作的时候要小心，我写的是熟悉，因为像音视频和 OpenCv 图像处理这些方面，没做个6、7年最好不要写精通。"]],[6151,6151],[6826,6826]]],[1521540332097,["gengmei_pxf@gengmei123.local",[[1,6172,"\n"]],[6172,6172],[6173,6173]]],[1521540334114,["gengmei_pxf@gengmei123.local",[[-1,6173,"，"]],[6174,6174],[6173,6173]]],[1521540337898,["gengmei_pxf@gengmei123.local",[[1,6186,"\n"]],[6186,6186],[6187,6187]]],[1521540341336,["gengmei_pxf@gengmei123.local",[[1,6198,"\n"]],[6198,6198],[6199,6199]]],[1521540344961,["gengmei_pxf@gengmei123.local",[[1,6239,"\n"]],[6239,6239],[6240,6240]]],[1521540346734,["gengmei_pxf@gengmei123.local",[[1,6256,"\n"]],[6256,6256],[6257,6257]]],[1521540350423,["gengmei_pxf@gengmei123.local",[[1,6288,"\n"]],[6288,6288],[6289,6289]]],[1521540352804,["gengmei_pxf@gengmei123.local",[[1,6299,"\n"]],[6299,6299],[6300,6300]]],[1521540355561,["gengmei_pxf@gengmei123.local",[[1,6315,"\n"]],[6315,6315],[6316,6316]]],[1521540357744,["gengmei_pxf@gengmei123.local",[[1,6324,"\n"]],[6324,6324],[6325,6325]]],[1521540359649,["gengmei_pxf@gengmei123.local",[[1,6334,"\n"]],[6334,6334],[6335,6335]]],[1521540361449,["gengmei_pxf@gengmei123.local",[[1,6345,"\n"]],[6345,6345],[6346,6346]]],[1521540363159,["gengmei_pxf@gengmei123.local",[[1,6365,"\n"]],[6365,6365],[6366,6366]]],[1521540367104,["gengmei_pxf@gengmei123.local",[[1,6404,"\n"]],[6404,6404],[6405,6405]]],[1521540369223,["gengmei_pxf@gengmei123.local",[[1,6427,"\n"]],[6427,6427],[6428,6428]]],[1521540372040,["gengmei_pxf@gengmei123.local",[[1,6441,"\n"]],[6441,6441],[6442,6442]]],[1521540374184,["gengmei_pxf@gengmei123.local",[[1,6467,"\n"]],[6467,6467],[6468,6468]]],[1521540377896,["gengmei_pxf@gengmei123.local",[[1,6476,"\n"]],[6476,6476],[6477,6477]]],[1521540389640,["gengmei_pxf@gengmei123.local",[[-1,6554,"，很荣幸的是面试官目前还没有要我手写算法"]],[6555,6574],[6554,6554]]],[1521540390839,["gengmei_pxf@gengmei123.local",[[1,6555,"\n"]],[6555,6555],[6556,6556]]],[1521540398159,["gengmei_pxf@gengmei123.local",[[1,6617,"\n"]],[6617,6617],[6618,6618]]],[1521540402030,["gengmei_pxf@gengmei123.local",[[-1,6618,"，"]],[6619,6619],[6618,6618]]],[1521540404086,["gengmei_pxf@gengmei123.local",[[1,6641,"\n"]],[6641,6641],[6642,6642]]],[1521540410157,["gengmei_pxf@gengmei123.local",[[1,6683,"\n"]],[6683,6683],[6684,6684]]],[1521540419206,["gengmei_pxf@gengmei123.local",[[1,6713,"\n"]],[6713,6713],[6714,6714]]],[1521540435093,["gengmei_pxf@gengmei123.local",[[-1,6721,"，有很多公司标明了，你必须要会 C 和 C++， OpenGL 或 OpenCv 或音视频编解码。选工作的时候要小心，我"]],[6721,6781],[6721,6721]]],[1521540439655,["gengmei_pxf@gengmei123.local",[[1,6721," "]],[6721,6721],[6722,6722]]],[1521540443862,["gengmei_pxf@gengmei123.local",[[-1,6730,"像音视频和 OpenCv 图像处理这些方面，"]],[6730,6752],[6730,6730]]],[1521540454760,["gengmei_pxf@gengmei123.local",[[1,6722,"技能最好"]],[6722,6722],[6726,6726]]]]]]}