{"compress":true,"commitItems":[["02a76674-d7d0-4e93-9fda-d3cf9a6647ec",1520929134458,"Android的UI访问是没有加锁的，这样在多个线程访问UI是不安全的。所以Android中规定只能在UI线程中访问UI。\n\n## 实例\n但是有没有极端的情况？使得我们在子线程中访问UI也可以使程序跑起来呢？接下来我们用一个例子去证实一下。\n\n新建一个工程，activity_main.xml布局如下所示：\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    >\n\n    <TextView\n        android:id=\"@+id/main_tv\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:textSize=\"18sp\"\n        android:layout_centerInParent=\"true\"\n        />\n\n</RelativeLayout>\n```\n很简单，只是添加了一个居中的TextView\n\nMainActivity代码如下所示：\n\n```\npublic class MainActivity extends AppCompatActivity {\n\n    private TextView main_tv;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        main_tv = (TextView) findViewById(R.id.main_tv);\n\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                main_tv.setText(\"子线程中访问\");\n            }\n        }).start();\n\n    }\n\n}\n```\n也是很简单的几行，在onCreate方法中创建了一个子线程，并进行UI访问操作。\n\n点击运行。你会发现即使在子线程中访问UI，程序一样能跑起来。结果如下所示： \n\n\n\n咦，那为嘛以前在子线程中更新UI会报错呢？难道真的可以在子线程中访问UI？\n\n先不急，这是一个极端的情况，修改MainActivity如下：\n\n```\npublic class MainActivity extends AppCompatActivity {\n\n    private TextView main_tv;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        main_tv = (TextView) findViewById(R.id.main_tv);\n\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(200);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                main_tv.setText(\"子线程中访问\");\n            }\n        }).start();\n\n    }\n\n}\n```\n让子线程睡眠200毫秒，醒来后再进行UI访问。\n\n结果你会发现，程序崩了。这才是正常的现象嘛。抛出了如下很熟悉的异常：\n\nandroid.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. \nat android.view.ViewRootImpl.checkThread(ViewRootImpl.Java:6581) \nat android.view.ViewRootImpl.requestLayout(ViewRootImpl.java:924)\n\n……\n\n作为一名开发者，我们应该认真阅读一下这些异常信息，是可以根据这些异常信息来找到为什么一开始的那种情况可以访问UI的。那我们分析一下异常信息：\n\n首先，从以下异常信息可以知道\n\nat android.view.ViewRootImpl.checkThread(ViewRootImpl.java:6581)\n\n这个异常是从android.view.ViewRootImpl的checkThread方法抛出的。\n\n这里顺便铺垫一个知识点：ViewRootImpl是ViewRoot的实现类。\n\n那现在跟进ViewRootImpl的checkThread方法瞧瞧，源码如下：\n\n```\nvoid checkThread() {\n    if (mThread != Thread.currentThread()) {\n        throw new CalledFromWrongThreadException(\n                \"Only the original thread that created a view hierarchy can touch its views.\");\n    }\n}\n```\n只有那么几行代码而已的，而mThread是主线程，在应用程序启动的时候，就已经被初始化了。\n\n由此我们可以得出结论： \n在访问UI的时候，ViewRoot会去检查当前是哪个线程访问的UI，如果不是主线程，那就会抛出如下异常：\n\nOnly the original thread that created a view hierarchy can touch its views\n\n这好像并不能解释什么？继续看到异常信息\n\nat android.view.ViewRootImpl.requestLayout(ViewRootImpl.java:924)\n\n## 验证\n\n那现在就看看requestLayout方法，\n\n```\n@Override\npublic void requestLayout() {\n    if (!mHandlingLayoutInLayoutRequest) {\n        checkThread();\n        mLayoutRequested = true;\n        scheduleTraversals();\n    }\n}\n```\n这里也是调用了checkThread()方法来检查当前线程，咦？除了检查线程好像没有什么信息。那再点进scheduleTraversals()方法看看\n\n```\nvoid scheduleTraversals() {\n    if (!mTraversalScheduled) {\n        mTraversalScheduled = true;\n        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();\n        mChoreographer.postCallback(\n                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);\n        if (!mUnbufferedInputDispatch) {\n            scheduleConsumeBatchedInput();\n        }\n        notifyRendererOfFramePending();\n        pokeDrawLockIfNeeded();\n    }\n}\n```\n注意到postCallback方法的的第二个参数传入了很像是一个后台任务。那再点进去\n\n```\nfinal class TraversalRunnable implements Runnable {\n    @Override\n    public void run() {\n        doTraversal();\n    }\n}\n```\n找到了，那么继续跟进doTraversal()方法。\n\n```\nvoid doTraversal() {\n    if (mTraversalScheduled) {\n        mTraversalScheduled = false;\n        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);\n\n        if (mProfile) {\n            Debug.startMethodTracing(\"ViewAncestor\");\n        }\n\n        performTraversals();\n\n        if (mProfile) {\n            Debug.stopMethodTracing();\n            mProfile = false;\n        }\n    }\n}\n```\n可以看到里面调用了一个performTraversals()方法，View的绘制过程就是从这个performTraversals方法开始的。PerformTraversals方法的代码有点长就不贴出来了，如果继续跟进去就是学习View的绘制了。而我们现在知道了，每一次访问了UI，Android都会重新绘制View。这个是很好理解的。\n\n分析到了这里，其实异常信息对我们帮助也不大了，它只告诉了我们子线程中访问UI在哪里抛出异常。 \n而我们会思考：当访问UI时，ViewRoot会调用checkThread方法去检查当前访问UI的线程是哪个，如果不是UI线程则会抛出异常，这是没问题的。但是为什么一开始在MainActivity的onCreate方法中创建一个子线程访问UI，程序还是正常能跑起来呢？？ \n唯一的解释就是执行onCreate方法的那个时候ViewRootImpl还没创建，无法去检查当前线程。\n\n那么就可以这样深入进去。寻找ViewRootImpl是在哪里，是什么时候创建的。好，继续前进\n\n在ActivityThread中，我们找到handleResumeActivity方法，如下：\n\n```\nfinal void handleResumeActivity(IBinder token,\n        boolean clearHide, boolean isForward, boolean reallyResume) {\n    // If we are getting ready to gc after going to the background, well\n    // we are back active so skip it.\n    unscheduleGcIdler();\n    mSomeActivitiesChanged = true;\n\n    // TODO Push resumeArgs into the activity for consideration\n    ActivityClientRecord r = performResumeActivity(token, clearHide);\n\n    if (r != null) {\n        final Activity a = r.activity;\n\n        //代码省略\n\n            r.activity.mVisibleFromServer = true;\n            mNumVisibleActivities++;\n            if (r.activity.mVisibleFromClient) {\n                r.activity.makeVisible();\n            }\n        }\n\n      //代码省略    \n}\n```\n可以看到内部调用了performResumeActivity方法，这个方法看名字肯定是回调onResume方法的入口的，那么我们还是跟进去瞧瞧。\n\n```\npublic final ActivityClientRecord performResumeActivity(IBinder token,\n        boolean clearHide) {\n    ActivityClientRecord r = mActivities.get(token);\n    if (localLOGV) Slog.v(TAG, \"Performing resume of \" + r\n            + \" finished=\" + r.activity.mFinished);\n    if (r != null && !r.activity.mFinished) {\n    //代码省略\n            r.activity.performResume();\n\n    //代码省略\n\n    return r;\n}\n```\n可以看到r.activity.performResume()这行代码，跟进 performResume方法，如下：\n\n```\nfinal void performResume() {\n    performRestart();\n\n    mFragments.execPendingActions();\n\n    mLastNonConfigurationInstances = null;\n\n    mCalled = false;\n    // mResumed is set by the instrumentation\n    mInstrumentation.callActivityOnResume(this);\n\n    //代码省略\n\n}\n```\nInstrumentation调用了callActivityOnResume方法，callActivityOnResume源码如下：\n\n```\npublic void callActivityOnResume(Activity activity) {\n    activity.mResumed = true;\n    activity.onResume();\n\n    if (mActivityMonitors != null) {\n        synchronized (mSync) {\n            final int N = mActivityMonitors.size();\n            for (int i=0; i<N; i++) {\n                final ActivityMonitor am = mActivityMonitors.get(i);\n                am.match(activity, activity, activity.getIntent());\n            }\n        }\n    }\n}\n```\n找到了，activity.onResume()。这也证实了，performResumeActivity方法确实是回调onResume方法的入口。\n\n那么现在我们看回来handleResumeActivity方法，执行完performResumeActivity方法回调了onResume方法后， \n会来到这一块代码：\n\nr.activity.mVisibleFromServer = true;\nmNumVisibleActivities++;\nif (r.activity.mVisibleFromClient) {\n    r.activity.makeVisible();\n}\nactivity调用了makeVisible方法，这应该是让什么显示的吧，跟进去探探。\n\n```\nvoid makeVisible() {\n    if (!mWindowAdded) {\n        ViewManager wm = getWindowManager();\n        wm.addView(mDecor, getWindow().getAttributes());\n        mWindowAdded = true;\n    }\n    mDecor.setVisibility(View.VISIBLE);\n}\n```\n## addView\n往WindowManager中添加DecorView，那现在应该关注的就是WindowManager的addView方法了。而WindowManager是一个接口来的，我们应该找到WindowManager的实现类才行，而WindowManager的实现类是WindowManagerImpl。这个和ViewRoot是一样，就是名字多了个impl。\n\n找到了WindowManagerImpl的addView方法，如下：\n\n@Override\npublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {\n    applyDefaultToken(params);\n    mGlobal.addView(view, params, mDisplay, mParentWindow);\n}\n里面调用了WindowManagerGlobal的addView方法，那现在就锁定 \nWindowManagerGlobal的addView方法：\n\n```\npublic void addView(View view, ViewGroup.LayoutParams params,\n        Display display, Window parentWindow) {\n\n    //代码省略  \n\n\n    ViewRootImpl root;\n    View panelParentView = null;\n\n    //代码省略\n\n        root = new ViewRootImpl(view.getContext(), display);\n\n        view.setLayoutParams(wparams);\n\n        mViews.add(view);\n        mRoots.add(root);\n        mParams.add(wparams);\n    }\n\n    // do this last because it fires off messages to start doing things\n    try {\n        root.setView(view, wparams, panelParentView);\n    } catch (RuntimeException e) {\n        // BadTokenException or InvalidDisplayException, clean up.\n        synchronized (mLock) {\n            final int index = findViewLocked(view, false);\n            if (index >= 0) {\n                removeViewLocked(index, true);\n            }\n        }\n        throw e;\n    }\n}\n```\n终于击破，ViewRootImpl是在WindowManagerGlobal的addView方法中创建的。\n##总结\n回顾前面的分析，总结一下： \n\tViewRootImpl的创建在onResume方法回调之后，而我们一开篇是在onCreate方法中创建了子线程并访问UI，在那个时刻，ViewRootImpl是没有创建的，无法检测当前线程是否是UI线程，所以程序没有崩溃一样能跑起来，而之后修改了程序，让线程休眠了200毫秒后，程序就崩了。很明显200毫秒后ViewRootImpl已经创建了，可以执行checkThread方法检查当前线程。",[[1520929125402,["gengmei_pxf@gengmei123.local",[[1,0,"\n"]],[0,0],[1,1]]],[1520929130653,["gengmei_pxf@gengmei123.local",[[1,0,"可以在非主线程修改UI吗"]],[0,0],[12,12]]],[1520929131138,["gengmei_pxf@gengmei123.local",[[1,13,"\n"]],[12,12],[13,13]]],[1520929132964,["gengmei_pxf@gengmei123.local",[[1,13,"=="]],[13,13],[15,15]]],[1520929143067,["gengmei_pxf@gengmei123.local",[[1,8989," "]],[8989,8989],[8990,8990]]]]]]}