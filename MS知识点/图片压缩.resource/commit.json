{"compress":true,"commitItems":[["bacc071a-4018-4bc8-af9b-6e6728490476",1517916492200,"",[[1517916479945,["gengmei_pxf@gengmei123.local",[[1,0,"图片压缩\n===\n\n\n## 质量压缩\n\n质量压缩：根据传递进去的质量大小，采用系统自带的压缩算法，将图片压缩成JPEG格式\n\n```\n/**\n * 质量压缩\n *\n * @param bitmap\n * @param quality\n * @param file\n */\npublic static void compressQuality(Bitmap bitmap, int quality, File file) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    bitmap.compress(Bitmap.CompressFormat.JPEG, quality, baos);\n    try {\n        FileOutputStream fos = new FileOutputStream(file);\n        fos.write(baos.toByteArray());\n        fos.flush();\n        fos.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\n```\n\n## [](https://github.com/AndroidHensen/BitmapCompress#%E5%B0%BA%E5%AF%B8%E5%8E%8B%E7%BC%A9)尺寸压缩\n\n尺寸压缩：根据图片的缩放比例进行等比大小的缩小尺寸，从而达到压缩的效果\n\n```\n/**\n * 尺寸压缩\n *\n * @param bitmap\n * @param file\n */\npublic static void compressSize(Bitmap bitmap, File file) {\n    int ratio = 8;//尺寸压缩比例\n    Bitmap result = Bitmap.createBitmap(bitmap.getWidth() / ratio, bitmap.getHeight() / ratio, Bitmap.Config.ARGB_8888);\n    Canvas canvas = new Canvas(result);\n    Rect rect = new Rect(0, 0, bitmap.getWidth() / ratio, bitmap.getHeight() / ratio);\n    canvas.drawBitmap(bitmap, null, rect, null);\n\n    compressQuality(result, 100, file);\n}\n\n```\n\n## [](https://github.com/AndroidHensen/BitmapCompress#%E9%87%87%E6%A0%B7%E7%8E%87%E5%8E%8B%E7%BC%A9)采样率压缩\n\n采样率压缩：根据图片的采样率大小进行压缩\n\n```\n/**\n * 采样率压缩\n *\n * @param filePath\n * @param file\n */\npublic static void compressSample(String filePath, File file) {\n    int inSampleSize = 8;//采样率设置\n    BitmapFactory.Options options = new BitmapFactory.Options();\n    options.inJustDecodeBounds = false;\n    options.inSampleSize = inSampleSize;\n    Bitmap bitmap = BitmapFactory.decodeFile(filePath, options);\n\n    compressQuality(bitmap, 100, file);\n}\n\n```\n\n## [](https://github.com/AndroidHensen/BitmapCompress#libjpeg%E5%8E%8B%E7%BC%A9)LibJpeg压缩\n\nLibJpeg压缩：通过Ndk调用LibJpeg库进行压缩，保留原有的像素，清晰度高\n\n### [](https://github.com/AndroidHensen/BitmapCompress#%E7%BC%96%E8%AF%91libjpeg)编译LibJpeg\n\n1、从Github上可以下载已经写好编译脚本的项目：[https://github.com/Zelex/libjpeg-turbo-android，并将其上传到Linux服务器的某个目录](https://github.com/Zelex/libjpeg-turbo-android%EF%BC%8C%E5%B9%B6%E5%B0%86%E5%85%B6%E4%B8%8A%E4%BC%A0%E5%88%B0Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%9F%90%E4%B8%AA%E7%9B%AE%E5%BD%95)\n\n[![这里写图片描述](https://camo.githubusercontent.com/bb8ae4e538ea1d619da760b596eb307ece527775/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f32303137313232343131353534353437363f77617465726d61726b2f322f746578742f6148523063446f764c324a736232637559334e6b626935755a585176635846664d7a417a4e7a6b324f446b3d2f666f6e742f3561364c354c32542f666f6e7473697a652f3430302f66696c6c2f49304a42516b46434d413d3d2f646973736f6c76652f37302f677261766974792f536f75746845617374)](https://camo.githubusercontent.com/bb8ae4e538ea1d619da760b596eb307ece527775/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f32303137313232343131353534353437363f77617465726d61726b2f322f746578742f6148523063446f764c324a736232637559334e6b626935755a585176635846664d7a417a4e7a6b324f446b3d2f666f6e742f3561364c354c32542f666f6e7473697a652f3430302f66696c6c2f49304a42516b46434d413d3d2f646973736f6c76652f37302f677261766974792f536f75746845617374)\n\n2、授予整个目录权限\n\n```\nchmod 777 -R libjpeg-turbo-android-master\n\n```\n\n3、进入libjpeg目录，使用下面指令进行编译，前提是你的服务器已经搭建了ndk-build和配置了环境变量\n\n```\nndk-build NDK_PROJECT_PATH=. APP_BUILD_SCRIPT=./Android.mk APP_ABI=armeabi-v7a obj/local/armeabi-v7a/libjpeg.a LOCAL_ARM_MODE=arm LOCAL_ARM_NEON=true ARCH_ARM_HAVE_NEON=true\n\n```\n\n4、接着编译成功后，会在 obj/local 目录下生成我们需要的 libjpeg.a\n\n[![这里写图片描述](https://camo.githubusercontent.com/d7a6726372a54d841514c462a06081fa3414908c/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f32303137313232343131353531313138363f77617465726d61726b2f322f746578742f6148523063446f764c324a736232637559334e6b626935755a585176635846664d7a417a4e7a6b324f446b3d2f666f6e742f3561364c354c32542f666f6e7473697a652f3430302f66696c6c2f49304a42516b46434d413d3d2f646973736f6c76652f37302f677261766974792f536f75746845617374)](https://camo.githubusercontent.com/d7a6726372a54d841514c462a06081fa3414908c/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f32303137313232343131353531313138363f77617465726d61726b2f322f746578742f6148523063446f764c324a736232637559334e6b626935755a585176635846664d7a417a4e7a6b324f446b3d2f666f6e742f3561364c354c32542f666f6e7473697a652f3430302f66696c6c2f49304a42516b46434d413d3d2f646973736f6c76652f37302f677261766974792f536f75746845617374)\n\n### [](https://github.com/AndroidHensen/BitmapCompress#%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B)创建工程\n\n1、创建一个新的项目，勾选包含C++，勾选C++11和C++的依赖库\n\n[![这里写图片描述](https://camo.githubusercontent.com/f2bf3e0a08da61ae9933e64f8e590bf8762f8230/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f32303137313232343132313532373530373f77617465726d61726b2f322f746578742f6148523063446f764c324a736232637559334e6b626935755a585176635846664d7a417a4e7a6b324f446b3d2f666f6e742f3561364c354c32542f666f6e7473697a652f3430302f66696c6c2f49304a42516b46434d413d3d2f646973736f6c76652f37302f677261766974792f536f75746845617374)](https://camo.githubusercontent.com/f2bf3e0a08da61ae9933e64f8e590bf8762f8230/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f32303137313232343132313532373530373f77617465726d61726b2f322f746578742f6148523063446f764c324a736232637559334e6b626935755a585176635846664d7a417a4e7a6b324f446b3d2f666f6e742f3561364c354c32542f666f6e7473697a652f3430302f66696c6c2f49304a42516b46434d413d3d2f646973736f6c76652f37302f677261766974792f536f75746845617374)\n\n2、将生成的 libjpeg.a和头文件导入到我们的项目中\n\n[![这里写图片描述](https://camo.githubusercontent.com/aea32742301afbd284bfaa8ee7c65b35fbb17081/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f32303137313232343132313432343139383f77617465726d61726b2f322f746578742f6148523063446f764c324a736232637559334e6b626935755a585176635846664d7a417a4e7a6b324f446b3d2f666f6e742f3561364c354c32542f666f6e7473697a652f3430302f66696c6c2f49304a42516b46434d413d3d2f646973736f6c76652f37302f677261766974792f536f75746845617374)](https://camo.githubusercontent.com/aea32742301afbd284bfaa8ee7c65b35fbb17081/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f32303137313232343132313432343139383f77617465726d61726b2f322f746578742f6148523063446f764c324a736232637559334e6b626935755a585176635846664d7a417a4e7a6b324f446b3d2f666f6e742f3561364c354c32542f666f6e7473697a652f3430302f66696c6c2f49304a42516b46434d413d3d2f646973736f6c76652f37302f677261766974792f536f75746845617374)\n\n3、配置gradle\n\n```\nandroid {\n    compileSdkVersion 25\n    buildToolsVersion \"25.0.3\"\n    defaultConfig {\n        applicationId \"com.handsome.bitmapcompress\"\n        minSdkVersion 16\n        targetSdkVersion 25\n        versionCode 1\n        versionName \"1.0\"\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n        externalNativeBuild {\n            cmake {\n                cppFlags \"-std=c++11 -frtti -fexceptions\"\n                //支持的CPU类型\n                abiFilters \"armeabi\", \"armeabi-v7a\"\n            }\n        }\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n    //修改Libs库的路径\n    sourceSets.main {\n        jniLibs.srcDirs = ['libs']\n        jni.srcDirs = []\n    }\n    externalNativeBuild {\n        cmake {\n            path \"CMakeLists.txt\"\n        }\n    }\n}\n\n```\n\n4、配置CMake\n\n```\ncmake_minimum_required(VERSION 3.4.1)\n\ninclude_directories(./libs/jpeg)\nlink_directories(./libs/${ANDROID_ABI})\n\nfind_library(log-lib\n             log)\nfind_library(android-lib\n             android)\nfind_library(bitmap-lib\n             jnigraphics)\n\nadd_library( # Sets the name of the library.\n             native-lib\n\n             # Sets the library as a shared library.\n             SHARED\n\n             # Provides a relative path to your source file(s).\n             src/main/cpp/native-lib.cpp )\n\ntarget_link_libraries( native-lib\n                       ${log-lib}\n                       ${android-lib}\n                       ${bitmap-lib}\n                       jpeg )\n\n```\n\n5、声明权限\n\n```\n<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n\n```\n\n### [](https://github.com/AndroidHensen/BitmapCompress#%E4%BD%BF%E7%94%A8libjpeg)使用LibJpeg\n\n1、启动选择文件的Intent\n\n```\n/**\n * 选择文件\n */\npublic void selectFile() {\n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.KITKAT) {\n        startActivityForResult(new Intent(Intent.ACTION_GET_CONTENT).setType(\"image/*\"), REQUEST_PICK_IMAGE);\n    } else {\n        Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);\n        intent.addCategory(Intent.CATEGORY_OPENABLE);\n        intent.setType(\"image/*\");\n        startActivityForResult(intent, REQUEST_KITKAT_PICK_IMAGE);\n    }\n}\n\n```\n\n2、对返回的结果进行压缩\n\n```\n/**\n * 返回结果\n *\n * @param requestCode\n * @param resultCode\n * @param data\n */\n@Override\npublic void onActivityResult(int requestCode, int resultCode, Intent data) {\n    super.onActivityResult(requestCode, resultCode, data);\n    if (resultCode == RESULT_OK) {\n        switch (requestCode) {\n            case REQUEST_PICK_IMAGE:\n                if (data != null) {\n                    Uri uri = data.getData();\n                    compressImage(uri);\n                }\n                break;\n            case REQUEST_KITKAT_PICK_IMAGE:\n                if (data != null) {\n                    Uri uri = ensureUriPermission(this, data);\n                    compressImage(uri);\n                }\n                break;\n        }\n    }\n}\n\n/**\n * 压缩图片\n * 注意：记得手动开启权限\n *\n * @param uri\n */\npublic void compressImage(Uri uri) {\n    try {\n        File saveFile = new File(getExternalCacheDir(), \"NDK压缩.jpg\");\n        Bitmap bitmap = MediaStore.Images.Media.getBitmap(getContentResolver(), uri);\n        int code = CompressUtils.compressBitmap(bitmap, 20, saveFile.getAbsolutePath().getBytes(), true);\n\n        File saveFile1 = new File(getExternalCacheDir(), \"质量压缩.jpg\");\n        CompressUtils.compressQuality(bitmap, 20, saveFile1);\n\n        File saveFile2 = new File(getExternalCacheDir(), \"尺寸压缩.jpg\");\n        CompressUtils.compressSize(bitmap, saveFile2);\n\n\t\t//采样率比较特殊，需要传递文件的目录，这里采用直接指定目录的文件\n        File saveFile3 = new File(getExternalCacheDir(), \"采样率压缩.jpg\");\n        File LocalFile = new File(\"/storage/emulated/0/DCIM/Camera/IMG_20171216_171956.jpg\");\n        if (LocalFile.exists()) {\n            CompressUtils.compressSample(LocalFile.getAbsolutePath(), saveFile3);\n        }\n\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n\n```\n\n3、加载本地库和声明LibJpeg压缩方法\n\n```\npublic class CompressUtils {\n\n    static {\n        System.loadLibrary(\"native-lib\");\n    }\n\n\tpublic static native int compressBitmap(Bitmap bitmap, int quality, byte[] fileNameBytes,\n\t                                            boolean optimize);\n}\n\n```\n\n4、编写LibJpeg的本地文件\n\n*   提取图片的ARGB通量的RGB通量\n*   采用LibJpeg的API进行压缩\n*   将数据写入到文件中\n\n```\n#include <jni.h>\n#include <string>\n#include <android/bitmap.h>\n#include <android/log.h>\n#include <setjmp.h>\n\nextern \"C\" {\n#include \"jpeglib.h\"\n#include \"cdjpeg.h\"\n}\n\n#define LOG_TAG \"jni\"\n#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)\n\ntypedef uint8_t BYTE;\n\ntypedef struct my_error_mgr *my_error_ptr;\nstruct my_error_mgr {\n    struct jpeg_error_mgr pub;\n    jmp_buf setjmp_buffer;\n};\n\nMETHODDEF(void)\nmy_error_exit(j_common_ptr cinfo) {\n    my_error_ptr myerr = (my_error_ptr) cinfo->err;\n    (*cinfo->err->output_message)(cinfo);\n    LOGE(\"jpeg_message_table[%d]:%s\", myerr->pub.msg_code,\n         myerr->pub.jpeg_message_table[myerr->pub.msg_code]);\n    longjmp(myerr->setjmp_buffer, 1);\n}\n\n/**\n * 采用Libjpeg压缩\n * @param data\n * @param w\n * @param h\n * @param quality\n * @param outfilename\n * @param optimize\n * @return\n */\nint generateJPEG(BYTE *data, int w, int h, int quality,\n                 const char *outfilename, jboolean optimize) {\n\n    //jpeg的结构体，保存的比如宽、高、位深、图片格式等信息\n    struct jpeg_compress_struct jcs;\n    //当读完整个文件的时候就会回调my_error_exit\n    struct my_error_mgr jem;\n    jcs.err = jpeg_std_error(&jem.pub);\n    jem.pub.error_exit = my_error_exit;\n    if (setjmp(jem.setjmp_buffer)) {\n        return 0;\n    }\n    //初始化jsc结构体\n    jpeg_create_compress(&jcs);\n    //打开输出文件\n    FILE* f = fopen(outfilename, \"wb\");\n    if (f == NULL) {\n        return 0;\n    }\n    //设置结构体的文件路径\n    jpeg_stdio_dest(&jcs, f);\n    jcs.image_width = w;//设置宽高\n    jcs.image_height = h;\n    //设置哈夫曼编码，TRUE=arithmetic coding, FALSE=Huffman\n\tif (optimize) {\n        jcs.arith_code = false;\n\t} else {\n        jcs.arith_code = true;\n\t}\n    //颜色通道数量\n    int nComponent = 3;\n    jcs.input_components = nComponent;\n    //设置结构体的颜色空间为RGB\n    jcs.in_color_space = JCS_RGB;\n    //全部设置默认参数\n    jpeg_set_defaults(&jcs);\n    //是否采用哈弗曼表数据计算 品质相差5-10倍\n    jcs.optimize_coding = optimize;\n    //设置质量\n    jpeg_set_quality(&jcs, quality, true);\n    //开始压缩，(是否写入全部像素)\n    jpeg_start_compress(&jcs, TRUE);\n\n    JSAMPROW row_pointer[1];\n    int row_stride;\n    //一行的RGB数量\n    row_stride = jcs.image_width * nComponent;\n    //一行一行遍历\n    while (jcs.next_scanline < jcs.image_height) {\n        //得到一行的首地址\n        row_pointer[0] = &data[jcs.next_scanline * row_stride];\n        //此方法会将jcs.next_scanline加1\n        jpeg_write_scanlines(&jcs, row_pointer, 1);//row_pointer就是一行的首地址，1：写入的行数\n    }\n    jpeg_finish_compress(&jcs);\n    jpeg_destroy_compress(&jcs);\n    fclose(f);\n    return 1;\n}\n\n/**\n * byte数组转C的字符串\n */\nchar *jstrinTostring(JNIEnv *env, jbyteArray barr) {\n    char *rtn = NULL;\n    jsize alen = env->GetArrayLength(barr);\n    jbyte *ba = env->GetByteArrayElements(barr, 0);\n    if (alen > 0) {\n        rtn = (char *) malloc(alen + 1);\n        memcpy(rtn, ba, alen);\n        rtn[alen] = 0;\n    }\n    env->ReleaseByteArrayElements(barr, ba, 0);\n    return rtn;\n}\n\nextern \"C\"\nJNIEXPORT jint JNICALL\nJava_com_handsome_bitmapcompress_CompressUtils_compressBitmap(JNIEnv *env, jclass type,\n                                                              jobject bitmap,\n                                                              jint quality,\n                                                              jbyteArray fileNameBytes_,\n                                                              jboolean optimize) {\n    //获取Bitmap信息\n    AndroidBitmapInfo android_bitmap_info;\n    AndroidBitmap_getInfo(env, bitmap, &android_bitmap_info);\n    //获取bitmap的 宽，高，format\n    int w = android_bitmap_info.width;\n    int h = android_bitmap_info.height;\n    int format = android_bitmap_info.format;\n\n    if (format != ANDROID_BITMAP_FORMAT_RGBA_8888) {\n        return -1;\n    }\n\n    //存储ARGB所有像素点\n    BYTE *pixelsColor;\n    //1、读取Bitmap所有像素信息\n    AndroidBitmap_lockPixels(env, bitmap, (void **) &pixelsColor);\n    //2、解析每个像素，去除A通量，取出RGB通量\n    int i = 0, j = 0;\n    BYTE a, r, g, b;\n    //存储RGB所有像素点\n    BYTE *data;\n    data = (BYTE *) malloc(w * h * 3);\n    //存储RGB首地址\n    BYTE *tempData = data;\n\n    int color;\n    for (i = 0; i < h; ++i) {\n        for (j = 0; j < w; ++j) {\n            //将8位通道转成32位通道\n            color = *((int *) pixelsColor);\n            //取值\n            a = ((color & 0xFF000000) >> 24);\n            r = ((color & 0x00FF0000) >> 16);\n            g = ((color & 0x0000FF00) >> 8);\n            b = ((color & 0x000000FF));\n            //赋值\n            *data = b;\n            *(data + 1) = g;\n            *(data + 2) = r;\n            //指针往后移\n            data += 3;\n            pixelsColor += 4;\n        }\n    }\n\n    //3、读取像素点完毕\n    AndroidBitmap_unlockPixels(env, bitmap);\n    char *fileName = jstrinTostring(env, fileNameBytes_);\n    //4、采用Libjpeg进行压缩\n    int resultCode = generateJPEG(tempData, w, h, quality, fileName, optimize);\n    if (resultCode == 0) {\n        return 0;\n    }\n    return 1;\n}\n```"]],[0,0],[15608,15608]]]]]]}