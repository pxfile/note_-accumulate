{"compress":true,"commitItems":[["3bc0ea3e-322a-406c-8ec5-6f16c3faaa1b",1520926801111,"",[[1520926767559,["gengmei_pxf@gengmei123.local",[[1,0,"反射技术在android中的应用\n===\n\n\n### **动态语言：**\n\n一般认为在程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言。从这个观点看，Perl，Python，Ruby是动态语言，C++，Java，C#不是动态语言。尽管这样，JAVA有着一个非常突出的动态相关机制：反射（Reflection）。运用反射我们可以于运行时加载、探知、使用编译期间完全未知的classes。换句话说，Java程序可以加载在运行时才得知名称的class，获悉其完整构造方法，并生成其对象实体、或对其属性设值、或唤起其成员方法。\n\n### **反射：**\n\n要让Java程序能够运行，就得让Java类被Java虚拟机加载。Java类如果不被Java虚拟机加载就不能正常运行。正常情况下，我们运行的所有的程序在编译期时候就已经把那个类被加载了。 Java的反射机制是在编译时并不确定是哪个类被加载了，而是在程序运行的时候才加载。使用的是在编译期并不知道的类。这样的编译特点就是java反射。\n\n### **反射的作用:**\n\n如果有AB两个程序员合作，A在写程序的时需要使用B所写的类，但B并没完成他所写的类。那么A的代码是不能通过编译的。此时，利用Java反射的机制，就可以让A在没有得到B所写的类的时候，来使自身的代码通过编译。\n\n### **反射的实质:**\n\n反射就是把Java类中的各种存在给解析成相应的Java类。要正确使用Java反射机制就得使用Class（C大写） 这个类。它是Java反射机制的起源。当一个类被加载以后，Java虚拟机就会自动产生一个Class对象。通过这个Class对象我们就能获得加载到虚拟机当中这个Class对象对应的方法、成员以及构造方法的声明和定义等信息。\n\n### **反射机制的优点与缺点:**\n\n为什么要用反射机制？直接创建对象不就可以了吗，这就涉及到了动态与静态的概念: \n静态编译：在编译时确定类型，绑定对象,即通过。 \n动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了java的灵活性，体现了多态的应用，降低类之间的藕合性。 \n一句话，反射机制的优点就是可以实现动态创建对象和编译，体现出很大的灵活性，特别是在J2EE的开发中它的灵活性就表现的十分明显。比如，一个大型的软件，不可能一次就把把它设计的很完美，当这个程序编译后，发布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用安装，只需要在运行时才动态的创建和编译，就可以实现该功能。它的缺点是对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于只直接执行相同的操作。\n\n* * *\n\n### **Android FrameWork中的反射:**\n\n一个类中的每个成员都可以用相应的反射API的一个实例对象来表示——反射机制。 \n了解这些，那我们就知道了，我们可以利用反射机制在Java程序中，动态的去调用一些protected甚至是private的方法或类，这样可以很大程度上满足我们的一些比较特殊需求。例如Activity的启动过程中Activity的对象的创建。\n\n以下代码位于ActivityThread中：\n\n```\nprivate Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n\n        。。。。。。\n        Activity activity = null;\n        try {\n            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();\n            activity = mInstrumentation.newActivity(\n                    cl, component.getClassName(), r.intent);\n            StrictMode.incrementExpectedActivityCount(activity.getClass());\n            r.intent.setExtrasClassLoader(cl);\n            r.intent.prepareToEnterProcess();\n            if (r.state != null) {\n                r.state.setClassLoader(cl);\n            }\n        } \n        。。。。。。\n```\n\n上面代码可知Activity在创建对象的时候调用了mInstrumentation.newActivity(); \n以下代码位于Instrumentation中：\n\n```\n    public Activity newActivity(ClassLoader cl, String className,\n            Intent intent)\n            throws InstantiationException, IllegalAccessException,\n            ClassNotFoundException {\n            //这里的className就是在manifest中注册的Activity name.\n        return (Activity)cl.loadClass(className).newInstance();\n    }\n```\n\n最终在newActivity()里返回的是利用cl.loadClass返回的Activity对象。可知，Activity对象的创建是通过反射完成的。java程序可以动态加载类定义，而这个动态加载的机制就是通过ClassLoader来实现的，所以可想而知ClassLoader的重要性如何。 \n\n### **ClassLoader和DexClassLoader**\n\n上面说到JAVA的动态加载的机制就是通过ClassLoader来实现的，ClassLoader也是实现反射的基石。ClassLoader是JAVA提供的一个类，顾名思义，它就是用来加载Class文件到JVM，以供程序使用的。\n\n但是问题来了，ClassLoader加载文件到JVM，但是Android是基于DVM的，用ClassLoader加载文件进DVM肯定是不行的。于是Android提供了另外一套加载机制，分别为 dalvik.system.DexClassLoader 和 dalvik.system.PathClassLoader，区别在于 PathClassLoader 不能直接从 zip 包中得到 dex，因此只支持直接操作 dex 文件或者已经安装过的 apk（因为安装过的 apk 在 cache 中存在缓存的 dex 文件）。而 DexClassLoader 可以加载外部的 apk、jar 或 dex文件，并且会在指定的 outpath 路径存放其 dex 文件。\n\n### **ClassLoader在JAVA中的应用**\n\n下面利用反射来调用另一个类中的方法\n\n```\n//定义一个测试类，用来被反射调用\npackage com.izzy;\npublic class Test {\n    private String s;\n    //构造方法\n    public Test(String s) {\n        this.s = s;\n    }\n    //定义一个方法，用来输出，构造方法中传递进来的参数\n    public void display() {\n        System.out.println(s);\n    }\n\n}\n\n```\n\n```\npackage com.izzy;\nimport java.lang.reflect.Constructor;\n\npublic class Client {\n\n    public static void main(String[] s) {\n        try {\n        //首先拿到系统ClassLoader，并加载Class，返回的是一个Class对象clazz \n            Class clazz = ClassLoader.getSystemClassLoader().loadClass(\n                    \"com.izzy.Test\");\n        //通过clazz 拿到构造方法并转换成对象\n            Constructor constructor = clazz.getConstructor(String.class);\n            Object obj = constructor.newInstance(\"I AM IZZY\");\n        //通过clazz 拿到成员方法\n            Method method = clazz.getMethod(\"display\", null);\n            method.invoke(obj, null);\n        } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n\n}\n\n```\n\n![这里写图片描述](http://img.blog.csdn.net/20160617160312603)\n\n### **DexClassLoader在Android中的应用**\n\n以一个例子来说明DexClassLoader用法（本例采用两个已安装的Apk），现在有两个Apk：Share和Test，利用Test来调用Share 里面的方法。\n\n首先在Share　apk中定义Share类，其中有一个display()方法提供给远程调用\n\n```\npublic class Share {\n    public void display(String s) {\n        Log.e(\"IZZY\", s);\n    }\n\n}\n```\n\n接着在manifest文件中配置action和category，方便调用这找到\n\n```\n  <activity\n            android:name=\".MainActivity\"\n            android:theme=\"@android:style/Theme.Light.NoTitleBar\">\n            <intent-filter>\n                <action android:name=\"com.IZZY\"/>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n```\n\n接下来就是在Test Apk中编写调用代码了\n\n```\n public void getFromRemote() {\n        Intent intent = new Intent(\"com.IZZY\");\n        PackageManager pm = getPackageManager();\n        List<ResolveInfo> resolveInfos = pm.queryIntentActivities(intent, 0);\n\n        ResolveInfo resolveInfo = resolveInfos.get(0);\n        ActivityInfo activityInfo = resolveInfo.activityInfo;\n        //拿到目标类的包名\n        String packageName = activityInfo.packageName;\n\n        //拿到目标类所在的apk或者jar存放的路径\n        String dexPath = activityInfo.applicationInfo.sourceDir;\n        //该路径为拿到目标类dex文件存放在调用者里的路径\n        String dexOutputDir = getApplicationInfo().dataDir;\n        //拿到目标类所使用的C/C++库存放路径\n        String nativeLibraryDir = activityInfo.applicationInfo.nativeLibraryDir;\n        //拿到类装载器\n        ClassLoader classLoader = getClassLoader();\n\n        //DexClassLoader参数分别对应以上四个参数\n        DexClassLoader dcl = new DexClassLoader(dexPath,dexOutputDir,nativeLibraryDir,classLoader);\n        try {\n            //装载目标类\n            Class<?> clazz = dcl.loadClass(packageName + \".Share\");\n            //拿到构造器并实例化对象\n            Constructor<?> constructor = clazz.getConstructor();\n            Object o = constructor.newInstance();\n            //拿到成员方法\n            Method display = clazz.getMethod(\"display\", String.class);\n            display.invoke(o, \"I AM IZZY\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n在该调用方法中首先利用Intent查询到目标activityInfo，然后利用查询到的activityInfo得到目标Apk的包名，目标Apk所在的apk或者jar存放的路径dexPath，目标Apk所使用的C/C++库存放路径nativeLibraryDir。然后利用这些参数实例化DexClassLoader加载器。之后反射调用目标类中的方法。\n（ps：此处使用的目标Apk是已经安装过的，因此采用Intent查询来拿到dexPath和nativeLibraryDir，如果是未安装过的jar包或Apk，则直接传入该jar包活Apk的文件存放路径和C/C++库存放路径）。 \n\n运行结果： \n![这里写图片描述](http://img.blog.csdn.net/20160630133339862) \n从结果看，调用者Apk拿到了目标Apk的方法并成功执行。\n\n### **DexClassLoaderde 在Android中的使用场景**\n\n上面是是使用的已经安装过的Apk，如果采用未安装过的jar包或者Apk，则实例化DexClassLoader的时候把相应路径改为需要加载的jar包或者Apk路径亦可拿到结果。这就使得DexClassLoaderde可以应用在HotFix（热修复），动态加载框架等等 一些基于插件化的架构中。"]],[0,0],[6964,6964]]],[1520926790762,["gengmei_pxf@gengmei123.local",[[-1,25,"#"],[1,37,""],[-1,811," "],[1,812," "],[-1,836," "],[1,837," "],[-1,895," "],[1,896," "],[-1,1289," "],[1,1290," "],[-1,2124," "],[1,2125," "],[-1,2627," "],[1,2628," "],[-1,6682," "],[1,6683," "],[-1,6690," "],[1,6691," "],[-1,6746," "],[1,6747," "]],[24,24],[23,23]]],[1520926795501,["gengmei_pxf@gengmei123.local",[[-1,268,"#"]],[267,267],[266,266]]],[1520926797798,["gengmei_pxf@gengmei123.local",[[-1,447,"#"]],[448,448],[447,447]]],[1520926801046,["gengmei_pxf@gengmei123.local",[[-1,567,"#"]],[567,567],[566,566]]],[1520926803796,["gengmei_pxf@gengmei123.local",[[-1,750,"#"]],[749,749],[748,748]]],[1520926810332,["gengmei_pxf@gengmei123.local",[[-1,1216,"#"]],[1215,1215],[1214,1214]]],[1520926820806,["gengmei_pxf@gengmei123.local",[[-1,2626,"#"]],[2626,2626],[2625,2625]]],[1520926824732,["gengmei_pxf@gengmei123.local",[[-1,3107,"#"]],[3106,3106],[3105,3105]]],[1520926828170,["gengmei_pxf@gengmei123.local",[[-1,4200,"#"]],[4200,4200],[4199,4199]]],[1520926831740,["gengmei_pxf@gengmei123.local",[[-1,6771,"#"]],[6772,6772],[6771,6771]]],[1520926899997,["gengmei_pxf@gengmei123.local",[[1,21,"### 什么是反射机制\n\n> 个人理解就是通过反编译获取类中所有的信息(包括：变量、方法、接口)，供开发者利用。\n\n### 优缺点\n\n优点：增强代码的自适应能力(动态的创建对象)、调用一些类中的私有方法(例如通过反射机制调用android[系统](https://www.2cto.com/os/)挂断电话的方法)。\n\n缺点：降低程序性能。牛逼的背后总是苦逼，反射机制说白了就是通过类名去解释类，然后告诉jvm我们需要做什么，肯定比jvm执行固定代码要耗时耗资源。"]],[21,21],[253,253]]],[1520926902616,["gengmei_pxf@gengmei123.local",[[-1,23,"#"]],[24,24],[23,23]]],[1520926906611,["gengmei_pxf@gengmei123.local",[[-1,33,"> "]],[35,35],[33,33]]],[1520926917066,["gengmei_pxf@gengmei123.local",[[1,1037,"* "]],[1037,1037],[1039,1039]]],[1520926918947,["gengmei_pxf@gengmei123.local",[[1,1064,"* "]],[1064,1064],[1066,1066]]],[1520926923503,["gengmei_pxf@gengmei123.local",[[1,1125,"\n"]],[1125,1125],[1126,1126]]],[1520926934454,["gengmei_pxf@gengmei123.local",[[1,1126,"\n"]],[1125,1125],[1126,1126]]],[1520926939141,["gengmei_pxf@gengmei123.local",[[1,1126,"### 有点"]],[1126,1126],[1132,1132]]],[1520926941074,["gengmei_pxf@gengmei123.local",[[-1,1130,"有点"]],[1132,1132],[1130,1130]]],[1520926943800,["gengmei_pxf@gengmei123.local",[[1,1130,"优点"]],[1130,1130],[1132,1132]]],[1520926948391,["gengmei_pxf@gengmei123.local",[[1,1372,"\n"]],[1372,1372],[1373,1373]]],[1520926948733,["gengmei_pxf@gengmei123.local",[[1,1373,"\n"]],[1373,1373],[1374,1374]]],[1520926950206,["gengmei_pxf@gengmei123.local",[[1,1374,"\n"]],[1373,1373],[1374,1374]]],[1520926951987,["gengmei_pxf@gengmei123.local",[[1,1374,"### "]],[1374,1374],[1378,1378]]],[1520926954087,["gengmei_pxf@gengmei123.local",[[1,1378,"缺点"]],[1378,1378],[1380,1380]]],[1520926968399,["gengmei_pxf@gengmei123.local",[[1,85,"* "]],[85,85],[87,87]]],[1520926970989,["gengmei_pxf@gengmei123.local",[[1,180,"* "]],[180,180],[182,182]]],[1520926985756,["gengmei_pxf@gengmei123.local",[[1,21,"\n"]],[20,20],[21,21]]],[1520926995374,["gengmei_pxf@gengmei123.local",[[1,21,"【】"]],[21,21],[23,23]]],[1520926996212,["gengmei_pxf@gengmei123.local",[[-1,21,"【】"]],[23,23],[21,21]]],[1520926997790,["gengmei_pxf@gengmei123.local",[[1,21,"[]()"]],[21,21],[25,25]]],[1520926999879,["gengmei_pxf@gengmei123.local",[[1,24,"java/android中的反射机制"]],[24,24],[42,42]]],[1520927001094,["gengmei_pxf@gengmei123.local",[[-1,24,"java/android中的反射机制"]],[42,42],[24,24]]],[1520927002717,["gengmei_pxf@gengmei123.local",[[1,22,"java/android中的反射机制"]],[22,22],[40,40]]],[1520927010389,["gengmei_pxf@gengmei123.local",[[1,42,"https://www.2cto.com/kf/201709/676771.html"]],[42,42],[84,84]]],[1520927014106,["gengmei_pxf@gengmei123.local",[[1,86,"\n"]],[85,85],[86,86]]]]]]}