{"compress":true,"commitItems":[["00460ab2-8a45-4b7d-a961-70dbe8f4d4dc",1520923016278,"",[[1520922979424,["gengmei_pxf@gengmei123.local",[[1,0,"Android之设计模式六大原则\n===\n\n\n1.  [设计模式六大原则1单一职责原则](http://blog.csdn.net/yubo_725/article/details/45037407#t0)\n2.  [设计模式六大原则2里氏替换原则](http://blog.csdn.net/yubo_725/article/details/45037407#t1)\n3.  [设计模式六大原则3依赖倒置原则](http://blog.csdn.net/yubo_725/article/details/45037407#t2)\n4.  [设计模式六大原则4接口隔离原则](http://blog.csdn.net/yubo_725/article/details/45037407#t3)\n5.  [设计模式六大原则5迪米特法则](http://blog.csdn.net/yubo_725/article/details/45037407#t4)\n6.  [设计模式六大原则6开闭原则](http://blog.csdn.net/yubo_725/article/details/45037407#t5)"]],[0,0],[505,505]]],[1520923007675,["gengmei_pxf@gengmei123.local",[[1,505,"\n\n"]],[505,505],[506,506]]],[1520923007922,["gengmei_pxf@gengmei123.local",[[1,507,"\n"]],[506,506],[507,507]]],[1520923039564,["gengmei_pxf@gengmei123.local",[[1,507,"# 单一职责原则\n\n定义：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。 \n问题由来：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。\n\n解决方案：遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险"]],[507,507],[730,730]]],[1520923044396,["gengmei_pxf@gengmei123.local",[[1,508,"#"],[-1,554," "],[1,555," "]],[508,508],[509,509]]],[1520923048513,["gengmei_pxf@gengmei123.local",[[1,732,"\n"]],[731,731],[732,732]]],[1520923048905,["gengmei_pxf@gengmei123.local",[[1,733,"\n"]],[732,732],[733,733]]],[1520923123522,["gengmei_pxf@gengmei123.local",[[1,733,"遵循单一职责原的优点有：\n\n*   可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；\n*   提高类的可读性，提高系统的可维护性；\n*   变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。"]],[733,733],[872,872]]],[1520923246769,["gengmei_pxf@gengmei123.local",[[1,873,"\n"]],[872,872],[873,873]]],[1520923247191,["gengmei_pxf@gengmei123.local",[[1,874,"\n"]],[873,873],[874,874]]],[1520923793684,["gengmei_pxf@gengmei123.local",[[1,874,"# 里氏替换原则\n\n肯定有不少人跟我刚看到这项原则的时候一样，对这个原则的名字充满疑惑。其实原因就是这项原则最早是在1988年，由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。\n\n定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。\n\n定义2：所有引用基类的地方必须能透明地使用其子类的对象。"]],[874,874],[1115,1115]]],[1520923796474,["gengmei_pxf@gengmei123.local",[[1,875,"#"]],[875,875],[876,876]]],[1520923804049,["gengmei_pxf@gengmei123.local",[[-1,885,"肯定有不少人跟我刚看到这项原则的时候一样，对这个原则的名字充满疑惑。其实原因就是"]],[885,925],[885,885]]],[1520923810912,["gengmei_pxf@gengmei123.local",[[1,1077,"\n"]],[1076,1076],[1077,1077]]],[1520923811704,["gengmei_pxf@gengmei123.local",[[1,1078,"\n"]],[1077,1077],[1078,1078]]],[1520923839032,["gengmei_pxf@gengmei123.local",[[1,1078,"里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：\n\n*   子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。\n*   子类中可以增加自己特有的方法。\n*   当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。\n*   当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。"]],[1078,1078],[1277,1277]]],[1520923848680,["gengmei_pxf@gengmei123.local",[[1,937,"* "]],[937,937],[939,939]]],[1520923850878,["gengmei_pxf@gengmei123.local",[[1,1050,"* "]],[1050,1050],[1052,1052]]],[1520923856597,["gengmei_pxf@gengmei123.local",[[1,1282,"\n"]],[1281,1281],[1282,1282]]],[1520923856942,["gengmei_pxf@gengmei123.local",[[1,1283,"\n"]],[1282,1282],[1283,1283]]],[1520923858783,["gengmei_pxf@gengmei123.local",[[-1,1283,"\n"],[1,1284,"## "]],[1283,1283],[1286,1286]]],[1520924233144,["gengmei_pxf@gengmei123.local",[[1,1286,"# 依赖倒置原则\n\n定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。\n\n问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。\n\n解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。"]],[1286,1286],[1522,1522]]],[1520924234925,["gengmei_pxf@gengmei123.local",[[-1,1286,"# "]],[1288,1288],[1286,1286]]],[1520924259412,["gengmei_pxf@gengmei123.local",[[1,1520,"\n\n"]],[1520,1520],[1521,1521]]],[1520924259779,["gengmei_pxf@gengmei123.local",[[1,1522,"\n"]],[1521,1521],[1522,1522]]],[1520924260119,["gengmei_pxf@gengmei123.local",[[1,1522,"在实际编程中，我们一般需要做到如下3点：\n\n*   低层模块尽量都要有抽象类或接口，或者两者都有。\n*   变量的声明类型尽量是抽象类或接口。\n*   使用继承时遵循里氏替换原则。\n\n依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。"]],[1522,1522],[1655,1655]]],[1520924462619,["gengmei_pxf@gengmei123.local",[[1,1656,"\n"]],[1655,1655],[1656,1656]]],[1520924462862,["gengmei_pxf@gengmei123.local",[[1,1657,"\n"]],[1656,1656],[1657,1657]]],[1520924464287,["gengmei_pxf@gengmei123.local",[[1,1657,"# 接口隔离原则\n\n定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 \n问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。\n\n解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。"]],[1657,1657],[1840,1840]]],[1520924466232,["gengmei_pxf@gengmei123.local",[[1,1658,"￥"],[-1,1709," "],[1,1710," "]],[1658,1658],[1659,1659]]],[1520924466939,["gengmei_pxf@gengmei123.local",[[-1,1658,"￥"]],[1659,1659],[1658,1658]]],[1520924467461,["gengmei_pxf@gengmei123.local",[[1,1658,"#"]],[1658,1658],[1659,1659]]],[1520924470451,["gengmei_pxf@gengmei123.local",[[1,1842,"\n"]],[1841,1841],[1842,1842]]],[1520924471130,["gengmei_pxf@gengmei123.local",[[1,1843,"\n"]],[1842,1842],[1843,1843]]],[1520924493662,["gengmei_pxf@gengmei123.local",[[1,1843,"采用接口隔离原则对接口进行约束时，要注意以下几点：\n\n*   接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。\n*   为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。\n*   提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。\n\n运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。"]],[1843,1843],[2119,2119]]],[1520924499993,["gengmei_pxf@gengmei123.local",[[1,2120,"\n"]],[2119,2119],[2120,2120]]],[1520924500329,["gengmei_pxf@gengmei123.local",[[1,2121,"\n"]],[2120,2120],[2121,2121]]],[1520924664383,["gengmei_pxf@gengmei123.local",[[1,2121,"# 迪米特法则\n\n定义：一个对象应该对其他对象保持最少的了解。\n\n问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。\n\n解决方案：尽量降低类与类之间的耦合。\n\n自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。"]],[2121,2121],[2300,2300]]],[1520924666558,["gengmei_pxf@gengmei123.local",[[1,2122,"#"]],[2122,2122],[2123,2123]]],[1520925111075,["gengmei_pxf@gengmei123.local",[[1,2302,"\n"]],[2301,2301],[2302,2302]]],[1520925111510,["gengmei_pxf@gengmei123.local",[[1,2303,"\n"]],[2302,2302],[2303,2303]]],[1520925114046,["gengmei_pxf@gengmei123.local",[[-1,2303,"\n"],[1,2304,"## # 开闭原则\n\n定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。\n\n问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。\n\n解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。\n\n开闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统。开闭原则可能是设计模式六项原则中定义最模糊的一个了，它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确的告诉我们。"]],[2303,2303],[2608,2608]]],[1520925116946,["gengmei_pxf@gengmei123.local",[[-1,2306,"# "]],[2308,2308],[2306,2306]]],[1520925180633,["gengmei_pxf@gengmei123.local",[[1,2606,"\n\n"]],[2606,2606],[2607,2607]]],[1520925181032,["gengmei_pxf@gengmei123.local",[[1,2608,"\n"]],[2607,2607],[2608,2608]]],[1520925183733,["gengmei_pxf@gengmei123.local",[[-1,2608,"\n"],[1,2609,"【】"]],[2608,2608],[2610,2610]]],[1520925184498,["gengmei_pxf@gengmei123.local",[[-1,2608,"【】"]],[2610,2610],[2608,2608]]],[1520925186200,["gengmei_pxf@gengmei123.local",[[1,2608,"\n\n"]],[2608,2608],[2609,2609]]],[1520925188783,["gengmei_pxf@gengmei123.local",[[-1,2609,"\n"],[1,2610,"![]()"]],[2609,2609],[2614,2614]]],[1520925190331,["gengmei_pxf@gengmei123.local",[[1,2613,"http://www.uml.org.cn/sjms/images/2012110233.jpg"]],[2613,2613],[2661,2661]]],[1520925198684,["gengmei_pxf@gengmei123.local",[[1,2611,"6da"]],[2611,2611],[2614,2614]]],[1520925199712,["gengmei_pxf@gengmei123.local",[[-1,2612,"da"]],[2614,2614],[2612,2612]]],[1520925202810,["gengmei_pxf@gengmei123.local",[[1,2612,"大原则"]],[2612,2612],[2615,2615]]]]]]}