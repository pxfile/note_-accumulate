{"compress":true,"commitItems":[["6ea20e7a-6d70-4b77-a94c-65bd72365c87",1519976249209,"",[[1519976202534,["gengmei_pxf@gengmei123.local",[[1,0,"版权声明：本文为博主原创文章，未经博主允许不得转载。\n\n目录[(?)](http://blog.csdn.net/u010983881/article/details/79050209 \"系统根据文章中H1到H6标签自动生成文章目录\")[[+]](http://csdnimg.cn/release/phoenix/# \"展开\")\n\n![](https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/master/gallery/algorithms/lru.png)\n\n### 一、Android中的缓存策略\n\n一般来说，缓存策略主要包含缓存的添加、获取和删除这三类操作。如何添加和获取缓存这个比较好理解，那么为什么还要删除缓存呢？这是因为不管是内存缓存还是硬盘缓存，它们的缓存大小都是有限的。当缓存满了之后，再想其添加缓存，这个时候就需要删除一些旧的缓存并添加新的缓存。\n\n因此LRU(**Least Recently Used**)缓存算法便应运而生，LRU是近期最少使用的算法，它的核心思想是当缓存满时，会优先淘汰那些近期最少使用的缓存对象，有效的避免了OOM的出现。在Android中采用LRU算法的常用缓存有两种：[LruCache](https://developer.android.com/reference/android/util/LruCache.html)和DisLruCache，分别用于实现内存缓存和硬盘缓存，其核心思想都是LRU缓存算法。\n\n其实LRU缓存的实现类似于一个特殊的栈，把访问过的元素放置到栈顶（若栈中存在，则更新至栈顶；若栈中不存在则直接入栈），然后如果栈中元素数量超过限定值，则删除栈底元素（即最近最少使用的元素）。详细算法实现如下图：\n\n![](https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/master/gallery/algorithms/1337859321_3597.png)\n\n1.  新数据压入到栈顶；\n2.  每当缓存命中（即缓存数据被访问），则将数据移到栈顶；\n3.  当栈满的时候，将栈底的数据丢弃。\n\n举个例子演示一下：\n\n![](https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/master/gallery/algorithms/lru-timg.jpg)\n\n### 二、LruCache的使用\n\n`LruCache`是Android 3.1所提供的一个缓存类，所以在Android中可以直接使用LruCache实现内存缓存。而DisLruCache目前在Android 还不是Android SDK的一部分，但Android官方文档推荐使用该算法来实现硬盘缓存。\n\n讲到`LruCache`不得不提一下`LinkedHashMap`，因为LruCache中Lru算法的实现就是通过`LinkedHashMap`来实现的。`LinkedHashMap`继承于`HashMap`，它使用了一个双向链表来存储Map中的Entry顺序关系，这种顺序有两种，一种是**LRU顺序**，一种是**插入顺序**，这可以由其构造函数`public LinkedHashMap(int initialCapacity,float loadFactor, boolean accessOrder)`的最后一个参数`accessOrder`来指定。所以，对于get、put、remove等操作，`LinkedHashMap`除了要做`HashMap`做的事情，还做些调整Entry顺序链表的工作。`LruCache`中将`LinkedHashMap`的顺序设置为LRU顺序来实现LRU缓存，每次调用get(也就是从内存缓存中取图片)，则将该对象移到链表的尾端。调用put插入新的对象也是存储在链表尾端，这样当内存缓存达到设定的最大值时，将链表头部的对象（近期最少用到的）移除。关于LinkedHashMap详解请前往：[理解LinkedHashMap](http://www.cnblogs.com/children/archive/2012/10/02/2710624.html)\n\n![](https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/master/gallery/algorithms/lru-cache.png)\n\n#### LruCache使用示例\n\nLruCache的使用非常简单，我们就以图片缓存为例：\n\n```java\nint maxMemory = (int) (Runtime.getRuntime().totalMemory()/1024);\nint cacheSize = maxMemory/8;\nmMemoryCache = new LruCache<String,Bitmap>(cacheSize){\n    @Override\n    protected int sizeOf(String key, Bitmap value) {\n        return value.getRowBytes()*value.getHeight()/1024;\n    }\n};12345678\n```\n\n① 设置LruCache缓存的大小，一般为当前进程可用容量的1/8。 \n② 重写sizeOf方法，计算出要缓存的每张图片的大小。\n\n**注意：**缓存的总容量和每个缓存对象的大小所用单位要一致。\n\n#### LruCache的实现原理\n\nLruCache的核心思想很好理解，就是要维护一个缓存对象列表，其中对象列表的排列方式是按照访问顺序实现的，即一直没访问的对象，将放在队尾，即将被淘汰。而最近访问的对象将放在队头，最后被淘汰。如下图所示：\n\n![](https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/master/gallery/algorithms/3985563-33560a9500e72780.png)\n\n那么这个队列到底是由谁来维护的，前面已经介绍了是由LinkedHashMap来维护。\n\n而LinkedHashMap是由数组+双向链表的数据结构来实现的。其中双向链表的结构可以实现访问顺序和插入顺序，使得LinkedHashMap中的\n\n```java\n/**\n * Constructs a new {@code LinkedHashMap} instance with the specified\n * capacity, load factor and a flag specifying the ordering behavior.\n *\n * @param initialCapacity\n *            the initial capacity of this hash map.\n * @param loadFactor\n *            the initial load factor.\n * @param accessOrder\n *            {@code true} if the ordering should be done based on the last\n *            access (from least-recently accessed to most-recently\n *            accessed), and {@code false} if the ordering should be the\n *            order in which the entries were inserted.\n */\npublic LinkedHashMap(\n        int initialCapacity, float loadFactor, boolean accessOrder) {\n    super(initialCapacity, loadFactor);\n    init();\n    this.accessOrder = accessOrder;\n}1234567891011121314151617181920\n```\n\n其中`accessOrder`设置为true则为**访问顺序**，为false，则为**插入顺序**。\n\n以具体例子解释，当设置为true时：\n\n```java\npublic static final void main(String[] args) {\n    LinkedHashMap<Integer, Integer> map = new LinkedHashMap<>(0, 0.75f, true);\n    map.put(0, 0);\n    map.put(1, 1);\n    map.put(2, 2);\n    map.put(3, 3);\n    map.put(4, 4);\n    map.put(5, 5);\n    map.put(6, 6);\n    map.get(1);     //访问1\n    map.get(2);     //访问2\n\n    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n        System.out.println(entry.getKey() + \":\" + entry.getValue());\n    }\n}12345678910111213141516\n```\n\n输出结果如下：\n\n> 0:0 \n> 3:3 \n> 4:4 \n> 5:5 \n> 6:6 \n> 1:1 \n> 2:2\n\n即最近访问的对象会被放到队尾，然后最后输出，那么这就正好满足的LRU缓存算法的思想。**可见LruCache巧妙实现，就是利用了LinkedHashMap的这种数据结构。**\n\n下面我们在LruCache源码中具体看看，怎么应用LinkedHashMap来实现缓存的添加，获得和删除的。\n\n### LruCache源码分析\n\n我们先看看成员变量有哪些：\n\n```java\npublic class LruCache<K, V> {\n    private final LinkedHashMap<K, V> map;\n\n    /** Size of this cache in units. Not necessarily the number of elements. */\n    private int size;   //当前cache的大小\n    private int maxSize;     //cache最大大小\n\n    private int putCount;       //put的次数\n    private int createCount;    //create的次数\n    private int evictionCount;  //驱逐剔除的次数\n    private int hitCount;       //命中的次数\n    private int missCount;      //未命中次数\n\n    //...省略...\n}123456789101112131415\n```\n\n构造函数如下，可以看到LruCache正是用了LinkedHashMap的`accessOrder=true`构造参数实现LRU访问顺序：\n\n```java\npublic LruCache(int maxSize) {\n    if (maxSize <= 0) {\n        throw new IllegalArgumentException(\"maxSize <= 0\");\n    }\n    this.maxSize = maxSize;\n    //将LinkedHashMap的accessOrder设置为true来实现LRU顺序\n    this.map = new LinkedHashMap<K, V>(0, 0.75f, true);\n}12345678\n```\n\n#### put方法\n\n```java\npublic final V put(K key, V value) {\n    //不可为空，否则抛出异常\n    if (key == null || value == null) {\n        throw new NullPointerException(\"key == null || value == null\");\n    }\n\n    V previous; //旧值\n    synchronized (this) {\n        putCount++;     //插入次数加1\n        size += safeSizeOf(key, value);     //更新缓存的大小\n        previous = map.put(key, value);\n        //如果已有缓存对象，则缓存大小的值需要剔除这个旧的大小\n        if (previous != null) {\n            size -= safeSizeOf(key, previous);\n        }\n    }\n\n    //entryRemoved()是个空方法，可以自行实现\n    if (previous != null) {\n        entryRemoved(false, key, previous, value);\n    }\n\n    //调整缓存大小(关键方法)\n    trimToSize(maxSize);\n    return previous;\n}1234567891011121314151617181920212223242526\n```\n\n可以看到put()方法并没有什么难点，重要的就是在添加过缓存对象后，调用`trimToSize()`方法，来判断缓存是否已满，如果满了就要删除近期最少使用的算法。\n\n#### trimToSize方法\n\n```java\npublic void trimToSize(int maxSize) {\n    while (true) {\n        K key;\n        V value;\n        synchronized (this) {\n            //如果map为空并且缓存size不等于0或者缓存size小于0，抛出异常\n            if (size < 0 || (map.isEmpty() && size != 0)) {\n                throw new IllegalStateException(getClass().getName()\n                        + \".sizeOf() is reporting inconsistent results!\");\n            }\n\n            //如果缓存大小size小于最大缓存，或者map为空，则不需要再删除缓存对象，跳出循环\n            if (size <= maxSize || map.isEmpty()) {\n                break;\n            }\n\n            //迭代器获取第一个对象，即队头的元素，近期最少访问的元素\n            Map.Entry<K, V> toEvict = map.entrySet().iterator().next();\n            key = toEvict.getKey();\n            value = toEvict.getValue();\n            //删除该对象，并更新缓存大小\n            map.remove(key);\n            size -= safeSizeOf(key, value);\n            evictionCount++;\n        }\n        entryRemoved(true, key, value, null);\n    }\n}12345678910111213141516171819202122232425262728\n```\n\n`trimToSize()`方法不断地删除`LinkedHashMap`中队头的元素，即近期最少访问的，直到缓存大小小于最大值。\n\n当调用LruCache的`get()`方法获取集合中的缓存对象时，就代表访问了一次该元素，将会更新队列，保持整个队列是按照访问顺序排序。这个更新过程就是在`LinkedHashMap`中的`get()`方法中完成的。\n\n我们先看LruCache的get()方法。\n\n#### get方法\n\n```java\n//LruCache的get()方法\npublic final V get(K key) {\n    if (key == null) {\n        throw new NullPointerException(\"key == null\");\n    }\n\n    V mapValue;\n    synchronized (this) {\n        //获取对应的缓存对象\n        //LinkedHashMap的get()方法会实现将访问的元素更新到队列尾部的功能\n        mapValue = map.get(key);\n\n        //mapValue不为空表示命中，hitCount+1并返回mapValue对象\n        if (mapValue != null) {\n            hitCount++;\n            return mapValue;\n        }\n        missCount++;    //未命中\n    }\n\n    /*\n     * Attempt to create a value. This may take a long time, and the map\n     * may be different when create() returns. If a conflicting value was\n     * added to the map while create() was working, we leave that value in\n     * the map and release the created value.\n     * 如果未命中，则试图创建一个对象，这里create方法默认返回null,并没有实现创建对象的方法。\n     * 如果需要事项创建对象的方法可以重写create方法。因为图片缓存时内存缓存没有命中会去\n     * 文件缓存中去取或者从网络下载，所以并不需要创建，下面的就不用看了。\n     */\n\n    V createdValue = create(key);\n    if (createdValue == null) {\n        return null;\n    }\n\n    //假如创建了新的对象，则继续往下执行\n    synchronized (this) {\n        createCount++;\n        //将createdValue加入到map中，并且将原来键为key的对象保存到mapValue\n        mapValue = map.put(key, createdValue);\n\n        if (mapValue != null) {\n            // There was a conflict so undo that last put\n            //如果mapValue不为空，则撤销上一步的put操作。\n            map.put(key, mapValue);\n        } else {\n            //加入新创建的对象之后需要重新计算size大小\n            size += safeSizeOf(key, createdValue);\n        }\n    }\n\n    if (mapValue != null) {\n        entryRemoved(false, key, createdValue, mapValue);\n        return mapValue;\n    } else {\n        //每次新加入对象都需要调用trimToSize方法看是否需要回收\n        trimToSize(maxSize);\n        return createdValue;\n    }\n}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960\n```\n\n其中LinkedHashMap的get()方法如下：\n\n```java\n//LinkedHashMap中的get方法\npublic V get(Object key) {\n    Node<K,V> e;\n    if ((e = getNode(hash(key), key)) == null)\n        return null;\n    //实现排序的关键方法\n    if (accessOrder)\n        afterNodeAccess(e);\n    return e.value;\n}12345678910\n```\n\n调用的afterNodeAccess()方法将该元素移到队尾，保证最后才删除，如下：\n\n```java\nvoid afterNodeAccess(Node<K,V> e) { // move node to last\n    LinkedHashMap.Entry<K,V> last;\n    if (accessOrder && (last = tail) != e) {\n        LinkedHashMap.Entry<K,V> p =\n            (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;\n        p.after = null;\n        if (b == null)\n            head = a;\n        else\n            b.after = a;\n        if (a != null)\n            a.before = b;\n        else\n            last = b;\n        if (last == null)\n            head = p;\n        else {\n            p.before = last;\n            last.after = p;\n        }\n        //当前节点p移动到尾部之后，尾部指针指向当前节点\n        tail = p;\n        ++modCount;\n    }\n}12345678910111213141516171819202122232425\n```\n\n由此可见`LruCache`中维护了一个集合`LinkedHashMap`，该`LinkedHashMap`是以访问顺序排序的。当调用`put()`方法时，就会在结合中添加元素，并调用`trimToSize()`判断缓存是否已满，如果满了就用`LinkedHashMap`的迭代器删除队头元素，即近期最少访问的元素。当调用get()方法访问缓存对象时，就会调用`LinkedHashMap`的`get()`方法获得对应集合元素，同时会更新该元素到队尾。\n\n以上便是LruCache实现的原理，理解了LinkedHashMap的数据结构就能理解整个原理。如果不懂，可以先看看LinkedHashMap的具体实现。\n\n### 参考资料\n\n*   [内存缓存LruCache实现原理](http://www.cnblogs.com/liuling/p/2015-9-24-1.html)\n*   [彻底解析Android缓存机制——LruCache](https://www.jianshu.com/p/b49a111147ee)\n*   [缓存淘汰算法–LRU算法](http://flychao88.iteye.com/blog/1977653)"]],[0,0],[10625,10625]]],[1519976240541,["gengmei_pxf@gengmei123.local",[[-1,0,"版权声明：本文为博主原创文章，未经博主允许不得转载。\n\n目录[(?)](http://blog.csdn.net/u010983881/article/details/79050209 \"系统根据文章中H1到H6标签自动生成文章目录\")[[+]](http://csdnimg.cn/release/phoenix/# \"展开\")\n\n"],[-1,2364," "],[1,2365," "],[-1,4191," "],[1,4192," "],[-1,4198," "],[1,4199," "],[-1,4205," "],[1,4206," "],[-1,4212," "],[1,4213," "],[-1,4219," "],[1,4220," "],[-1,4226," "],[1,4227," LRUCache原理"]],[0,167],[10,10]]],[1519976241365,["gengmei_pxf@gengmei123.local",[[1,0,"版权声明：本文为博主原创文章，未经博主允许不得转载。\n\n目录[(?)](http://blog.csdn.net/u010983881/article/details/79050209 \"系统根据文章中H1到H6标签自动生成文章目录\")[[+]](http://csdnimg.cn/release/phoenix/# \"展开\")\n\n"],[1,2197," "],[-1,2197," "],[1,4024," "],[-1,4024," "],[1,4031," "],[-1,4031," "],[1,4038," "],[-1,4038," "],[1,4045," "],[-1,4045," "],[1,4052," "],[-1,4052," "],[1,4059," "],[-1,4059," LRUCache原理"]],[10,10],[0,167]]],[1519976243041,["gengmei_pxf@gengmei123.local",[[-1,0,"版权声明：本文为博主原创文章，未经博主允许不得转载。\n\n目录[(?)](http://blog.csdn.net/u010983881/article/details/79050209 \"系统根据文章中H1到H6标签自动生成文章目录\")[[+]](http://csdnimg.cn/release/phoenix/# \"展开\")\n\n"],[1,167,"LRUCache原理"],[-1,2364," "],[1,2365," "],[-1,4191," "],[1,4192," "],[-1,4198," "],[1,4199," "],[-1,4205," "],[1,4206," "],[-1,4212," "],[1,4213," "],[-1,4219," "],[1,4220," "],[-1,4226," "],[1,4227," "]],[0,167],[10,10]]],[1519976244482,["gengmei_pxf@gengmei123.local",[[1,0,"版权声明：本文为博主原创文章，未经博主允许不得转载。\n\n目录[(?)](http://blog.csdn.net/u010983881/article/details/79050209 \"系统根据文章中H1到H6标签自动生成文章目录\")[[+]](http://csdnimg.cn/release/phoenix/# \"展开\")\n\n"],[-1,0,"LRUCache原理"],[1,2207," "],[-1,2207," "],[1,4034," "],[-1,4034," "],[1,4041," "],[-1,4041," "],[1,4048," "],[-1,4048," "],[1,4055," "],[-1,4055," "],[1,4062," "],[-1,4062," "],[1,4069," "],[-1,4069," "]],[10,10],[0,167]]],[1519976248341,["gengmei_pxf@gengmei123.local",[[-1,0,"版权声明：本文为博主原创文章，未经博主允许不得转载。\n\n目录[(?)](http://blog.csdn.net/u010983881/article/details/79050209 \"系统根据文章中H1到H6标签自动生成文章目录\")[[+]](http://csdnimg.cn/release/phoenix/# \"展开\")"],[1,165,"LRUCache原理"],[-1,2364," "],[1,2365," "],[-1,4191," "],[1,4192," "],[-1,4198," "],[1,4199," "],[-1,4205," "],[1,4206," "],[-1,4212," "],[1,4213," "],[-1,4219," "],[1,4220," "],[-1,4226," "],[1,4227," "]],[0,165],[10,10]]],[1519976309228,[null,[[1,12,"LRUCache原理"],[-1,2199,"程"],[1,2200," "],[-1,4026,"如"],[1,4027," "],[-1,4033,"0"],[1,4034," "],[-1,4040,"3"],[1,4041," "],[-1,4047,"4"],[1,4048," "],[-1,4054,"5:5 \n> 6:6"],[1,4064," :5"],[-1,4068,"1:1"]],[12,12],[4068,4068]]],[1519976309229,[null,[[-1,12,"LRUCache原理"],[1,2209,"程"],[-1,2209," "],[1,4036,"如"],[-1,4036," "],[1,4043,"0"],[-1,4043," "],[1,4050,"3"],[-1,4050," "],[1,4057,"4"],[-1,4057," "],[1,4064,"5:5 \n> 6:6"],[-1,4064," :5"],[1,4071,"1:1"]],[4068,4068],[12,12]]],[1519976260017,["gengmei_pxf@gengmei123.local",[[1,12,"\n"]],[10,10],[11,11]]],[1519976261860,["gengmei_pxf@gengmei123.local",[[1,11,"==="]],[11,11],[14,14]]],[1519976269705,["gengmei_pxf@gengmei123.local",[[-1,16,"LRUCache原理"]],[16,26],[16,16]]],[1519976549276,[null,[[1,16,"![](https:"],[-1,2193,"程"],[1,2194," "],[-1,4020,"如"],[1,4021," "],[-1,4027,"0"],[1,4028," "],[-1,4034,"3"],[1,4035," "],[-1,4041,"4"],[1,4042," "],[-1,4048,"5:5 \n> 6:6"],[1,4058," :5"],[-1,4062,"1:1"]],[16,16],[4062,4062]]],[1519976549276,[null,[[-1,16,"![](https:"],[1,2203,"程"],[-1,2203," "],[1,4030,"如"],[-1,4030," "],[1,4037,"0"],[-1,4037," "],[1,4044,"3"],[-1,4044," "],[1,4051,"4"],[-1,4051," "],[1,4058,"5:5 \n> 6:6"],[-1,4058," :5"],[1,4065,"1:1"]],[4062,4062],[16,16]]],[1519976535158,["gengmei_pxf@gengmei123.local",[[-1,149,"一般来说，缓存策略主要包含缓存的添加、获取和删除这三类操作。如何添加和获取缓存这个比较好理解，那么为什么还要删除缓存呢？这是因为不管是"],[1,216,"Android用LruCache来取代原来强引用和软引用实现"],[-1,220,"还是硬盘缓存，它们的缓存大小都是有限的。当缓存满了之后，再想其添加缓存，这个时候就需要删除一些旧的缓存并添加新的缓存。\n\n因此LRU(**Least Recently Used**)缓存算法便应运而生，"],[1,321,"，因为据说自2.3以后Android将更频繁的调用GC，导致软引用缓存的数据极易被释放。"]],[149,321],[227,227]]],[1519976536325,["gengmei_pxf@gengmei123.local",[[1,227,"\n"]],[227,227],[228,228]]],[1519976609235,[null,[[1,16,"![](https:"],[-1,139,"一般来说，缓存策略主"],[-1,179,"，它们的"],[1,183,"内存缓存"],[1,228,"LRU是近期最少使用"],[-1,2100,"程"],[1,2101," "],[-1,3927,"如"],[1,3928," "],[-1,3934,"0"],[1,3935," "],[-1,3941,"3"],[1,3942," "],[-1,3948,"4"],[1,3949," "],[-1,3955,"5:5 \n> 6:6"],[1,3965," :5"],[-1,3969,"1:1"]],[16,16],[3969,3969]]],[1519976609235,[null,[[-1,16,"![](https:"],[1,149,"一般来说，缓存策略主"],[1,179,"，它们的"],[-1,179,"内存缓存"],[-1,228,"LRU是近期最少使用"],[1,2110,"程"],[-1,2110," "],[1,3937,"如"],[-1,3937," "],[1,3944,"0"],[-1,3944," "],[1,3951,"3"],[-1,3951," "],[1,3958,"4"],[-1,3958," "],[1,3965,"5:5 \n> 6:6"],[-1,3965," :5"],[1,3972,"1:1"]],[3969,3969],[16,16]]],[1519976549385,["gengmei_pxf@gengmei123.local",[[1,229,"ruCache使用一个LinkedHashMap简单的实现内存的缓存，没有软引用，都是强引用。L"]],[228,228],[276,276]]],[1519976664047,[null,[[1,16,"![](https:"],[-1,139,"一般来说，缓存策略主"],[-1,179,"，它们的"],[1,183,"内存缓存"],[-1,228,"的"],[1,229,"L"],[1,277,"RU是近期最少使用的"],[-1,2148,"程"],[1,2149," "],[-1,3975,"如"],[1,3976," "],[-1,3982,"0"],[1,3983," "],[-1,3989,"3"],[1,3990," "],[-1,3996,"4"],[1,3997," "],[-1,4003,"5:5 \n> 6:6"],[1,4013," :5"],[-1,4017,"1:1"]],[16,16],[4017,4017]]],[1519976664047,[null,[[-1,16,"![](https:"],[1,149,"一般来说，缓存策略主"],[1,179,"，它们的"],[-1,179,"内存缓存"],[1,228,"的"],[-1,228,"L"],[-1,277,"RU是近期最少使用的"],[1,2158,"程"],[-1,2158," "],[1,3985,"如"],[-1,3985," "],[1,3992,"0"],[-1,3992," "],[1,3999,"3"],[-1,3999," "],[1,4006,"4"],[-1,4006," "],[1,4013,"5:5 \n> 6:6"],[-1,4013," :5"],[1,4020,"1:1"]],[4017,4017],[16,16]]],[1519976637322,["gengmei_pxf@gengmei123.local",[[-1,484,"其实LRU缓存的实现类似于一个特殊的栈，把访问过的元素放置到栈顶（若栈中存在，则更新至栈顶；若栈中不存在则直接入栈），然后如果栈中元素数量超过限定值，则删除栈底元素（即最近最少使用的元素）。详细算法实现如下图：\n\n![](https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/master/gallery/algorithms/1337859321_3597.png)\n\n1.  新数据压入到栈顶；\n2.  每当缓存命中（即缓存数据被访问），则将数据移到栈顶；\n3.  当栈满的时候，将栈底的数据丢弃。\n\n举个例子演示一下：\n\n![](https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/master/gallery/algorithms/lru-timg.jpg)\n"]],[484,909],[484,484]]],[1519976637801,["gengmei_pxf@gengmei123.local",[[-1,484,"\n"]],[484,484],[483,483]]],[1519976904067,[null,[[1,16,"![](https:"],[-1,139,"一般来说，缓存策略主"],[-1,179,"，它们的"],[1,183,"内存缓存"],[-1,228,"的"],[1,229,"L"],[1,277,"RU是近期最少使用的"],[-1,474,"其实LRU缓存的实现"],[1,484,"### 二、LruC"],[-1,1722,"程"],[1,1723," "],[-1,3549,"如"],[1,3550," "],[-1,3556,"0"],[1,3557," "],[-1,3563,"3"],[1,3564," "],[-1,3570,"4"],[1,3571," "],[-1,3577,"5:5 \n> 6:6"],[1,3587," :5"],[-1,3591,"1:1"]],[16,16],[3591,3591]]],[1519976904067,[null,[[-1,16,"![](https:"],[1,149,"一般来说，缓存策略主"],[1,179,"，它们的"],[-1,179,"内存缓存"],[1,228,"的"],[-1,228,"L"],[-1,277,"RU是近期最少使用的"],[1,484,"其实LRU缓存的实现"],[-1,484,"### 二、LruC"],[1,1732,"程"],[-1,1732," "],[1,3559,"如"],[-1,3559," "],[1,3566,"0"],[-1,3566," "],[1,3573,"3"],[-1,3573," "],[1,3580,"4"],[-1,3580," "],[1,3587,"5:5 \n> 6:6"],[-1,3587," :5"],[1,3594,"1:1"]],[3591,3591],[16,16]]],[1519976877296,["gengmei_pxf@gengmei123.local",[[1,227,"     "]],[227,227],[232,232]]],[1519976877902,["gengmei_pxf@gengmei123.local",[[1,233,"\n"]],[232,232],[233,233]]],[1519976898231,["gengmei_pxf@gengmei123.local",[[1,303,"**"]],[303,303],[305,305]]],[1519976964053,[null,[[1,16,"![](https:"],[-1,139,"一般来说，缓存策略主"],[-1,179,"，它们的"],[1,183,"内存缓存"],[-1,234,"的"],[1,235,"L"],[1,283,"RU是近期最少使用的"],[1,293,"**"],[-1,303,"**"],[-1,482,"其实LRU缓存的实现"],[1,492,"### 二、LruC"],[-1,1730,"程"],[1,1731," "],[-1,3557,"如"],[1,3558," "],[-1,3564,"0"],[1,3565," "],[-1,3571,"3"],[1,3572," "],[-1,3578,"4"],[1,3579," "],[-1,3585,"5:5 \n> 6:6"],[1,3595," :5"],[-1,3599,"1:1"]],[16,16],[3599,3599]]],[1519976964053,[null,[[-1,16,"![](https:"],[1,149,"一般来说，缓存策略主"],[1,179,"，它们的"],[-1,179,"内存缓存"],[1,234,"的"],[-1,234,"L"],[-1,283,"RU是近期最少使用的"],[-1,303,"**"],[1,315,"**"],[1,492,"其实LRU缓存的实现"],[-1,492,"### 二、LruC"],[1,1740,"程"],[-1,1740," "],[1,3567,"如"],[-1,3567," "],[1,3574,"0"],[-1,3574," "],[1,3581,"3"],[-1,3581," "],[1,3588,"4"],[-1,3588," "],[1,3595,"5:5 \n> 6:6"],[-1,3595," :5"],[1,3602,"1:1"]],[3599,3599],[16,16]]],[1519976905020,["gengmei_pxf@gengmei123.local",[[1,343,"**"]],[343,343],[345,345]]],[1519976910250,["gengmei_pxf@gengmei123.local",[[-1,343,"**"]],[345,345],[343,343]]],[1519976911670,["gengmei_pxf@gengmei123.local",[[1,342,"**"]],[342,342],[344,344]]],[1519976916786,["gengmei_pxf@gengmei123.local",[[1,303,"："]],[303,303],[304,304]]],[1519976927900,["gengmei_pxf@gengmei123.local",[[1,346,"\n"]],[346,346],[347,347]]],[1519976928389,["gengmei_pxf@gengmei123.local",[[1,347,"\n"]],[347,347],[348,348]]],[1519977024053,[null,[[1,16,"![](https:"],[-1,139,"一般来说，缓存策略主"],[-1,179,"，它们的"],[1,183,"内存缓存"],[-1,234,"的"],[1,235,"L"],[1,283,"RU是近期最少使用的"],[1,293,"：**"],[-1,303,"：**"],[1,333,"**"],[1,334,"\n\n"],[-1,343,"**"],[-1,346,"\n\n"],[-1,487,"其实LRU缓存的实现"],[1,497,"### 二、LruC"],[-1,1735,"程"],[1,1736," "],[-1,3562,"如"],[1,3563," "],[-1,3569,"0"],[1,3570," "],[-1,3576,"3"],[1,3577," "],[-1,3583,"4"],[1,3584," "],[-1,3590,"5:5 \n> 6:6"],[1,3600," :5"],[-1,3604,"1:1"]],[16,16],[3604,3604]]],[1519977024053,[null,[[-1,16,"![](https:"],[1,149,"一般来说，缓存策略主"],[1,179,"，它们的"],[-1,179,"内存缓存"],[1,234,"的"],[-1,234,"L"],[-1,283,"RU是近期最少使用的"],[-1,303,"：**"],[1,316,"：**"],[-1,343,"**"],[-1,346,"\n\n"],[1,357,"**"],[1,358,"\n\n"],[1,497,"其实LRU缓存的实现"],[-1,497,"### 二、LruC"],[1,1745,"程"],[-1,1745," "],[1,3572,"如"],[-1,3572," "],[1,3579,"0"],[-1,3579," "],[1,3586,"3"],[-1,3586," "],[1,3593,"4"],[-1,3593," "],[1,3600,"5:5 \n> 6:6"],[-1,3600," :5"],[1,3607,"1:1"]],[3604,3604],[16,16]]],[1519976965040,["gengmei_pxf@gengmei123.local",[[1,826,"\n"]],[826,826],[827,827]]],[1519976975778,["gengmei_pxf@gengmei123.local",[[1,828,"\n"]],[828,828],[829,829]]],[1519976979649,["gengmei_pxf@gengmei123.local",[[1,908,"\n"]],[908,908],[909,909]]],[1519976980329,["gengmei_pxf@gengmei123.local",[[1,909,"\n"]],[909,909],[910,910]]],[1519976987668,["gengmei_pxf@gengmei123.local",[[1,828,"``"]],[828,828],[830,830]]],[1519976991543,["gengmei_pxf@gengmei123.local",[[1,913,"\n"]],[913,913],[914,914]]],[1519976993274,["gengmei_pxf@gengmei123.local",[[1,913,"``"]],[912,912],[914,914]]],[1519977001649,["gengmei_pxf@gengmei123.local",[[-1,914,"`"]],[915,915],[914,914]]],[1519977002642,["gengmei_pxf@gengmei123.local",[[1,914,"`"]],[914,914],[915,915]]],[1519977084056,[null,[[1,16,"![](https:"],[-1,139,"一般来说，缓存策略主"],[-1,179,"，它们的"],[1,183,"内存缓存"],[-1,234,"的"],[1,235,"L"],[1,283,"RU是近期最少使用的"],[1,293,"：**"],[-1,303,"：**"],[1,333,"**"],[1,334,"\n\n"],[-1,343,"**"],[-1,346,"\n\n"],[-1,487,"其实LRU缓存的实现"],[1,497,"### 二、LruC"],[1,816,"\n"],[1,817,"``\n"],[-1,826,"\n"],[-1,828,"``\n"],[1,900,"\n\n"],[1,901,"``\n"],[-1,910,"\n\n"],[-1,913,"``\n"],[-1,1744,"程"],[1,1745," "],[-1,3571,"如"],[1,3572," "],[-1,3578,"0"],[1,3579," "],[-1,3585,"3"],[1,3586," "],[-1,3592,"4"],[1,3593," "],[-1,3599,"5:5 \n> 6:6"],[1,3609," :5"],[-1,3613,"1:1"]],[16,16],[3613,3613]]],[1519977084057,[null,[[-1,16,"![](https:"],[1,149,"一般来说，缓存策略主"],[1,179,"，它们的"],[-1,179,"内存缓存"],[1,234,"的"],[-1,234,"L"],[-1,283,"RU是近期最少使用的"],[-1,303,"：**"],[1,316,"：**"],[-1,343,"**"],[-1,346,"\n\n"],[1,357,"**"],[1,358,"\n\n"],[1,497,"其实LRU缓存的实现"],[-1,497,"### 二、LruC"],[-1,826,"\n"],[-1,828,"``\n"],[1,840,"\n"],[1,841,"``\n"],[-1,910,"\n\n"],[-1,913,"``\n"],[1,925,"\n\n"],[1,926,"``\n"],[1,1754,"程"],[-1,1754," "],[1,3581,"如"],[-1,3581," "],[1,3588,"0"],[-1,3588," "],[1,3595,"3"],[-1,3595," "],[1,3602,"4"],[-1,3602," "],[1,3609,"5:5 \n> 6:6"],[-1,3609," :5"],[1,3616,"1:1"]],[3613,3613],[16,16]]],[1519977048791,["gengmei_pxf@gengmei123.local",[[-1,1259,"![](https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/master/gallery/algorithms/lru-cache.png)"]],[1259,1375],[1259,1259]]],[1519977049231,["gengmei_pxf@gengmei123.local",[[-1,1260,"\n"]],[1259,1259],[1258,1258]]],[1519977049766,["gengmei_pxf@gengmei123.local",[[-1,1259,"\n"]],[1258,1258],[1257,1257]]],[1519977057198,["gengmei_pxf@gengmei123.local",[[-1,130,"#"]],[131,131],[130,130]]],[1519977059950,["gengmei_pxf@gengmei123.local",[[-1,498,"#"]],[499,499],[498,498]]],[1519977067382,["gengmei_pxf@gengmei123.local",[[-1,1260,"#"]],[1261,1261],[1260,1260]]],[1519977144063,[null,[[1,16,"![](https:"],[-1,120,"#"],[1,130,"d"],[-1,138,"一般来说，缓存策略主"],[-1,178,"，它们的"],[1,182,"内存缓存"],[-1,233,"的"],[1,234,"L"],[1,282,"RU是近期最少使用的"],[1,292,"：**"],[-1,302,"：**"],[1,332,"**"],[1,333,"\n\n"],[-1,342,"**"],[-1,345,"\n\n"],[-1,486,"其实LRU缓存的实现"],[1,496,"## 二、LruC"],[1,498,"h"],[1,814,"\n"],[1,815,"``\n"],[-1,824,"\n"],[-1,826,"``\n"],[1,898,"\n\n"],[1,899,"``\n"],[-1,908,"\n\n"],[-1,911,"``\n"],[-1,1247,"![](https:"],[1,1257,"### LruCa"],[1,1260,"使"],[-1,1623,"程"],[1,1624," "],[-1,3450,"如"],[1,3451," "],[-1,3457,"0"],[1,3458," "],[-1,3464,"3"],[1,3465," "],[-1,3471,"4"],[1,3472," "],[-1,3478,"5:5 \n> 6:6"],[1,3488," :5"],[-1,3492,"1:1"]],[16,16],[3492,3492]]],[1519977144063,[null,[[-1,16,"![](https:"],[1,130,"#"],[-1,139,"d"],[1,148,"一般来说，缓存策略主"],[1,178,"，它们的"],[-1,178,"内存缓存"],[1,233,"的"],[-1,233,"L"],[-1,282,"RU是近期最少使用的"],[-1,302,"：**"],[1,315,"：**"],[-1,342,"**"],[-1,345,"\n\n"],[1,356,"**"],[1,357,"\n\n"],[1,496,"其实LRU缓存的实现"],[-1,496,"## 二、LruC"],[-1,507,"h"],[-1,824,"\n"],[-1,826,"``\n"],[1,838,"\n"],[1,839,"``\n"],[-1,908,"\n\n"],[-1,911,"``\n"],[1,923,"\n\n"],[1,924,"``\n"],[1,1257,"![](https:"],[-1,1257,"### LruCa"],[-1,1269,"使"],[1,1633,"程"],[-1,1633," "],[1,3460,"如"],[-1,3460," "],[1,3467,"0"],[-1,3467," "],[1,3474,"3"],[-1,3474," "],[1,3481,"4"],[-1,3481," "],[1,3488,"5:5 \n> 6:6"],[-1,3488," :5"],[1,3495,"1:1"]],[3492,3492],[16,16]]],[1519977090000,["gengmei_pxf@gengmei123.local",[[-1,1680,"**"]],[1680,1682],[1680,1680]]],[1519977091151,["gengmei_pxf@gengmei123.local",[[1,1679,"**"]],[1679,1679],[1681,1681]]],[1519977096469,["gengmei_pxf@gengmei123.local",[[-1,1711,"#"]],[1712,1712],[1711,1711]]],[1519977264074,[null,[[1,16,"![](https:"],[-1,120,"#"],[1,130,"d"],[-1,138,"一般来说，缓存策略主"],[-1,178,"，它们的"],[1,182,"内存缓存"],[-1,233,"的"],[1,234,"L"],[1,282,"RU是近期最少使用的"],[1,292,"：**"],[-1,302,"：**"],[1,332,"**"],[1,333,"\n\n"],[-1,342,"**"],[-1,345,"\n\n"],[-1,486,"其实LRU缓存的实现"],[1,496,"## 二、LruC"],[1,498,"h"],[1,814,"\n"],[1,815,"``\n"],[-1,824,"\n"],[-1,826,"``\n"],[1,898,"\n\n"],[1,899,"``\n"],[-1,908,"\n\n"],[-1,911,"``\n"],[-1,1247,"![](https:"],[1,1257,"### LruCa"],[1,1260,"使"],[-1,1623,"程"],[1,1624," "],[-1,1669,"："],[1,1672,"："],[-1,1679,"**"],[1,1682,"个缓"],[-1,1701,"#"],[1,1711,"的"],[-1,3449,"如"],[1,3450," "],[-1,3456,"0"],[1,3457," "],[-1,3463,"3"],[1,3464," "],[-1,3470,"4"],[1,3471," "],[-1,3477,"5:5 \n> 6:6"],[1,3487," :5"],[-1,3491,"1:1"]],[16,16],[3491,3491]]],[1519977264074,[null,[[-1,16,"![](https:"],[1,130,"#"],[-1,139,"d"],[1,148,"一般来说，缓存策略主"],[1,178,"，它们的"],[-1,178,"内存缓存"],[1,233,"的"],[-1,233,"L"],[-1,282,"RU是近期最少使用的"],[-1,302,"：**"],[1,315,"：**"],[-1,342,"**"],[-1,345,"\n\n"],[1,356,"**"],[1,357,"\n\n"],[1,496,"其实LRU缓存的实现"],[-1,496,"## 二、LruC"],[-1,507,"h"],[-1,824,"\n"],[-1,826,"``\n"],[1,838,"\n"],[1,839,"``\n"],[-1,908,"\n\n"],[-1,911,"``\n"],[1,923,"\n\n"],[1,924,"``\n"],[1,1257,"![](https:"],[-1,1257,"### LruCa"],[-1,1269,"使"],[1,1633,"程"],[-1,1633," "],[1,1679,"："],[-1,1681,"："],[1,1689,"**"],[-1,1690,"个缓"],[1,1711,"#"],[-1,1720,"的"],[1,3459,"如"],[-1,3459," "],[1,3466,"0"],[-1,3466," "],[1,3473,"3"],[-1,3473," "],[1,3480,"4"],[-1,3480," "],[1,3487,"5:5 \n> 6:6"],[-1,3487," :5"],[1,3494,"1:1"]],[3491,3491],[16,16]]],[1519977235935,["gengmei_pxf@gengmei123.local",[[-1,1795,"尾"]],[1796,1796],[1795,1795]]],[1519977238303,["gengmei_pxf@gengmei123.local",[[1,1795,"头"]],[1795,1795],[1796,1796]]],[1519977240397,["gengmei_pxf@gengmei123.local",[[-1,1815,"头"]],[1816,1816],[1815,1815]]],[1519977249168,["gengmei_pxf@gengmei123.local",[[1,1815,"尾"]],[1815,1815],[1816,1816]]],[1519977324064,[null,[[1,16,"![](https:"],[-1,120,"#"],[1,130,"d"],[-1,138,"一般来说，缓存策略主"],[-1,178,"，它们的"],[1,182,"内存缓存"],[-1,233,"的"],[1,234,"L"],[1,282,"RU是近期最少使用的"],[1,292,"：**"],[-1,302,"：**"],[1,332,"**"],[1,333,"\n\n"],[-1,342,"**"],[-1,345,"\n\n"],[-1,486,"其实LRU缓存的实现"],[1,496,"## 二、LruC"],[1,498,"h"],[1,814,"\n"],[1,815,"``\n"],[-1,824,"\n"],[-1,826,"``\n"],[1,898,"\n\n"],[1,899,"``\n"],[-1,908,"\n\n"],[-1,911,"``\n"],[-1,1247,"![](https:"],[1,1257,"### LruCa"],[1,1260,"使"],[-1,1623,"程"],[1,1624," "],[-1,1669,"："],[1,1672,"："],[-1,1679,"**"],[1,1682,"个缓"],[-1,1698,"#"],[1,1711,"的"],[-1,1785,"尾"],[1,1786,"头"],[-1,1795,"头"],[1,1796,"近"],[-1,1805,"头"],[1,1806,"尾"],[-1,1815,"尾"],[1,1816,"图"],[-1,3449,"如"],[1,3450," "],[-1,3456,"0"],[1,3457," "],[-1,3463,"3"],[1,3464," "],[-1,3470,"4"],[1,3471," "],[-1,3477,"5:5 \n> 6:6"],[1,3487," :5"],[-1,3491,"1:1"]],[16,16],[3491,3491]]],[1519977324064,[null,[[-1,16,"![](https:"],[1,130,"#"],[-1,139,"d"],[1,148,"一般来说，缓存策略主"],[1,178,"，它们的"],[-1,178,"内存缓存"],[1,233,"的"],[-1,233,"L"],[-1,282,"RU是近期最少使用的"],[-1,302,"：**"],[1,315,"：**"],[-1,342,"**"],[-1,345,"\n\n"],[1,356,"**"],[1,357,"\n\n"],[1,496,"其实LRU缓存的实现"],[-1,496,"## 二、LruC"],[-1,507,"h"],[-1,824,"\n"],[-1,826,"``\n"],[1,838,"\n"],[1,839,"``\n"],[-1,908,"\n\n"],[-1,911,"``\n"],[1,923,"\n\n"],[1,924,"``\n"],[1,1257,"![](https:"],[-1,1257,"### LruCa"],[-1,1269,"使"],[1,1633,"程"],[-1,1633," "],[1,1679,"："],[-1,1681,"："],[1,1689,"**"],[-1,1690,"个缓"],[1,1708,"#"],[-1,1720,"的"],[1,1795,"尾"],[-1,1795,"头"],[1,1805,"头"],[-1,1805,"近"],[1,1815,"头"],[-1,1815,"尾"],[1,1825,"尾"],[-1,1825,"图"],[1,3459,"如"],[-1,3459," "],[1,3466,"0"],[-1,3466," "],[1,3473,"3"],[-1,3473," "],[1,3480,"4"],[-1,3480," "],[1,3487,"5:5 \n> 6:6"],[-1,3487," :5"],[1,3494,"1:1"]],[3491,3491],[16,16]]],[1519977265341,["gengmei_pxf@gengmei123.local",[[-1,1822,"。如下图所示：\n\n![](https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/master/gallery/algorithms/3985563-33560a9500e72780.png)"]],[1822,1962],[1822,1822]]],[1519977268642,["gengmei_pxf@gengmei123.local",[[1,1822,"。如下图所示：\n\n![](https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/master/gallery/algorithms/3985563-33560a9500e72780.png)"]],[1822,1822],[1822,1962]]],[1519977279652,["gengmei_pxf@gengmei123.local",[[-1,1823,"如下图所示：\n\n![](https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/master/gallery/algorithms/3985563-33560a9500e72780.png)\n\n那么"]],[1823,1962],[1823,1823]]],[1519977287476,["gengmei_pxf@gengmei123.local",[[-1,1827,"到底是"]],[1827,1830],[1827,1827]]],[1519977293388,["gengmei_pxf@gengmei123.local",[[-1,1827,"由谁来维护的，前面已经介绍了是"]],[1828,1842],[1827,1827]]],[1519977317915,["gengmei_pxf@gengmei123.local",[[-1,2696,"1234567891011121314151617181920"]],[2696,2727],[2696,2696]]],[1519977384063,[null,[[1,16,"![](https:"],[-1,120,"#"],[1,130,"d"],[-1,138,"一般来说，缓存策略主"],[-1,178,"，它们的"],[1,182,"内存缓存"],[-1,233,"的"],[1,234,"L"],[1,282,"RU是近期最少使用的"],[1,292,"：**"],[-1,302,"：**"],[1,332,"**"],[1,333,"\n\n"],[-1,342,"**"],[-1,345,"\n\n"],[-1,486,"其实LRU缓存的实现"],[1,496,"## 二、LruC"],[1,498,"h"],[1,814,"\n"],[1,815,"``\n"],[-1,824,"\n"],[-1,826,"``\n"],[1,898,"\n\n"],[1,899,"``\n"],[-1,908,"\n\n"],[-1,911,"``\n"],[-1,1247,"![](https:"],[1,1257,"### LruCa"],[1,1260,"使"],[-1,1623,"程"],[1,1624," "],[-1,1669,"："],[1,1672,"："],[-1,1679,"**"],[1,1682,"个缓"],[-1,1701,"#"],[1,1711,"的"],[-1,1785,"尾"],[1,1786,"头"],[-1,1795,"头"],[1,1796,"近"],[-1,1805,"头"],[1,1806,"尾"],[-1,1813,"如下尾所示：\n\n!。维护的，"],[1,1827,"这个队列由LinkedHas"],[-1,2686,"1234567891"],[1,2696,"\n```\n\n其中`a"],[-1,3257,"如"],[1,3258," "],[-1,3264,"0"],[1,3265," "],[-1,3271,"3"],[1,3272," "],[-1,3278,"4"],[1,3279," "],[-1,3285,"5:5 \n> 6:6"],[1,3295," :5"],[-1,3299,"1:1"]],[16,16],[3299,3299]]],[1519977384063,[null,[[-1,16,"![](https:"],[1,130,"#"],[-1,139,"d"],[1,148,"一般来说，缓存策略主"],[1,178,"，它们的"],[-1,178,"内存缓存"],[1,233,"的"],[-1,233,"L"],[-1,282,"RU是近期最少使用的"],[-1,302,"：**"],[1,315,"：**"],[-1,342,"**"],[-1,345,"\n\n"],[1,356,"**"],[1,357,"\n\n"],[1,496,"其实LRU缓存的实现"],[-1,496,"## 二、LruC"],[-1,507,"h"],[-1,824,"\n"],[-1,826,"``\n"],[1,838,"\n"],[1,839,"``\n"],[-1,908,"\n\n"],[-1,911,"``\n"],[1,923,"\n\n"],[1,924,"``\n"],[1,1257,"![](https:"],[-1,1257,"### LruCa"],[-1,1269,"使"],[1,1633,"程"],[-1,1633," "],[1,1679,"："],[-1,1681,"："],[1,1689,"**"],[-1,1690,"个缓"],[1,1711,"#"],[-1,1720,"的"],[1,1795,"尾"],[-1,1795,"头"],[1,1805,"头"],[-1,1805,"近"],[1,1815,"头"],[-1,1815,"尾"],[1,1823,"如下尾所示：\n\n!。维护的，"],[-1,1823,"这个队列由LinkedHas"],[1,2696,"1234567891"],[-1,2696,"\n```\n\n其中`a"],[1,3267,"如"],[-1,3267," "],[1,3274,"0"],[-1,3274," "],[1,3281,"3"],[-1,3281," "],[1,3288,"4"],[-1,3288," "],[1,3295,"5:5 \n> 6:6"],[-1,3295," :5"],[1,3302,"1:1"]],[3299,3299],[16,16]]],[1519977329186,["gengmei_pxf@gengmei123.local",[[-1,2537,"        "]],[2545,2545],[2537,2537]]],[1519977329682,["gengmei_pxf@gengmei123.local",[[-1,2536,"\n"]],[2537,2537],[2536,2536]]],[1519977338362,["gengmei_pxf@gengmei123.local",[[-1,2692,"\n"]],[2692,2692],[2691,2691]]],[1519977444062,[null,[[1,16,"![](https:"],[-1,120,"#"],[1,130,"d"],[-1,138,"一般来说，缓存策略主"],[-1,178,"，它们的"],[1,182,"内存缓存"],[-1,233,"的"],[1,234,"L"],[1,282,"RU是近期最少使用的"],[1,292,"：**"],[-1,302,"：**"],[1,332,"**"],[1,333,"\n\n"],[-1,342,"**"],[-1,345,"\n\n"],[-1,486,"其实LRU缓存的实现"],[1,496,"## 二、LruC"],[1,498,"h"],[1,814,"\n"],[1,815,"``\n"],[-1,824,"\n"],[-1,826,"``\n"],[1,898,"\n\n"],[1,899,"``\n"],[-1,908,"\n\n"],[-1,911,"``\n"],[-1,1247,"![](https:"],[1,1257,"### LruCa"],[1,1260,"使"],[-1,1623,"程"],[1,1624," "],[-1,1669,"："],[1,1672,"："],[-1,1679,"**"],[1,1682,"个缓"],[-1,1701,"#"],[1,1711,"的"],[-1,1785,"尾"],[1,1786,"头"],[-1,1795,"头"],[1,1796,"近"],[-1,1805,"头"],[1,1806,"尾"],[-1,1813,"如下尾所示：\n\n!。维护的，"],[1,1827,"这个队列由LinkedHas"],[-1,2526,"\n       "],[1,2534,"int"],[1,2536,"nitia"],[-1,2677,"1234567891"],[1,2687,"\n```\n其中`a"],[1,2692,"O"],[-1,3247,"如"],[1,3248," "],[-1,3254,"0"],[1,3255," "],[-1,3261,"3"],[1,3262," "],[-1,3268,"4"],[1,3269," "],[-1,3275,"5:5 \n> 6:6"],[1,3285," :5"],[-1,3289,"1:1"]],[16,16],[3289,3289]]],[1519977444062,[null,[[-1,16,"![](https:"],[1,130,"#"],[-1,139,"d"],[1,148,"一般来说，缓存策略主"],[1,178,"，它们的"],[-1,178,"内存缓存"],[1,233,"的"],[-1,233,"L"],[-1,282,"RU是近期最少使用的"],[-1,302,"：**"],[1,315,"：**"],[-1,342,"**"],[-1,345,"\n\n"],[1,356,"**"],[1,357,"\n\n"],[1,496,"其实LRU缓存的实现"],[-1,496,"## 二、LruC"],[-1,507,"h"],[-1,824,"\n"],[-1,826,"``\n"],[1,838,"\n"],[1,839,"``\n"],[-1,908,"\n\n"],[-1,911,"``\n"],[1,923,"\n\n"],[1,924,"``\n"],[1,1257,"![](https:"],[-1,1257,"### LruCa"],[-1,1269,"使"],[1,1633,"程"],[-1,1633," "],[1,1679,"："],[-1,1681,"："],[1,1689,"**"],[-1,1690,"个缓"],[1,1711,"#"],[-1,1720,"的"],[1,1795,"尾"],[-1,1795,"头"],[1,1805,"头"],[-1,1805,"近"],[1,1815,"头"],[-1,1815,"尾"],[1,1823,"如下尾所示：\n\n!。维护的，"],[-1,1823,"这个队列由LinkedHas"],[1,2536,"\n       "],[-1,2536,"int"],[-1,2541,"nitia"],[1,2687,"1234567891"],[-1,2687,"\n```\n其中`a"],[-1,2701,"O"],[1,3257,"如"],[-1,3257," "],[1,3264,"0"],[-1,3264," "],[1,3271,"3"],[-1,3271," "],[1,3278,"4"],[-1,3278," "],[1,3285,"5:5 \n> 6:6"],[-1,3285," :5"],[1,3292,"1:1"]],[3289,3289],[16,16]]],[1519977386512,["gengmei_pxf@gengmei123.local",[[-1,2745,"以具体例子解释，"]],[2745,2753],[2745,2745]]],[1519977393640,["gengmei_pxf@gengmei123.local",[[-1,2756,"\n```java\npublic static final void main(String[] args) {\n    LinkedHashMap<Integer, Integer> map = new LinkedHashMap<>(0, 0.75f, true);\n    map.put(0, 0);\n    map.put(1, 1);\n    map.put(2, 2);\n    map.put(3, 3);\n    map.put(4, 4);\n    map.put(5, 5);\n    map.put(6, 6);\n    map.get(1);     //访问1\n    map.get(2);     //访问2\n\n    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n        System.out.println(entry.getKey() + \":\" + entry.getValue());\n    }\n}12345678910111213141516\n```\n\n输出结果 下：\n\n>  :0 \n>  :3 \n>  :4 \n>  :5 \n>  \n> 2:2\n\n"]],[2756,3293],[2756,2756]]],[1519977396360,["gengmei_pxf@gengmei123.local",[[-1,2755,"\n"]],[2756,2756],[2755,2755]]],[1519977424063,["gengmei_pxf@gengmei123.local",[[-1,3398,"123456789101112131415"]],[3398,3419],[3398,3398]]],[1519977427862,["gengmei_pxf@gengmei123.local",[[-1,3737,"12345678"]],[3737,3745],[3737,3737]]],[1519977433854,["gengmei_pxf@gengmei123.local",[[-1,4429,"1234567891011121314151617181920212223242526"]],[4429,4472],[4429,4429]]],[1519977504063,[null,[[1,16,"![](https:"],[-1,120,"#"],[1,130,"d"],[-1,138,"一般来说，缓存策略主"],[-1,178,"，它们的"],[1,182,"内存缓存"],[-1,233,"的"],[1,234,"L"],[1,282,"RU是近期最少使用的"],[1,292,"：**"],[-1,302,"：**"],[1,332,"**"],[1,333,"\n\n"],[-1,342,"**"],[-1,345,"\n\n"],[-1,486,"其实LRU缓存的实现"],[1,496,"## 二、LruC"],[1,498,"h"],[1,814,"\n"],[1,815,"``\n"],[-1,824,"\n"],[-1,826,"``\n"],[1,898,"\n\n"],[1,899,"``\n"],[-1,908,"\n\n"],[-1,911,"``\n"],[-1,1247,"![](https:"],[1,1257,"### LruCa"],[1,1260,"使"],[-1,1623,"程"],[1,1624," "],[-1,1669,"："],[1,1672,"："],[-1,1679,"**"],[1,1682,"个缓"],[-1,1701,"#"],[1,1711,"的"],[-1,1785,"尾"],[1,1786,"头"],[-1,1795,"头"],[1,1796,"近"],[-1,1805,"头"],[1,1806,"尾"],[-1,1813,"如下尾所示：\n\n!。维护的，"],[1,1827,"这个队列由LinkedHas"],[-1,2526,"\n       "],[1,2534,"int"],[1,2536,"nitia"],[-1,2677,"1234567891"],[1,2687,"\n```\n其中`a"],[1,2692,"O"],[-1,2735,"以具体例子解释，"],[-1,2745,"\n\n```java\n"],[1,2755,"置为true时："]],[16,16],[2763,2763]]],[1519977504064,[null,[[-1,16,"![](https:"],[1,130,"#"],[-1,139,"d"],[1,148,"一般来说，缓存策略主"],[1,178,"，它们的"],[-1,178,"内存缓存"],[1,233,"的"],[-1,233,"L"],[-1,282,"RU是近期最少使用的"],[-1,302,"：**"],[1,315,"：**"],[-1,342,"**"],[-1,345,"\n\n"],[1,356,"**"],[1,357,"\n\n"],[1,496,"其实LRU缓存的实现"],[-1,496,"## 二、LruC"],[-1,507,"h"],[-1,824,"\n"],[-1,826,"``\n"],[1,838,"\n"],[1,839,"``\n"],[-1,908,"\n\n"],[-1,911,"``\n"],[1,923,"\n\n"],[1,924,"``\n"],[1,1257,"![](https:"],[-1,1257,"### LruCa"],[-1,1269,"使"],[1,1633,"程"],[-1,1633," "],[1,1679,"："],[-1,1681,"："],[1,1689,"**"],[-1,1690,"个缓"],[1,1711,"#"],[-1,1720,"的"],[1,1795,"尾"],[-1,1795,"头"],[1,1805,"头"],[-1,1805,"近"],[1,1815,"头"],[-1,1815,"尾"],[1,1823,"如下尾所示：\n\n!。维护的，"],[-1,1823,"这个队列由LinkedHas"],[1,2536,"\n       "],[-1,2536,"int"],[-1,2541,"nitia"],[1,2687,"1234567891"],[-1,2687,"\n```\n其中`a"],[-1,2701,"O"],[1,2745,"以具体例子解释，"],[1,2747,"\n\n```java\n"],[-1,2747,"置为true时："]],[2763,2763],[16,16]]],[1519977445526,["gengmei_pxf@gengmei123.local",[[-1,3746,"#"]],[3747,3747],[3746,3746]]],[1519977448813,["gengmei_pxf@gengmei123.local",[[-1,4520,"#"]],[4521,4521],[4520,4520]]],[1519977452464,["gengmei_pxf@gengmei123.local",[[1,4533,"（）"]],[4533,4533],[4535,4535]]],[1519977460879,["gengmei_pxf@gengmei123.local",[[1,4534,"核心方法"]],[4534,4534],[4538,4538]]],[1519977468901,["gengmei_pxf@gengmei123.local",[[-1,5466,"12345678910111213141516171819202122232425262728"]],[5466,5513],[5466,5466]]],[1519977491868,["gengmei_pxf@gengmei123.local",[[-1,5674,"#"]],[5675,5675],[5674,5674]]],[1519977500282,["gengmei_pxf@gengmei123.local",[[-1,7375,"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960"]],[7375,7486],[7375,7375]]],[1519977503707,["gengmei_pxf@gengmei123.local",[[-1,7638,"12345678910"]],[7638,7649],[7638,7638]]],[1519977564063,[null,[[1,16,"![](https:"],[-1,120,"#"],[1,130,"d"],[-1,138,"一般来说，缓存策略主"],[-1,178,"，它们的"],[1,182,"内存缓存"],[-1,233,"的"],[1,234,"L"],[1,282,"RU是近期最少使用的"],[1,292,"：**"],[-1,302,"：**"],[1,332,"**"],[1,333,"\n\n"],[-1,342,"**"],[-1,345,"\n\n"],[-1,486,"其实LRU缓存的实现"],[1,496,"## 二、LruC"],[1,498,"h"],[1,814,"\n"],[1,815,"``\n"],[-1,824,"\n"],[-1,826,"``\n"],[1,898,"\n\n"],[1,899,"``\n"],[-1,908,"\n\n"],[-1,911,"``\n"],[-1,1247,"![](https:"],[1,1257,"### LruCa"],[1,1260,"使"],[-1,1623,"程"],[1,1624," "],[-1,1669,"："],[1,1672,"："],[-1,1679,"**"],[1,1682,"个缓"],[-1,1701,"#"],[1,1711,"的"],[-1,1785,"尾"],[1,1786,"头"],[-1,1795,"头"],[1,1796,"近"],[-1,1805,"头"],[1,1806,"尾"],[-1,1813,"如下尾所示：\n\n!。维护的，"],[1,1827,"这个队列由LinkedHas"],[-1,2526,"\n       "],[1,2534,"int"],[1,2536,"nitia"],[-1,2677,"1234567891"],[1,2687,"\n```\n其中`a"],[1,2692,"O"],[-1,2735,"以具体例子解释，"],[-1,2745,"\n\n```java\n"],[1,2755,"置为true时："]],[16,16],[2763,2763]]],[1519977564063,[null,[[-1,16,"![](https:"],[1,130,"#"],[-1,139,"d"],[1,148,"一般来说，缓存策略主"],[1,178,"，它们的"],[-1,178,"内存缓存"],[1,233,"的"],[-1,233,"L"],[-1,282,"RU是近期最少使用的"],[-1,302,"：**"],[1,315,"：**"],[-1,342,"**"],[-1,345,"\n\n"],[1,356,"**"],[1,357,"\n\n"],[1,496,"其实LRU缓存的实现"],[-1,496,"## 二、LruC"],[-1,507,"h"],[-1,824,"\n"],[-1,826,"``\n"],[1,838,"\n"],[1,839,"``\n"],[-1,908,"\n\n"],[-1,911,"``\n"],[1,923,"\n\n"],[1,924,"``\n"],[1,1257,"![](https:"],[-1,1257,"### LruCa"],[-1,1269,"使"],[1,1633,"程"],[-1,1633," "],[1,1679,"："],[-1,1681,"："],[1,1689,"**"],[-1,1690,"个缓"],[1,1711,"#"],[-1,1720,"的"],[1,1795,"尾"],[-1,1795,"头"],[1,1805,"头"],[-1,1805,"近"],[1,1815,"头"],[-1,1815,"尾"],[1,1823,"如下尾所示：\n\n!。维护的，"],[-1,1823,"这个队列由LinkedHas"],[1,2536,"\n       "],[-1,2536,"int"],[-1,2541,"nitia"],[1,2687,"1234567891"],[-1,2687,"\n```\n其中`a"],[-1,2701,"O"],[1,2745,"以具体例子解释，"],[1,2747,"\n\n```java\n"],[-1,2747,"置为true时："]],[2763,2763],[16,16]]],[1519977513155,["gengmei_pxf@gengmei123.local",[[-1,8338,"12345678910111213141516171819202122232425"]],[8338,8379],[8338,8338]]],[1519977538434,["gengmei_pxf@gengmei123.local",[[-1,16,"![](https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/master/gallery/algorithms/lru.png)"]],[16,126],[16,16]]],[1519977538802,["gengmei_pxf@gengmei123.local",[[-1,17,"\n"]],[16,16],[15,15]]],[1519977539138,["gengmei_pxf@gengmei123.local",[[-1,16,"\n"]],[15,15],[14,14]]],[1519977556801,["gengmei_pxf@gengmei123.local",[[1,260,"\n"]],[260,260],[261,261]]],[1519977624063,[null,[[1,16,"## 一、Andr"],[1,18,"d"],[-1,26,"一般来说，缓存策略主"],[-1,66,"，它们的"],[1,70,"内存缓存"],[-1,121,"的"],[1,122,"L"],[1,170,"RU是近期最少使用的"],[1,180,"：**"],[-1,190,"：**"],[1,220,"**"],[1,221,"\n\n"],[-1,230,"**"],[-1,233,"\n\n"],[1,250,"\n"],[-1,260,"\n"],[-1,375,"其实LRU缓存的实现"],[1,385,"## 二、LruC"],[1,387,"h"],[1,703,"\n"],[1,704,"``\n"],[-1,713,"\n"],[-1,715,"``\n"],[1,787,"\n\n"],[1,788,"``\n"],[-1,797,"\n\n"],[-1,800,"``\n"],[-1,1136,"![](https:"],[1,1146,"### LruCa"],[1,1149,"使"],[-1,1512,"程"],[1,1513," "],[-1,1558,"："],[1,1561,"："],[-1,1568,"**"],[1,1571,"个缓"],[-1,1590,"#"],[1,1600,"的"],[-1,1674,"尾"],[1,1675,"头"],[-1,1684,"头"],[1,1685,"近"],[-1,1694,"头"],[1,1695,"尾"],[-1,1702,"如下尾所示：\n\n!。维护的，"],[1,1716,"这个队列由LinkedHas"],[-1,2415,"\n       "],[1,2423,"int"],[1,2425,"nitia"],[-1,2566,"1234567891"],[1,2576,"\n```\n其中`a"],[1,2581,"O"],[-1,2624,"以具体例子解释，"],[-1,2634,"\n\n```java\n"],[1,2644,"置为true时："]],[16,16],[2652,2652]]],[1519977624063,[null,[[-1,16,"## 一、Andr"],[-1,27,"d"],[1,36,"一般来说，缓存策略主"],[1,66,"，它们的"],[-1,66,"内存缓存"],[1,121,"的"],[-1,121,"L"],[-1,170,"RU是近期最少使用的"],[-1,190,"：**"],[1,203,"：**"],[-1,230,"**"],[-1,233,"\n\n"],[1,244,"**"],[1,245,"\n\n"],[-1,260,"\n"],[1,271,"\n"],[1,385,"其实LRU缓存的实现"],[-1,385,"## 二、LruC"],[-1,396,"h"],[-1,713,"\n"],[-1,715,"``\n"],[1,727,"\n"],[1,728,"``\n"],[-1,797,"\n\n"],[-1,800,"``\n"],[1,812,"\n\n"],[1,813,"``\n"],[1,1146,"![](https:"],[-1,1146,"### LruCa"],[-1,1158,"使"],[1,1522,"程"],[-1,1522," "],[1,1568,"："],[-1,1570,"："],[1,1578,"**"],[-1,1579,"个缓"],[1,1600,"#"],[-1,1609,"的"],[1,1684,"尾"],[-1,1684,"头"],[1,1694,"头"],[-1,1694,"近"],[1,1704,"头"],[-1,1704,"尾"],[1,1712,"如下尾所示：\n\n!。维护的，"],[-1,1712,"这个队列由LinkedHas"],[1,2425,"\n       "],[-1,2425,"int"],[-1,2430,"nitia"],[1,2576,"1234567891"],[-1,2576,"\n```\n其中`a"],[-1,2590,"O"],[1,2634,"以具体例子解释，"],[1,2636,"\n\n```java\n"],[-1,2636,"置为true时："]],[2652,2652],[16,16]]],[1519977566576,["gengmei_pxf@gengmei123.local",[[1,352,"\n"]],[352,352],[353,353]]],[1519977570723,["gengmei_pxf@gengmei123.local",[[1,261,"* "]],[261,261],[263,263]]],[1519977573064,["gengmei_pxf@gengmei123.local",[[-1,341,"和"]],[342,342],[341,341]]],[1519977573440,["gengmei_pxf@gengmei123.local",[[1,341,"\n"]],[341,341],[342,342]]],[1519977575058,["gengmei_pxf@gengmei123.local",[[1,342,"* "]],[342,342],[344,344]]],[1519977579296,["gengmei_pxf@gengmei123.local",[[-1,355,"，"]],[356,356],[355,355]]],[1519977584618,["gengmei_pxf@gengmei123.local",[[1,263,"**"]],[263,263],[265,265]]],[1519977589594,["gengmei_pxf@gengmei123.local",[[1,343,"**"]],[343,343],[345,345]]],[1519977592258,["gengmei_pxf@gengmei123.local",[[1,348,"**"]],[348,348],[350,350]]],[1519977594153,["gengmei_pxf@gengmei123.local",[[1,361,"**"]],[361,361],[363,363]]],[1519977598711,["gengmei_pxf@gengmei123.local",[[1,364,"\n"]],[364,364],[365,365]]],[1519977684064,[null,[[1,16,"## 一、Andr"],[1,18,"d"],[-1,26,"一般来说，缓存策略主"],[-1,66,"，它们的"],[1,70,"内存缓存"],[-1,121,"的"],[1,122,"L"],[1,170,"RU是近期最少使用的"],[1,180,"：**"],[-1,190,"：**"],[1,220,"**"],[1,221,"\n\n"],[-1,230,"**"],[-1,233,"\n\n"],[1,250,"\n* **"],[-1,260,"\n* **"],[-1,333,"和"],[1,334,"**\n* **"],[1,343,"he"],[-1,346,"* **e，"],[1,352,"\n"],[-1,361,"**\n\n"],[1,365,"存"],[-1,388,"其实LRU缓存的实现"],[1,398,"## 二、LruC"],[1,400,"h"],[1,716,"\n``"],[1,717,"\n"],[-1,726,"\n"],[-1,728,"``\n"],[1,800,"\n\n"],[1,801,"``\n"],[-1,810,"\n\n"],[-1,813,"``\n"],[-1,1149,"![](https:"],[1,1159,"### LruCa"],[1,1162,"使"],[-1,1525,"程"],[1,1526," "],[-1,1571,"："],[1,1574,"："],[-1,1581,"**"],[1,1584,"个缓"],[-1,1603,"#"],[1,1613,"的"],[-1,1687,"尾"],[1,1688,"头"],[-1,1697,"头"],[1,1698,"近"],[-1,1707,"头"],[1,1708,"尾"],[-1,1715,"如下尾所示：\n\n!。维护的，"],[1,1729,"这个队列由LinkedHas"],[-1,2428,"\n       "],[1,2436,"int"],[1,2438,"nitia"],[-1,2579,"1234567891"],[1,2589,"\n```\n其中`a"],[1,2594,"O"],[-1,2637,"以具体例子解释，"],[-1,2647,"\n\n```java\n"],[1,2657,"置为true时："]],[16,16],[2665,2665]]],[1519977684064,[null,[[-1,16,"## 一、Andr"],[-1,27,"d"],[1,36,"一般来说，缓存策略主"],[1,66,"，它们的"],[-1,66,"内存缓存"],[1,121,"的"],[-1,121,"L"],[-1,170,"RU是近期最少使用的"],[-1,190,"：**"],[1,203,"：**"],[-1,230,"**"],[-1,233,"\n\n"],[1,244,"**"],[1,245,"\n\n"],[-1,260,"\n* **"],[1,275,"\n* **"],[1,343,"和"],[-1,343,"**\n* **"],[-1,359,"he"],[1,364,"* **e，"],[-1,364,"\n"],[1,374,"**\n\n"],[-1,374,"存"],[1,398,"其实LRU缓存的实现"],[-1,398,"## 二、LruC"],[-1,409,"h"],[-1,726,"\n``"],[-1,730,"\n"],[1,740,"\n"],[1,741,"``\n"],[-1,810,"\n\n"],[-1,813,"``\n"],[1,825,"\n\n"],[1,826,"``\n"],[1,1159,"![](https:"],[-1,1159,"### LruCa"],[-1,1171,"使"],[1,1535,"程"],[-1,1535," "],[1,1581,"："],[-1,1583,"："],[1,1591,"**"],[-1,1592,"个缓"],[1,1613,"#"],[-1,1622,"的"],[1,1697,"尾"],[-1,1697,"头"],[1,1707,"头"],[-1,1707,"近"],[1,1717,"头"],[-1,1717,"尾"],[1,1725,"如下尾所示：\n\n!。维护的，"],[-1,1725,"这个队列由LinkedHas"],[1,2438,"\n       "],[-1,2438,"int"],[-1,2443,"nitia"],[1,2589,"1234567891"],[-1,2589,"\n```\n其中`a"],[-1,2603,"O"],[1,2647,"以具体例子解释，"],[1,2649,"\n\n```java\n"],[-1,2649,"置为true时："]],[2665,2665],[16,16]]],[1519977634041,["gengmei_pxf@gengmei123.local",[[1,3648,"#"]],[3648,3648],[3649,3649]]],[1519977638040,["gengmei_pxf@gengmei123.local",[[1,4423,"#"]],[4423,4423],[4424,4424]]],[1519977641656,["gengmei_pxf@gengmei123.local",[[1,5578,"#"]],[5578,5578],[5579,5579]]],[1519977650637,["gengmei_pxf@gengmei123.local",[[1,8566,"\n"]],[8564,8564],[8565,8565]]],[1519977652261,["gengmei_pxf@gengmei123.local",[[1,8567,"\n"]],[8565,8565],[8566,8566]]],[1519977670544,["gengmei_pxf@gengmei123.local",[[1,8566,"* [Android】源码分析 - LRUCache缓存实现原理](http://blog.csdn.net/u010983881/article/details/79050209)"]],[8566,8566],[8657,8657]]],[1519977676487,["gengmei_pxf@gengmei123.local",[[1,8568,"【"]],[8568,8568],[8569,8569]]],[1519977678612,["gengmei_pxf@gengmei123.local",[[-1,8569,"["]],[8570,8570],[8569,8569]]],[1519977682326,["gengmei_pxf@gengmei123.local",[[1,8569,"["]],[8569,8569],[8570,8570]]],[1519977721679,[null,[[1,16,"## 一、Andr"],[1,18,"d"],[-1,26,"一般来说，缓存策略主"],[-1,66,"，它们的"],[1,70,"内存缓存"],[-1,121,"的"],[1,122,"L"],[1,170,"RU是近期最少使用的"],[1,180,"：**"],[-1,190,"：**"],[1,220,"**"],[1,221,"\n\n"],[-1,230,"**"],[-1,233,"\n\n"],[1,250,"\n* **"],[-1,260,"\n* **"],[-1,333,"和"],[1,334,"**\n* **"],[1,343,"he"],[-1,346,"* **e，"],[1,352,"\n"],[-1,361,"**\n\n"],[1,365,"存"],[-1,388,"其实LRU缓存的实现"],[1,398,"## 二、LruC"],[1,400,"h"],[1,716,"\n``"],[1,717,"\n"],[-1,726,"\n"],[-1,728,"``\n"],[1,800,"\n\n"],[1,801,"``\n"],[-1,810,"\n\n"],[-1,813,"``\n"],[-1,1149,"![](https:"],[1,1159,"### LruCa"],[1,1162,"使"],[-1,1525,"程"],[1,1526," "],[-1,1571,"："],[1,1574,"："],[-1,1581,"**"],[1,1584,"个缓"],[-1,1603,"#"],[1,1613,"的"],[-1,1687,"尾"],[1,1688,"头"],[-1,1697,"头"],[1,1698,"近"],[-1,1707,"头"],[1,1708,"尾"],[-1,1715,"如下尾所示：\n\n!。维护的，"],[1,1729,"这个队列由LinkedHas"],[-1,2428,"\n       "],[1,2436,"int"],[1,2438,"nitia"],[-1,2579,"1234567891"],[1,2589,"\n```\n其中`a"],[1,2594,"O"],[-1,2637,"以具体例子解释，"],[-1,2647,"\n\n```java\n"],[1,2657,"置为true时："]],[16,16],[2665,2665]]],[1519977721679,[null,[[-1,16,"## 一、Andr"],[-1,27,"d"],[1,36,"一般来说，缓存策略主"],[1,66,"，它们的"],[-1,66,"内存缓存"],[1,121,"的"],[-1,121,"L"],[-1,170,"RU是近期最少使用的"],[-1,190,"：**"],[1,203,"：**"],[-1,230,"**"],[-1,233,"\n\n"],[1,244,"**"],[1,245,"\n\n"],[-1,260,"\n* **"],[1,275,"\n* **"],[1,343,"和"],[-1,343,"**\n* **"],[-1,359,"he"],[1,364,"* **e，"],[-1,364,"\n"],[1,374,"**\n\n"],[-1,374,"存"],[1,398,"其实LRU缓存的实现"],[-1,398,"## 二、LruC"],[-1,409,"h"],[-1,726,"\n``"],[-1,730,"\n"],[1,740,"\n"],[1,741,"``\n"],[-1,810,"\n\n"],[-1,813,"``\n"],[1,825,"\n\n"],[1,826,"``\n"],[1,1159,"![](https:"],[-1,1159,"### LruCa"],[-1,1171,"使"],[1,1535,"程"],[-1,1535," "],[1,1581,"："],[-1,1583,"："],[1,1591,"**"],[-1,1592,"个缓"],[1,1613,"#"],[-1,1622,"的"],[1,1697,"尾"],[-1,1697,"头"],[1,1707,"头"],[-1,1707,"近"],[1,1717,"头"],[-1,1717,"尾"],[1,1725,"如下尾所示：\n\n!。维护的，"],[-1,1725,"这个队列由LinkedHas"],[1,2438,"\n       "],[-1,2438,"int"],[-1,2443,"nitia"],[1,2589,"1234567891"],[-1,2589,"\n```\n其中`a"],[-1,2603,"O"],[1,2647,"以具体例子解释，"],[1,2649,"\n\n```java\n"],[-1,2649,"置为true时："]],[2665,2665],[16,16]]],[1519977684395,["gengmei_pxf@gengmei123.local",[[-1,8568,"【"]],[8569,8569],[8568,8568]]],[1519977686750,["gengmei_pxf@gengmei123.local",[[1,8569,"【"]],[8569,8569],[8570,8570]]],[1519977692611,["gengmei_pxf@gengmei123.local",[[-1,8567," "]],[8568,8568],[8567,8567]]],[1519977695862,["gengmei_pxf@gengmei123.local",[[1,8567,"  "]],[8567,8567],[8569,8569]]],[1519977704942,["gengmei_pxf@gengmei123.local",[[-1,8567,"  "]],[8569,8569],[8567,8567]]],[1519977706197,["gengmei_pxf@gengmei123.local",[[1,8567," "]],[8567,8567],[8568,8568]]],[1519977715214,["gengmei_pxf@gengmei123.local",[[-1,8569,"【"],[-1,8571,"ndroid】"]],[8569,8578],[8569,8570]]],[1519977715455,["gengmei_pxf@gengmei123.local",[[1,8570,"n"]],[8569,8570],[8569,8571]]],[1519977715601,["gengmei_pxf@gengmei123.local",[[1,8571,"d"]],[8569,8571],[8569,8572]]],[1519977715826,["gengmei_pxf@gengmei123.local",[[1,8572,"r"]],[8569,8572],[8569,8573]]],[1519977715891,["gengmei_pxf@gengmei123.local",[[1,8573,"o"]],[8569,8573],[8569,8574]]],[1519977715980,["gengmei_pxf@gengmei123.local",[[1,8574,"i"]],[8569,8574],[8569,8575]]],[1519977716116,["gengmei_pxf@gengmei123.local",[[1,8575,"d"]],[8569,8575],[8569,8576]]]]]]}