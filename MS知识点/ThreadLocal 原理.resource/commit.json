{"compress":true,"commitItems":[["718a76d8-df8e-48db-a661-15823b6cba19",1520153403315,"",[[1520153345341,["gengmei_pxf@localhost",[[1,0,"ThreadLocal 原理\n===\n\n\n"]],[0,0],[21,21]]]]],["d9c43c46-05f3-4a0c-8206-2a62275e0220",1520234745936,"ThreadLocal 原理\n===\n\n\n",[[1520234730101,["gengmei_pxf@gengmei123.local",[[1,20,"## ThreadLocal是什么\n\nThreadLocal是一个关于创建线程局部变量的类。\n\n通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。\n\n## Global && Local\n\n上面的两个修饰看似矛盾，实则不然。\n\n*   Global 意思是在当前线程中，任何一个点都可以访问到ThreadLocal的值。\n*   Local 意思是该线程的ThreadLocal只能被该线程访问，一般情况下其他线程访问不到。\n\n## 用法简介\n\n### 创建，支持泛型\n\n| \n\n1\n\n | \n\n```\nThreadLocal<String> mStringThreadLocal = new ThreadLocal<>();\n\n```\n\n |\n\n### set方法\n\n| \n\n1\n\n | \n\n```\nmStringThreadLocal.set(\"droidyue.com\");\n\n```\n\n |\n\n### get方法\n\n| \n\n1\n\n | \n\n```\nmStringThreadLocal.get();\n\n```\n\n |\n\n完整的使用示例\n\n| \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n | \n\n```\nprivate void testThreadLocal() {\n    Thread t = new Thread() {\n        ThreadLocal<String> mStringThreadLocal = new ThreadLocal<>();\n\n        @Override\n        public void run() {\n            super.run();\n            mStringThreadLocal.set(\"droidyue.com\");\n            mStringThreadLocal.get();\n        }\n    };\n\n    t.start();\n}\n\n```\n\n |\n\n### ThreadLocal初始值\n\n为ThreadLocal设置默认的get初始值，需要重写`initialValue`方法，下面是一段代码，我们将默认值修改成了线程的名字\n\n| \n\n1\n2\n3\n4\n5\n6\n\n | \n\n```\nThreadLocal<String> mThreadLocal = new ThreadLocal<String>() {\n    @Override\n    protected String initialValue() {\n      return Thread.currentThread().getName();\n    }\n};\n\n```\n\n |\n\n## Android中的应用\n\n在Android中，Looper类就是利用了ThreadLocal的特性，保证每个线程只存在一个Looper对象。\n\n| \n\n1\n2\n3\n4\n5\n6\n7\n\n | \n\n```\nstatic final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();\nprivate static void prepare(boolean quitAllowed) {\n    if (sThreadLocal.get() != null) {\n        throw new RuntimeException(\"Only one Looper may be created per thread\");\n    }\n    sThreadLocal.set(new Looper(quitAllowed));\n}\n\n```\n\n |\n\n## 如何实现\n\n为了更好的掌握ThreadLocal，我认为了解其内部实现是很有必要的，这里我们以set方法从起始看一看ThreadLocal的实现原理。\n\n下面是ThreadLocal的set方法，大致意思为\n\n*   首先获取当前线程\n*   利用当前线程作为句柄获取一个ThreadLocalMap的对象\n*   如果上述ThreadLocalMap对象不为空，则设置值，否则创建这个ThreadLocalMap对象并设置值\n\n源码如下\n\n| \n\n1\n2\n3\n4\n5\n6\n7\n8\n\n | \n\n```\npublic void set(T value) {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n}\n\n```\n\n |\n\n下面是一个利用Thread对象作为句柄获取ThreadLocalMap对象的代码\n\n| \n\n1\n2\n3\n\n | \n\n```\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n\n```\n\n |\n\n上面的代码获取的实际上是Thread对象的threadLocals变量，可参考下面代码\n\n| \n\n1\n2\n3\n4\n5\n6\n\n | \n\n```\nclass Thread implements Runnable {\n    /* ThreadLocal values pertaining to this thread. This map is maintained\n     * by the ThreadLocal class. */\n\n    ThreadLocal.ThreadLocalMap threadLocals = null;\n}\n\n```\n\n |\n\n而如果一开始设置，即ThreadLocalMap对象未创建，则新建ThreadLocalMap对象，并设置初始值。\n\n| \n\n1\n2\n3\n\n | \n\n```\nvoid createMap(Thread t, T firstValue) {\n    t.threadLocals = new ThreadLocalMap(this, firstValue);\n}\n\n```\n\n |\n\n总结：实际上ThreadLocal的值是放入了当前线程的一个ThreadLocalMap实例中，所以只能在本线程中访问，其他线程无法访问。\n\n## 对象存放在哪里\n\n在Java中，栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。\n\n### 问：那么是不是说ThreadLocal的实例以及其值存放在栈上呢？\n\n其实不是，因为ThreadLocal实例实际上也是被其创建的类持有（更顶端应该是被线程持有）。而ThreadLocal的值其实也是被线程实例持有。\n\n**它们都是位于堆上，只是通过一些技巧将可见性修改成了线程可见。**\n\n关于堆和栈的比较，请参考[Java中的堆和栈的区别](http://droidyue.com/blog/2014/12/07/differences-between-stack-and-heap-in-java/ \"Java中的堆和栈的区别\")\n\n## 真的只能被一个线程访问么\n\n既然上面提到了ThreadLocal只对当前线程可见，是不是说ThreadLocal的值只能被一个线程访问呢？\n\n使用InheritableThreadLocal可以实现多个线程访问ThreadLocal的值。\n\n如下，我们在主线程中创建一个InheritableThreadLocal的实例，然后在子线程中得到这个InheritableThreadLocal实例设置的值。\n\n| \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n | \n\n```\nprivate void testInheritableThreadLocal() {\n    final ThreadLocal threadLocal = new InheritableThreadLocal();\n    threadLocal.set(\"droidyue.com\");\n    Thread t = new Thread() {\n        @Override\n        public void run() {\n            super.run();\n            Log.i(LOGTAG, \"testInheritableThreadLocal =\" + threadLocal.get());\n        }\n    };\n\n    t.start();\n}\n\n```\n\n |\n\n上面的代码输出的日志信息为\n\n| \n\n1\n\n | \n\n```\nI/MainActivity( 5046): testInheritableThreadLocal =droidyue.com\n\n```\n\n |\n\n使用InheritableThreadLocal可以将某个线程的ThreadLocal值在其子线程创建时传递过去。因为在线程创建过程中，有相关的处理逻辑。\n\n| \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n | \n\n```\n//Thread.java\n private void init(ThreadGroup g, Runnable target, String name,\n                      long stackSize, AccessControlContext acc) {\n        //code goes here\n        if (parent.inheritableThreadLocals != null)\n            this.inheritableThreadLocals =\n                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);\n        /* Stash the specified stack size in case the VM cares */\n        this.stackSize = stackSize;\n\n        /* Set thread ID */\n        tid = nextThreadID();\n}\n\n```\n\n |\n\n上面代码就是在线程创建的时候，复制父线程的inheritableThreadLocals的数据。\n\n## 会导致内存泄露么\n\n有网上讨论说ThreadLocal会导致内存泄露，原因如下\n\n*   首先ThreadLocal实例被线程的ThreadLocalMap实例持有，也可以看成被线程持有。\n*   如果应用使用了线程池，那么之前的线程实例处理完之后出于复用的目的依然存活\n*   所以，ThreadLocal设定的值被持有，导致内存泄露。\n\n上面的逻辑是清晰的，可是ThreadLocal并不会产生内存泄露，因为ThreadLocalMap在选择key的时候，并不是直接选择ThreadLocal实例，而是ThreadLocal实例的弱引用。\n\n| \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n | \n\n```\nstatic class ThreadLocalMap {\n\n/**\n* The entries in this hash map extend WeakReference, using\n* its main ref field as the key (which is always a\n* ThreadLocal object).  Note that null keys (i.e. entry.get()\n* == null) mean that the key is no longer referenced, so the\n* entry can be expunged from table.  Such entries are referred to\n* as \"stale entries\" in the code that follows.\n*/\n    static class Entry extends WeakReference<ThreadLocal<?>> {\n        /** The value associated with this ThreadLocal. */\n        Object value;\n\n        Entry(ThreadLocal<?> k, Object v) {\n            super(k);\n            value = v;\n        }\n    }\n}\n\n```\n\n |\n\n所以实际上从ThreadLocal设计角度来说是不会导致内存泄露的。关于弱引用，了解更多，请访问[译文：理解Java中的弱引用](http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/ \"译文：理解Java中的弱引用\n\")\n\n## 使用场景\n\n*   实现单个线程单例以及单个线程上下文信息存储，比如交易id等\n*   实现线程安全，非线程安全的对象使用ThreadLocal之后就会变得线程安全，因为每个线程都会有一个对应的实例\n*   承载一些线程相关的数据，避免在方法中来回传递参数\n\n**注意：Android的ThreadLocal与Java实现略有不同，但是原理是一致的**。"]],[20,20],[5903,5903]]],[1520234742008,["gengmei_pxf@gengmei123.local",[[-1,303,"| \n\n1\n\n | "]],[303,313],[303,303]]],[1520234742512,["gengmei_pxf@gengmei123.local",[[-1,304,"\n"]],[303,303],[302,302]]],[1520234743183,["gengmei_pxf@gengmei123.local",[[-1,303,"\n"]],[302,302],[301,301]]],[1520234748047,["gengmei_pxf@gengmei123.local",[[-1,375," |"]],[375,377],[375,375]]],[1520234748383,["gengmei_pxf@gengmei123.local",[[-1,376,"\n"]],[375,375],[374,374]]],[1520234748735,["gengmei_pxf@gengmei123.local",[[-1,375,"\n"]],[374,374],[373,373]]],[1520234751423,["gengmei_pxf@gengmei123.local",[[-1,386,"| \n\n1\n\n | \n\n"]],[385,397],[385,385]]],[1520234751751,["gengmei_pxf@gengmei123.local",[[-1,385,"\n"]],[385,385],[384,384]]],[1520234752695,["gengmei_pxf@gengmei123.local",[[1,385,"\n"]],[384,384],[385,385]]],[1520234755975,["gengmei_pxf@gengmei123.local",[[-1,436," |\n"]],[435,438],[435,435]]],[1520234756335,["gengmei_pxf@gengmei123.local",[[-1,436,"\n"]],[435,435],[434,434]]],[1520234757447,["gengmei_pxf@gengmei123.local",[[-1,433,"`"]],[434,434],[433,433]]],[1520234758695,["gengmei_pxf@gengmei123.local",[[1,435,"\n"]],[433,433],[434,434]]],[1520234759479,["gengmei_pxf@gengmei123.local",[[1,436,"\n"]],[434,434],[435,435]]],[1520234760013,["gengmei_pxf@gengmei123.local",[[-1,436,"\n"]],[435,435],[434,434]]],[1520234760413,["gengmei_pxf@gengmei123.local",[[-1,435,"\n"]],[434,434],[433,433]]],[1520234760984,["gengmei_pxf@gengmei123.local",[[1,433,"`"]],[433,433],[434,434]]],[1520234764343,["gengmei_pxf@gengmei123.local",[[-1,447,"| \n\n1\n\n | \n"]],[447,458],[447,447]]],[1520234764759,["gengmei_pxf@gengmei123.local",[[-1,447,"\n"]],[447,447],[446,446]]],[1520234768487,["gengmei_pxf@gengmei123.local",[[-1,483," |"]],[484,485],[483,483]]],[1520234768943,["gengmei_pxf@gengmei123.local",[[-1,484,"\n"]],[483,483],[482,482]]],[1520234769639,["gengmei_pxf@gengmei123.local",[[-1,483,"\n"]],[482,482],[481,481]]],[1520234777095,["gengmei_pxf@gengmei123.local",[[-1,492,"| \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n | "]],[492,533],[492,492]]],[1520234777820,["gengmei_pxf@gengmei123.local",[[-1,493,"\n"]],[492,492],[491,491]]],[1520234778887,["gengmei_pxf@gengmei123.local",[[-1,492,"\n"]],[491,491],[490,490]]],[1520234783336,["gengmei_pxf@gengmei123.local",[[-1,835,"\n"]],[835,835],[834,834]]],[1520234784167,["gengmei_pxf@gengmei123.local",[[-1,832," |"]],[834,834],[832,832]]],[1520234784615,["gengmei_pxf@gengmei123.local",[[-1,832,"\n"]],[832,832],[831,831]]],[1520234787743,["gengmei_pxf@gengmei123.local",[[-1,921,"\n| \n\n1\n2\n3\n4\n5\n6\n\n |"]],[921,941],[921,921]]],[1520234788983,["gengmei_pxf@gengmei123.local",[[-1,920,"\n"]],[921,921],[920,920]]],[1520234792168,["gengmei_pxf@gengmei123.local",[[-1,1104," |\n\n"]],[1103,1107],[1103,1103]]],[1520234792574,["gengmei_pxf@gengmei123.local",[[-1,1103,"\n"]],[1103,1103],[1102,1102]]],[1520234796356,["gengmei_pxf@gengmei123.local",[[-1,1178,"| \n\n1\n2\n3\n4\n5\n6\n7\n\n | "]],[1178,1200],[1178,1178]]],[1520234796983,["gengmei_pxf@gengmei123.local",[[-1,1179,"\n"]],[1178,1178],[1177,1177]]],[1520234797663,["gengmei_pxf@gengmei123.local",[[-1,1178,"\n"]],[1177,1177],[1176,1176]]],[1520234801135,["gengmei_pxf@gengmei123.local",[[-1,1488," |"]],[1489,1490],[1488,1488]]],[1520234801511,["gengmei_pxf@gengmei123.local",[[-1,1489,"\n"]],[1488,1488],[1487,1487]]],[1520234801959,["gengmei_pxf@gengmei123.local",[[-1,1488,"\n"]],[1487,1487],[1486,1486]]],[1520234806540,["gengmei_pxf@gengmei123.local",[[-1,1712,"| \n\n1\n2\n3\n4\n5\n6\n7\n8\n\n | \n"]],[1711,1736],[1711,1711]]],[1520234807037,["gengmei_pxf@gengmei123.local",[[-1,1712,"\n"]],[1711,1711],[1710,1710]]],[1520234809814,["gengmei_pxf@gengmei123.local",[[-1,1915," |"]],[1917,1917],[1915,1915]]],[1520234810110,["gengmei_pxf@gengmei123.local",[[-1,1916,"\n"]],[1915,1915],[1914,1914]]],[1520234810598,["gengmei_pxf@gengmei123.local",[[-1,1915,"\n"]],[1914,1914],[1913,1913]]],[1520234813768,["gengmei_pxf@gengmei123.local",[[-1,1957,"| \n\n1\n2\n3\n\n |"]],[1957,1970],[1957,1957]]],[1520234814119,["gengmei_pxf@gengmei123.local",[[-1,1956,"\n"]],[1957,1957],[1956,1956]]],[1520234815270,["gengmei_pxf@gengmei123.local",[[-1,1955,"\n"]],[1956,1956],[1955,1955]]],[1520234818622,["gengmei_pxf@gengmei123.local",[[-1,2031," |\n"]],[2032,2034],[2031,2031]]],[1520234818998,["gengmei_pxf@gengmei123.local",[[-1,2031,"\n"]],[2031,2031],[2030,2030]]],[1520234819494,["gengmei_pxf@gengmei123.local",[[-1,2030,"\n"]],[2030,2030],[2029,2029]]],[1520234822598,["gengmei_pxf@gengmei123.local",[[-1,2075,"| \n\n1\n2\n3\n4\n5\n6\n\n | \n\n"]],[2074,2096],[2074,2074]]],[1520234827582,["gengmei_pxf@gengmei123.local",[[-1,2287," |\n\n"]],[2286,2290],[2286,2286]]],[1520234828038,["gengmei_pxf@gengmei123.local",[[-1,2286,"\n"]],[2286,2286],[2285,2285]]],[1520234830862,["gengmei_pxf@gengmei123.local",[[-1,2345,"| \n\n1\n2\n3\n\n | \n"]],[2344,2359],[2344,2344]]],[1520234831542,["gengmei_pxf@gengmei123.local",[[-1,2345,"\n"]],[2344,2344],[2343,2343]]],[1520234835238,["gengmei_pxf@gengmei123.local",[[-1,2457," |\n"]],[2456,2459],[2456,2456]]],[1520234835638,["gengmei_pxf@gengmei123.local",[[-1,2457,"\n"]],[2456,2456],[2455,2455]]],[1520234836590,["gengmei_pxf@gengmei123.local",[[-1,2454,"`"]],[2455,2455],[2454,2454]]],[1520234837901,["gengmei_pxf@gengmei123.local",[[1,2454,"`"]],[2454,2454],[2455,2455]]],[1520234846526,["gengmei_pxf@gengmei123.local",[[-1,3121,"| \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n | \n"]],[3120,3159],[3120,3120]]],[1520234847182,["gengmei_pxf@gengmei123.local",[[-1,3121,"\n"]],[3120,3120],[3119,3119]]],[1520234850612,["gengmei_pxf@gengmei123.local",[[-1,3493," |\n"]],[3492,3495],[3492,3492]]],[1520234850998,["gengmei_pxf@gengmei123.local",[[-1,3493,"\n"]],[3492,3492],[3491,3491]]],[1520234852302,["gengmei_pxf@gengmei123.local",[[-1,3490,"`"]],[3491,3491],[3490,3490]]],[1520234853205,["gengmei_pxf@gengmei123.local",[[1,3490,"`"]],[3490,3490],[3491,3491]]],[1520234855758,["gengmei_pxf@gengmei123.local",[[-1,3508,"| \n\n1\n\n | \n"]],[3507,3518],[3507,3507]]],[1520234856414,["gengmei_pxf@gengmei123.local",[[-1,3508,"\n"]],[3507,3507],[3506,3506]]],[1520234859518,["gengmei_pxf@gengmei123.local",[[-1,3582," |\n"]],[3582,3585],[3582,3582]]],[1520234859854,["gengmei_pxf@gengmei123.local",[[-1,3582,"\n"]],[3582,3582],[3581,3581]]],[1520234860965,["gengmei_pxf@gengmei123.local",[[-1,3581,"\n"]],[3581,3581],[3580,3580]]],[1520234864646,["gengmei_pxf@gengmei123.local",[[-1,3660,"| \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n | "]],[3660,3698],[3660,3660]]],[1520234865261,["gengmei_pxf@gengmei123.local",[[-1,3661,"\n"]],[3660,3660],[3659,3659]]],[1520234865718,["gengmei_pxf@gengmei123.local",[[-1,3660,"\n"]],[3659,3659],[3658,3658]]],[1520234869255,["gengmei_pxf@gengmei123.local",[[-1,4177," |\n\n"]],[4176,4180],[4176,4176]]],[1520234869638,["gengmei_pxf@gengmei123.local",[[-1,4176,"\n"]],[4176,4176],[4175,4175]]],[1520234874053,["gengmei_pxf@gengmei123.local",[[-1,4502,"| \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n | "]],[4502,4561],[4502,4502]]],[1520234874694,["gengmei_pxf@gengmei123.local",[[-1,4503,"\n"]],[4502,4502],[4501,4501]]],[1520234875181,["gengmei_pxf@gengmei123.local",[[-1,4502,"\n"]],[4501,4501],[4500,4500]]],[1520234879141,["gengmei_pxf@gengmei123.local",[[-1,5148," |"]],[5149,5150],[5148,5148]]],[1520234879509,["gengmei_pxf@gengmei123.local",[[-1,5149,"\n"]],[5148,5148],[5147,5147]]],[1520234879957,["gengmei_pxf@gengmei123.local",[[-1,5148,"\n"]],[5147,5147],[5146,5146]]],[1520234880917,["gengmei_pxf@gengmei123.local",[[-1,5145,"`"]],[5146,5146],[5145,5145]]],[1520234881889,["gengmei_pxf@gengmei123.local",[[1,5145,"`"]],[5145,5145],[5146,5146]]],[1520234978103,["gengmei_pxf@gengmei123.local",[[1,1119,"\n"]],[1118,1118],[1119,1119]]],[1520234979680,["gengmei_pxf@gengmei123.local",[[1,1120,"\n"]],[1118,1118],[1119,1119]]],[1520234980355,["gengmei_pxf@gengmei123.local",[[1,1119,"在handler机制中，之所以每个线程能够获得自身的looper，而不影响其他线程，是因为通过操作每个线程自身的localValues对象内部的table数组实现的，从而达到不同线程访问同一个threadLocal的get()和set()不会访问或修改到其他线程的数据。"]],[1119,1119],[1254,1254]]],[1520235007908,["gengmei_pxf@gengmei123.local",[[1,1120,"Android的"]],[1120,1120],[1128,1128]]],[1520235019237,["gengmei_pxf@gengmei123.local",[[-1,1139,"之所以每个线程能够获得自身的looper，而不影响其他线程，是因为通过操作每个线程自身的localValues对象内部的table数组实现的，从而达到不同线程访问同一个threadLocal的get()和set()不会访问或修改到其他线程的数据。"]],[1139,1262],[1139,1139]]],[1520235021018,["gengmei_pxf@gengmei123.local",[[1,1200,"\n"]],[1198,1198],[1199,1199]]],[1520235021513,["gengmei_pxf@gengmei123.local",[[1,1201,"\n"]],[1199,1199],[1200,1200]]],[1520235021884,["gengmei_pxf@gengmei123.local",[[1,1200,"之所以每个线程能够获得自身的looper，而不影响其他线程，是因为通过操作每个线程自身的localValues对象内部的table数组实现的，从而达到不同线程访问同一个threadLocal的get()和set()不会访问或修改到其他线程的数据。"]],[1200,1200],[1323,1323]]],[1520235025235,["gengmei_pxf@gengmei123.local",[[-1,1119,"在Android的handler机制中，"]],[1119,1139],[1119,1119]]],[1520235025618,["gengmei_pxf@gengmei123.local",[[-1,1120,"\n"]],[1119,1119],[1118,1118]]],[1520235026018,["gengmei_pxf@gengmei123.local",[[-1,1119,"\n"]],[1118,1118],[1117,1117]]],[1520235061454,["gengmei_pxf@gengmei123.local",[[-1,1178,"之所以每个线程能够获得自身的looper，而不影响其他线程，是因为通过操作每个线程自身"],[1,1221,"ThreadLocal 的set、get、remove方法都是针对**当前线程**"],[-1,1231,"es对象内部的"],[1,1238,"se变量中的**"],[-1,1245,"实现的，从而达到"],[1,1253,"**进行操作的，因此保证了"],[-1,1257,"访问同一个t"],[1,1263,"对一同个T"],[-1,1273,"的get()和set()不会访问或修改到其他线程的数据"],[1,1300,"实例进行数据操作的时候不会互相干扰。在Android中有个地方用到了ThreadLocal，那就是Looper，因为Looper的作用域就是线程，每个线程都有各自的Looper，所以系统把这些Looper都通过ThreadLocal进行存储，便于系统的管理和调度，省去了建立全局存储的麻烦"]],[1178,1301],[1421,1421]]],[1520235217722,["gengmei_pxf@gengmei123.local",[[-1,1119,"在Android中，Looper类就是利用了ThreadLocal的特性，保证每个线程只存在一个Looper对象。"]],[1119,1176],[1119,1119]]],[1520235218206,["gengmei_pxf@gengmei123.local",[[-1,1120,"\n"]],[1119,1119],[1118,1118]]],[1520235218515,["gengmei_pxf@gengmei123.local",[[-1,1119,"\n"]],[1118,1118],[1117,1117]]],[1520235220421,["gengmei_pxf@gengmei123.local",[[1,1364,"\n"]],[1362,1362],[1363,1363]]],[1520235220680,["gengmei_pxf@gengmei123.local",[[1,1365,"\n"]],[1363,1363],[1364,1364]]],[1520235221122,["gengmei_pxf@gengmei123.local",[[1,1364,"在Android中，Looper类就是利用了ThreadLocal的特性，保证每个线程只存在一个Looper对象。"]],[1364,1364],[1421,1421]]],[1520235223496,["gengmei_pxf@gengmei123.local",[[1,1364,"所以"]],[1364,1364],[1366,1366]]]]]]}