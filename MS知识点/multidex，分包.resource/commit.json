{"compress":true,"commitItems":[["47e39de0-c66a-4048-8c58-454d440919f0",1521471800013,"",[[1521471784720,["gengmei_pxf@gengmei123.local",[[1,0,"multidex，分包\n===\n\n\n[Android分包MultiDex源码分析](http://blog.csdn.net/shensky711/article/details/52845661)\n[dex分包变形记](https://segmentfault.com/a/1190000004053072)\n\n### MultiDex的产生背景\n\n当Android系统安装一个应用的时候，有一步是对Dex进行优化，这个过程有一个专门的工具来处理，叫DexOpt。DexOpt的执行过程是在第一次加载Dex文件的时候执行的。这个过程会生成一个ODEX文件，即Optimised Dex。执行ODex的效率会比直接执行Dex文件的效率要高很多。\n\n但是在早期的Android系统中，DexOpt有一个问题，DexOpt会把每一个类的方法id检索起来，存在一个链表结构里面。但是这个链表的长度是用一个short类型来保存的，导致了方法id的数目不能够超过65536个。当一个项目足够大的时候，显然这个方法数的上限是不够的。尽管在新版本的Android系统中，DexOpt修复了这个问题，但是我们仍然需要对低版本的Android系统做兼容。\n\n为了解决方法数超限的问题，需要将该dex文件拆成两个或多个，为此谷歌官方推出了multidex兼容包，配合AndroidStudio实现了一个APK包含多个dex的功能。\n\n* * *\n\n### MultiDex的简要原理\n\n我们以APK中有两个dex文件为例，第二个dex文件为classes2.dex。\n\n1.  兼容包在Applicaion实例化之后，会检查系统版本是否支持 multidex，classes2.dex是否需要安装。\n2.  如果需要安装则会从APK中解压出classes2.dex并将其拷贝到应用的沙盒目录下。\n3.  通过反射将classes2.dex注入到当前的classloader中。"]],[0,0],[828,828]]],[1521471787940,["gengmei_pxf@gengmei123.local",[[-1,158,"##"]],[160,160],[158,158]]],[1521471791062,["gengmei_pxf@gengmei123.local",[[-1,613,"##"]],[615,615],[613,613]]],[1521471909501,["gengmei_pxf@gengmei123.local",[[1,824,"\n\n"]],[824,824],[825,825]]],[1521471909958,["gengmei_pxf@gengmei123.local",[[1,826,"\n"]],[825,825],[826,826]]],[1521471910425,["gengmei_pxf@gengmei123.local",[[1,826,"## 关于65K方法限制\n\n我们知道Android中的可执行伟剑都存储在dex文件中，其中包含已编译的代码来运行你的应用程序。Dalvik虚拟机对可执行dex文件的规格是有方法限制的，即一个单一的dex文件的方法总数最多为65536。\n\n其中包括：\n\n*   引用的Android Framework方法\n*   library的方法\n*   我们自己书写代码的方法。\n\n为了突破这个方法数的限制，我们就提出了一个方案——生成多个dex文件。这个多个dex文件的方案，我们又称为multidex方案配置。\n\n**Multidex支持Android 5.0之前的版本** \n    Android5.0版本的平台之前，Android使用的是Dalvik Runtime执行的程序代码。默认情况下，限制应用到一个单一的classes.dex。\n\nDalvik字节码文件每APK。为了绕过这个限制，你可以使用multidex支持库，成为你的应用程序的主要部分和DEX文件进行管理，获得额外的dex文件，它们包含的代码。\n\n**Multidex支持Android 5.0及更高版本** \n    Android 5.0和更高的Runtime 如art，本身就支持从应用的APK文件加载多个DEX文件。art支持预编译的应用程序在安装时扫描类（..）。Dex文件编译成一个单一的Android设备上执行.oat文件。\n\n* * *\n\n## 避免65K限制\n\n当你确定使用multidex的分包策略的时候，请你先确定自己的代码中都是优秀的。你还需要做以下几步：\n\n*   去掉一些未使用的import和library\n*   使用ProGuard去掉一些未使用的代码"]],[826,826],[1553,1553]]],[1521471919327,["gengmei_pxf@gengmei123.local",[[-1,827,"#"],[-1,1110," \n    "],[1,1116," \n    "],[-1,1314," \n    "],[1,1320," \n    #"]],[827,827],[827,827]]],[1521471980014,[null,[[1,827,"#"],[-1,1319,"#"]],[827,827],[1319,1319]]],[1521471980014,[null,[[-1,827,"#"],[1,1320,"#"]],[1319,1319],[827,827]]],[1521471926560,["gengmei_pxf@gengmei123.local",[[1,1081,"## "]],[1081,1081],[1084,1084]]],[1521471930317,["gengmei_pxf@gengmei123.local",[[-1,1084,"**"]],[1086,1086],[1084,1084]]],[1521471933733,["gengmei_pxf@gengmei123.local",[[-1,1110,"**"]],[1112,1112],[1110,1110]]],[1521471937494,["gengmei_pxf@gengmei123.local",[[-1,1284,"**"],[1,1286,"## "]],[1284,1286],[1287,1287]]],[1521471939677,["gengmei_pxf@gengmei123.local",[[-1,1313,"**"]],[1315,1315],[1313,1313]]],[1521472100023,[null,[[1,827,"##"],[-1,1079,"**"],[1,1084,"Mu"],[-1,1108,"**"],[1,1110," \n"],[-1,1282,"**"],[1,1287,"Mu"],[-1,1311,"**"],[1,1313," \n"],[-1,1317,"#"]],[827,827],[1317,1317]]],[1521472100023,[null,[[-1,827,"##"],[1,1081,"**"],[-1,1084,"Mu"],[1,1110,"**"],[-1,1110," \n"],[1,1284,"**"],[-1,1287,"Mu"],[1,1313,"**"],[-1,1313," \n"],[1,1319,"#"]],[1317,1317],[827,827]]],[1521472053358,["gengmei_pxf@gengmei123.local",[[1,518,"\n"]],[516,516],[517,517]]],[1521472053612,["gengmei_pxf@gengmei123.local",[[1,519,"\n"]],[517,517],[518,518]]],[1521472054150,["gengmei_pxf@gengmei123.local",[[1,518,"1.  **DexOpt优化的限制**：当Android系统启动一个应用的时候，有一步是对Dex进行优化，这个过程有一个专门的工具来处理，叫DexOpt。DexOpt的执行过程是在第一次加载Dex文件的时候执行的。这个过程会生成一个ODEX文件，即Optimised Dex。执行ODex的效率会比直接执行Dex文件的效率要高很多。但是在早期的Android系统中，DexOpt有一个问题，也就是这篇文章想要说明并解决的问题。DexOpt会把每一个类的方法id检索起来，存在一个链表结构里面。但是这个链表的长度是用一个short类型来保存的，导致了方法id的数目不能够超过65536个。当一个项目足够大的时候，显然这个方法数的上限是不够的。尽管在新版本的Android系统中，DexOpt修复了这个问题，但是我们仍然需要对老系统做兼容\n2.  **dalvik bytecode的限制**：因为 Dalvik 的 invoke-kind 指令集中，method reference index 只留了 16 bits，最多能引用 65535 个方法，参考链接：[http://stackoverflow.com/questions/21490382/does-the-android-art-runtime-have-the-same-method-limit-limitations-as-dalvik/21492160#21492160](http://stackoverflow.com/questions/21490382/does-the-android-art-runtime-have-the-same-method-limit-limitations-as-dalvik/21492160#21492160)，[http://source.android.com/devices/tech/dalvik/dalvik-bytecode.html](http://source.android.com/devices/tech/dalvik/dalvik-bytecode.html)\n\n鉴于以上原因，在打包Android应用的时候，会对方法数做一个检测，当方法数超过了DexFormat.MAX_MEMBER_IDX（定义为0Xffff, 注意，这个**不是Dex文件格式的限制**，Dex文件中存储方法ID用的并不是short类型，无论最新的DexFile.h新定义的u4是uint32_t，还是老版本DexFile引用的vm/Common.h里定义的u4是uint32或者unsigned int，都不是short类型，特此说明）便报错"]],[518,518],[1646,1646]]],[1521472058525,["gengmei_pxf@gengmei123.local",[[1,886,"\n"]],[886,886],[887,887]]],[1521472134662,[null,[[1,1958,"##"],[-1,2210,"**"],[1,2215,"Mu"],[-1,2239,"**"],[1,2241," \n"],[-1,2413,"**"],[1,2418,"Mu"],[-1,2442,"**"],[1,2444," \n"],[-1,2448,"#"]],[1958,1958],[2448,2448]]],[1521472134662,[null,[[-1,1958,"##"],[1,2212,"**"],[-1,2215,"Mu"],[1,2241,"**"],[-1,2241," \n"],[1,2415,"**"],[-1,2418,"Mu"],[1,2444,"**"],[-1,2444," \n"],[1,2450,"#"]],[2448,2448],[1958,1958]]],[1521472107100,["gengmei_pxf@gengmei123.local",[[1,2684,"\n"]],[2683,2683],[2684,2684]]],[1521472107315,["gengmei_pxf@gengmei123.local",[[1,2685,"\n"]],[2684,2684],[2685,2685]]],[1521472107919,["gengmei_pxf@gengmei123.local",[[1,2685,"# 谷歌分包方案\n\n谷歌提供了一个multiDex的分包方案，当方法数超过65536的时候，生成多个dex文件，把应用启动时必须用到的类和该类的直接引用类放到main dex中，把其他类放到second dex中。当应用启动之后，动态加载second dex，从而避免64k问题。使用Android Studio很容易实现分包方案： \n![这里写图片描述](http://img.blog.csdn.net/20160826154025452)\n\n1.  在build.gradle中添加：multiDexEnabled true\n2.  加入依赖‘compile ‘com.android.support:multidex:1.0.1’’\n3.  让应用的Application类直接使用或者继承MultiDexApplication\n4.  如果你想使用自定义的Application，又不想继承MultiDexApplication，那么可以在attachBaseContext方法里执行MultiDex.install(base)\n\n以上就是谷歌multiDex方案所需做的设置，通过配置multiDex，便可解决64k方法数限制\n\n# 谷歌multiDex存在的问题\n\n虽然谷歌的分包方案很简单，但是效果并不是那么好，谷歌本身也枚举了分包方案的**缺点**：\n\n1.  如果在主线程中执行MultiDex.install，加载second dex，因为加载从dex是同步的，会阻塞线程，second dex太大的话，有可能导致ANR\n2.  API Level 14之前，由于Dalvik LinearAlloc bug（问题22586，就是上文提到的LinearAlloc问题），很可能会出问题的\n3.  应用程序使用了multiedex配置的，会造成使用比较大的内存\n4.  对于应用程序比较复杂的，存在较多的library的项目。multidex可能会造成不同依赖项目间的dex文件函数相互调用，找不到方法\n\n# 如何解决谷歌分包方案的问题\n\n针对上面的问题，参考网上的一些解决方案，如美团、facebook、微信等，初步使用的解决方法如下：\n\n1.  第一次启动的时候，检测到未曾加载过second dex，那么启动欢迎页面（启动新的进程，原来进程进入阻塞等待，注意，此时不会发生ANR，因为已经不是前台进程了），在欢迎页面里面进行second dex的加载，加载完成后通知主线程继续\n2.  设定单个dex文件最大方法数为48000（经验值）而不是65536，避免内存问题\n3.  同上\n4.  控制程序逻辑，未曾加载完second dex之前，进入阻塞等待，直到加载完程序才往下走\n\n下面是流程图：\n\n![这里写图片描述](http://img.blog.csdn.net/20160826154042949)"]],[2685,2685],[3901,3901]]],[1521472254674,[null,[[-1,1958,""],[1,1958,"##"],[-1,2210,"**"],[1,2215,"Mu"],[-1,2239,"**"],[1,2241," \n"],[-1,2413,"**"],[1,2418,"Mu"],[-1,2442,"**"],[1,2444," \n"],[-1,2448,"#"],[-1,2682,"\n"],[1,2683,""],[1,3901,"\n"]],[1958,1958],[3902,3902]]],[1521472254674,[null,[[1,1958,""],[-1,1958,"##"],[1,2212,"**"],[-1,2215,"Mu"],[1,2241,"**"],[-1,2241," \n"],[1,2415,"**"],[-1,2418,"Mu"],[1,2444,"**"],[-1,2444," \n"],[1,2450,"#"],[1,2683,"\n"],[-1,2683,""],[-1,3901,"\n"]],[3902,3902],[1958,1958]]],[1521472252384,["gengmei_pxf@gengmei123.local",[[1,157,"\n"],[-1,2851," "],[1,2852," # Android最大方法数和解决方案"]],[155,155],[175,175]]],[1521472253460,["gengmei_pxf@gengmei123.local",[[-1,157,"\n"],[1,2852," "],[-1,2852," # Android最大方法数和解决方案"]],[175,175],[155,155]]],[1521472292144,[null,[[1,156,"#Android最大方法数和解决方案\n"],[-1,1958,""],[1,1958,"##"],[-1,2210,"**"],[1,2215,"Mu"],[-1,2239,"**"],[1,2241," \n"],[-1,2413,"**"],[1,2418,"Mu"],[-1,2442,"**"],[1,2444," \n"],[-1,2448,"#"],[-1,2684,"\n"],[-1,2832,"id Studio很容易实现分包方案："],[1,2851,""],[-1,3901,""],[1,3901,"\n"]],[156,156],[3902,3902]]],[1521472292144,[null,[[-1,156,"#Android最大方法数和解决方案\n"],[1,1977,""],[-1,1977,"##"],[1,2231,"**"],[-1,2234,"Mu"],[1,2260,"**"],[-1,2260," \n"],[1,2434,"**"],[-1,2437,"Mu"],[1,2463,"**"],[-1,2463," \n"],[1,2469,"#"],[1,2704,"\n"],[1,2851,"id Studio很容易实现分包方案："],[-1,2851,""],[1,3901,""],[-1,3901,"\n"]],[3902,3902],[156,156]]],[1521472257598,["gengmei_pxf@gengmei123.local",[[-1,2685,"# 谷歌分包方案\n\n谷歌提供了一个multiDex的分包方案，当方法数超过65536的时候，生成多个dex文件，把应用启动时必须用到的类和该类的直接引用类放到main dex中，把其他类放到second dex中。当应用启动之后，动态加载second dex，从而避免64k问题。使用Android Studio很容易实现分包方案： \n![这里写图片描述](http://img.blog.csdn.net/20160826154025452)\n\n1.  在build.gradle中添加：multiDexEnabled true\n2.  加入依赖‘compile ‘com.android.support:multidex:1.0.1’’\n3.  让应用的Application类直接使用或者继承MultiDexApplication\n4.  如果你想使用自定义的Application，又不想继承MultiDexApplication，那么可以在attachBaseContext方法里执行MultiDex.install(base)\n\n以上就是谷歌multiDex方案所需做的设置，通过配置multiDex，便可解决64k方法数限制\n\n# 谷歌multiDex存在的问题\n\n虽然谷歌的分包方案很简单，但是效果并不是那么好，谷歌本身也枚举了分包方案的**缺点**：\n\n1.  如果在主线程中执行MultiDex.install，加载second dex，因为加载从dex是同步的，会阻塞线程，second dex太大的话，有可能导致ANR\n2.  API Level 14之前，由于Dalvik LinearAlloc bug（问题22586，就是上文提到的LinearAlloc问题），很可能会出问题的\n3.  应用程序使用了multiedex配置的，会造成使用比较大的内存\n4.  对于应用程序比较复杂的，存在较多的library的项目。multidex可能会造成不同依赖项目间的dex文件函数相互调用，找不到方法\n\n# 如何解决谷歌分包方案的问题\n\n针对上面的问题，参考网上的一些解决方案，如美团、facebook、微信等，初步使用的解决方法如下：\n\n1.  第一次启动的时候，检测到未曾加载过second dex，那么启动欢迎页面（启动新的进程，原来进程进入阻塞等待，注意，此时不会发生ANR，因为已经不是前台进程了），在欢迎页面里面进行second dex的加载，加载完成后通知主线程继续\n2.  设定单个dex文件最大方法数为48000（经验值）而不是65536，避免内存问题\n3.  同上\n4.  控制程序逻辑，未曾加载完second dex之前，进入阻塞等待，直到加载完程序才往下走\n\n下面是流程图：\n\n![这里写图片描述](http://img.blog.csdn.net/20160826154042949)"]],[3901,3901],[2685,2685]]],[1521472260931,["gengmei_pxf@gengmei123.local",[[-1,2685,"\n"]],[2685,2685],[2684,2684]]],[1521472264787,["gengmei_pxf@gengmei123.local",[[-1,156,"#Android最大方法数和解决方案"]],[156,174],[156,156]]],[1521472267467,["gengmei_pxf@gengmei123.local",[[1,156,"[]()"]],[156,156],[160,160]]],[1521472269821,["gengmei_pxf@gengmei123.local",[[1,157,"# Android最大方法数和解决方案"]],[157,157],[176,176]]],[1521472272706,["gengmei_pxf@gengmei123.local",[[-1,157,"# "]],[159,159],[157,157]]],[1521472280045,["gengmei_pxf@gengmei123.local",[[1,176,"http://blog.csdn.net/shensky711/article/details/52329035"]],[176,176],[232,232]]],[1521472285665,["gengmei_pxf@gengmei123.local",[[1,18,"* "]],[18,18],[20,20]]],[1521472287867,["gengmei_pxf@gengmei123.local",[[1,102,"* "]],[102,102],[104,104]]],[1521472289921,["gengmei_pxf@gengmei123.local",[[1,160,"* "]],[160,160],[162,162]]],[1521472352145,[null,[[1,239,"\n\n# MultiDex的产生背景\n\n"],[-1,2023,""],[1,2023,"##"],[-1,2275,"**"],[1,2280,"Mu"],[-1,2304,"**"],[1,2306," \n"],[-1,2478,"**"],[1,2483,"Mu"],[-1,2507,"**"],[1,2509," \n"],[-1,2513,"#"],[-1,2730,"roGuard去掉一些未使用的代码\n\n\n"],[1,2750,""]],[239,239],[2750,2750]]],[1521472352145,[null,[[-1,239,"\n\n# MultiDex的产生背景\n\n"],[1,2042,""],[-1,2042,"##"],[1,2296,"**"],[-1,2299,"Mu"],[1,2325,"**"],[-1,2325," \n"],[1,2499,"**"],[-1,2502,"Mu"],[1,2528,"**"],[-1,2528," \n"],[1,2534,"#"],[1,2750,"roGuard去掉一些未使用的代码\n\n\n"],[-1,2750,""]],[2750,2750],[239,239]]],[1521472324647,["gengmei_pxf@gengmei123.local",[[1,2750,"\n\n"]],[2750,2750],[2751,2751]]],[1521472325079,["gengmei_pxf@gengmei123.local",[[1,2752,"\n"]],[2751,2751],[2752,2752]]],[1521472326369,["gengmei_pxf@gengmei123.local",[[1,2752,"# 什么是64K限制和LinearAlloc限制\n\n## 64K限制\n\n随着Android应用功能的增加，代码量不断地增大，当应用方法数量超过了65536的时候，编译的时候便会提示： \n![这里写图片描述](http://img.blog.csdn.net/20160826154008202)\n\n这个Android著名的Dex 64k method数量上限。那么，是什么原因导致方法数不能超过64K呢？网上搜集了一下资料，原因一般有：\n\n1.  **DexOpt优化的限制**：当Android系统启动一个应用的时候，有一步是对Dex进行优化，这个过程有一个专门的工具来处理，叫DexOpt。DexOpt的执行过程是在第一次加载Dex文件的时候执行的。这个过程会生成一个ODEX文件，即Optimised Dex。执行ODex的效率会比直接执行Dex文件的效率要高很多。但是在早期的Android系统中，DexOpt有一个问题，也就是这篇文章想要说明并解决的问题。DexOpt会把每一个类的方法id检索起来，存在一个链表结构里面。但是这个链表的长度是用一个short类型来保存的，导致了方法id的数目不能够超过65536个。当一个项目足够大的时候，显然这个方法数的上限是不够的。尽管在新版本的Android系统中，DexOpt修复了这个问题，但是我们仍然需要对老系统做兼容\n2.  **dalvik bytecode的限制**：因为 Dalvik 的 invoke-kind 指令集中，method reference index 只留了 16 bits，最多能引用 65535 个方法，参考链接：[http://stackoverflow.com/questions/21490382/does-the-android-art-runtime-have-the-same-method-limit-limitations-as-dalvik/21492160#21492160](http://stackoverflow.com/questions/21490382/does-the-android-art-runtime-have-the-same-method-limit-limitations-as-dalvik/21492160#21492160)，[http://source.android.com/devices/tech/dalvik/dalvik-bytecode.html](http://source.android.com/devices/tech/dalvik/dalvik-bytecode.html)\n\n鉴于以上原因，在打包Android应用的时候，会对方法数做一个检测，当方法数超过了DexFormat.MAX_MEMBER_IDX（定义为0Xffff, 注意，这个**不是Dex文件格式的限制**，Dex文件中存储方法ID用的并不是short类型，无论最新的DexFile.h新定义的u4是uint32_t，还是老版本DexFile引用的vm/Common.h里定义的u4是uint32或者unsigned int，都不是short类型，特此说明）便报错\n\n## LinearAlloc限制\n\n即使方法数没有超过65536，能正常编译打包成apk，在安装的时候，也有可能会提示INSTALL_FAILED_DEXOPT而导致安装失败，这个一般就是因为LinearAlloc的限制导致的。这个主要是因为Dexopt 使用 LinearAlloc 来存储应用的方法信息。Dalvik LinearAlloc 是一个固定大小的缓冲区。在Android 版本的历史上，LinearAlloc 分别经历了4M/5M/8M/16M限制。Android 2.2和2.3的缓冲区只有5MB，Android 4.x提高到了8MB 或16MB。当方法数量过多导致超出缓冲区大小时，也会造成dexopt崩溃\n\n# 谷歌分包方案\n\n谷歌提供了一个multiDex的分包方案，当方法数超过65536的时候，生成多个dex文件，把应用启动时必须用到的类和该类的直接引用类放到main dex中，把其他类放到second dex中。当应用启动之后，动态加载second dex，从而避免64k问题。使用Android Studio很容易实现分包方案： \n![这里写图片描述](http://img.blog.csdn.net/20160826154025452)\n\n1.  在build.gradle中添加：multiDexEnabled true\n2.  加入依赖‘compile ‘com.android.support:multidex:1.0.1’’\n3.  让应用的Application类直接使用或者继承MultiDexApplication\n4.  如果你想使用自定义的Application，又不想继承MultiDexApplication，那么可以在attachBaseContext方法里执行MultiDex.install(base)\n\n以上就是谷歌multiDex方案所需做的设置，通过配置multiDex，便可解决64k方法数限制\n\n# 谷歌multiDex存在的问题\n\n虽然谷歌的分包方案很简单，但是效果并不是那么好，谷歌本身也枚举了分包方案的**缺点**：\n\n1.  如果在主线程中执行MultiDex.install，加载second dex，因为加载从dex是同步的，会阻塞线程，second dex太大的话，有可能导致ANR\n2.  API Level 14之前，由于Dalvik LinearAlloc bug（问题22586，就是上文提到的LinearAlloc问题），很可能会出问题的\n3.  应用程序使用了multiedex配置的，会造成使用比较大的内存\n4.  对于应用程序比较复杂的，存在较多的library的项目。multidex可能会造成不同依赖项目间的dex文件函数相互调用，找不到方法\n\n# 如何解决谷歌分包方案的问题\n\n针对上面的问题，参考网上的一些解决方案，如美团、facebook、微信等，初步使用的解决方法如下：\n\n1.  第一次启动的时候，检测到未曾加载过second dex，那么启动欢迎页面（启动新的进程，原来进程进入阻塞等待，注意，此时不会发生ANR，因为已经不是前台进程了），在欢迎页面里面进行second dex的加载，加载完成后通知主线程继续\n2.  设定单个dex文件最大方法数为48000（经验值）而不是65536，避免内存问题\n3.  同上\n4.  控制程序逻辑，未曾加载完second dex之前，进入阻塞等待，直到加载完程序才往下走\n\n下面是流程图：\n\n![这里写图片描述](http://img.blog.csdn.net/20160826154042949)"]],[2752,2752],[5633,5633]]],[1521472360495,[null,[[1,239,"\n\n# MultiDex的产生背景\n\n"],[-1,2023,""],[1,2023,"##"],[-1,2275,"**"],[1,2280,"Mu"],[-1,2304,"**"],[1,2306," \n"],[-1,2478,"**"],[1,2483,"Mu"],[-1,2507,"**"],[1,2509," \n"],[-1,2513,"#"],[-1,2730,"roGuard去掉一些未使用的代码\n\n\n"],[1,2750,""]],[239,239],[2750,2750]]],[1521472360495,[null,[[-1,239,"\n\n# MultiDex的产生背景\n\n"],[1,2042,""],[-1,2042,"##"],[1,2296,"**"],[-1,2299,"Mu"],[1,2325,"**"],[-1,2325," \n"],[1,2499,"**"],[-1,2502,"Mu"],[1,2528,"**"],[-1,2528," \n"],[1,2534,"#"],[1,2750,"roGuard去掉一些未使用的代码\n\n\n"],[-1,2750,""]],[2750,2750],[239,239]]],[1521472355352,["gengmei_pxf@gengmei123.local",[[1,2720,"*   "],[1,2750,"roGuard去掉一些未使用的代码"],[-1,2843," "],[1,2844," "],[-1,4583," "],[1,4584," "]],[2720,2750],[2771,2771]]],[1521472358622,["gengmei_pxf@gengmei123.local",[[-1,2716,"*   "]],[2720,2720],[2716,2716]]],[1521472485768,[null,[[1,239,"\n\n# MultiDex的产生背景\n\n"],[-1,2023,""],[1,2023,"##"],[-1,2275,"**"],[1,2280,"Mu"],[-1,2304,"**"],[1,2306," \n"],[-1,2478,"**"],[1,2483,"Mu"],[-1,2507,"**"],[1,2509," \n"],[-1,2513,"#"],[-1,2716,"*   "],[1,2720,"ibra"],[-1,2730,"roGuard去掉一些未使用的代码\n\n\n"]],[239,239],[2730,2730]]],[1521472485768,[null,[[-1,239,"\n\n# MultiDex的产生背景\n\n"],[1,2042,""],[-1,2042,"##"],[1,2296,"**"],[-1,2299,"Mu"],[1,2325,"**"],[-1,2325," \n"],[1,2499,"**"],[-1,2502,"Mu"],[1,2528,"**"],[-1,2528," \n"],[1,2534,"#"],[1,2736,"*   "],[-1,2736,"ibra"],[1,2750,"roGuard去掉一些未使用的代码\n\n\n"]],[2730,2730],[239,239]]],[1521472481145,["gengmei_pxf@gengmei123.local",[[-1,17,"\n"]],[16,16],[15,15]]],[1521472484042,["gengmei_pxf@gengmei123.local",[[-1,16,"\n"]],[16,16],[15,15]]]]]]}