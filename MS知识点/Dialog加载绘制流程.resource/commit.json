{"compress":true,"commitItems":[["0ba13550-5869-4a81-9c9d-366609e9dd9a",1521019718792,"",[[1521019678524,["gengmei_pxf@gengmei123.local",[[1,0,"Dialog加载绘制流程\n===\n\n\n首先创建一个Dialog，回顾下创建Dialog的流程。\n\n```\n\npublic class MainActivity extends Activity {\n    AlertDialog alertDialog=null;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this);\n        builder.setIcon(R.mipmap.ic_launcher);\n        builder.setMessage(\"Message部分\");\n        builder.setTitle(\"Title部分\");\n        builder.setView(R.layout.activity_main);\n\n        builder.setPositiveButton(\"确定\", new DialogInterface.OnClickListener() {\n            @Override\n            public void onClick(DialogInterface dialog, int which) {\n                alertDialog.dismiss();\n            }\n        });\n        builder.setNegativeButton(\"取消\", new DialogInterface.OnClickListener() {\n            @Override\n            public void onClick(DialogInterface dialog, int which) {\n                alertDialog.dismiss();\n            }\n        });\n        alertDialog = builder.create();\n        alertDialog.show();\n    }\n}\n\n```\n\n运行效果如下，截图中hello world是main布局里面的。\n\n![](//upload-images.jianshu.io/upload_images/1836169-b9651076221d4b6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/516)\n\n我们看一下Dialog的部分代码\n\n```\npublic class AlertDialog extends AppCompatDialog implements DialogInterface {\n\n    final AlertController mAlert;\n    static final int LAYOUT_HINT_NONE = 0;\n    static final int LAYOUT_HINT_SIDE = 1;\n\n    protected AlertDialog(@NonNull Context context) {\n        this(context, 0);\n    }\n\n    /**\n     *构造函数，可以指定主题，比如 R.attr#alertDialogTheme\n     */\n    protected AlertDialog(@NonNull Context context, @StyleRes int themeResId) {\n        super(context, resolveDialogTheme(context, themeResId));\n        mAlert = new AlertController(getContext(), this, getWindow());\n    }\n\n    /**\n     *构造函数，点击外部是否可取消，取消时候的回调\n     */\n    protected AlertDialog(@NonNull Context context, boolean cancelable,\n            @Nullable OnCancelListener cancelListener) {\n        this(context, 0);\n        setCancelable(cancelable);\n        setOnCancelListener(cancelListener);\n    }\n\n    /**\n    获取对话框中的按钮，比如可以获取BUTTON_POSITIVE\n     */\n    public Button getButton(int whichButton) {\n        return mAlert.getButton(whichButton);\n    }\n\n    //设置标题，内部调用了  mAlert.setTitle(title)\n    @Override\n    public void setTitle(CharSequence title) {\n        super.setTitle(title);\n        mAlert.setTitle(title);\n    }\n\n    /**\n     * 标题也可能是一个View，此时设置标题用这个方法\n     */\n    public void setCustomTitle(View customTitleView) {\n        mAlert.setCustomTitle(customTitleView);\n    }\n\n    public void setMessage(CharSequence message) {\n        mAlert.setMessage(message);\n    }\n    .......\n    public static class Builder {\n        private final AlertController.AlertParams P;\n        private final int mTheme;\n\n         //构造函数\n        public Builder(@NonNull Context context) {\n            this(context, resolveDialogTheme(context, 0));\n        }\n\n         //构造函数\n        public Builder(@NonNull Context context, @StyleRes int themeResId) {\n            P = new AlertController.AlertParams(new ContextThemeWrapper(\n                    context, resolveDialogTheme(context, themeResId)));\n            mTheme = themeResId;\n        }\n\n        @NonNull\n        public Context getContext() {\n            return P.mContext;\n        }\n\n        public Builder setTitle(@StringRes int titleId) {\n            P.mTitle = P.mContext.getText(titleId);\n            return this;\n        }\n\n        public Builder setTitle(CharSequence title) {\n            P.mTitle = title;\n            return this;\n        }\n\n        public Builder setCustomTitle(View customTitleView) {\n            P.mCustomTitleView = customTitleView;\n            return this;\n        }\n\n        public Builder setMessage(@StringRes int messageId) {\n            P.mMessage = P.mContext.getText(messageId);\n            return this;\n        }\n\n        public Builder setMessage(CharSequence message) {\n            P.mMessage = message;\n            return this;\n        }\n       .......  \n        public AlertDialog create() {\n\n            final AlertDialog dialog = new AlertDialog(P.mContext, mTheme);\n        //Dialog的参数其实保存在P这个类里面\n            P.apply(dialog.mAlert);\n            dialog.setCancelable(P.mCancelable);\n            if (P.mCancelable) {\n                dialog.setCanceledOnTouchOutside(true);\n            }\n            dialog.setOnCancelListener(P.mOnCancelListener);\n            dialog.setOnDismissListener(P.mOnDismissListener);\n            if (P.mOnKeyListener != null) {\n                dialog.setOnKeyListener(P.mOnKeyListener);\n            }\n            return dialog;\n        }\n\n        public AlertDialog show() {\n            final AlertDialog dialog = create();\n            dialog.show();\n            return dialog;\n        }\n    }\n}\n\n```\n\n从代码中可以看到，我们创建的Dialog是什么样式，可以通过Builder的set系列方法指定，是当我们调用Builder的set系列方法的时候，会将我们传递的参数保存在P中，这个P是什么呢？在Builder有一个成员\n\n```\nprivate final AlertController.AlertParams P;\n\n```\n\nP是AlertController的内部类AlertParams类型的变量。AlertParams中包含了与AlertDialog视图中对应的成员变量。调用Builder的set系列方法之后，我们传递的参数就保存在P中了。P存在之后，我们就可以创建对话框了。这个就好像，我们要建造房子，得先有设计图纸，图纸决定了房子的样子。\n\n```\npublic AlertDialog create() {\n    final AlertDialog dialog = new AlertDialog(P.mContext, mTheme);\n    P.apply(dialog.mAlert);\n}\n\n```\n\n用new的方式创建一个AlertDialog，AlertDialog的构造函数中调用了super,AlertDialog继承Dialog,看一下Dialog的构造函数。\n\n```\n Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) {\n   ....\n        mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);\n        final Window w = new PhoneWindow(mContext);\n        mWindow = w;\n        w.setCallback(this);\n        w.setOnWindowDismissedCallback(this);\n        w.setWindowManager(mWindowManager, null, null);\n        w.setGravity(Gravity.CENTER);\n\n        mListenersHandler = new ListenersHandler(this);\n    }\n\n```\n\n可以发现直接new了一个PhoneWindow赋值给mWindow，并且设置了callback回调，当窗口状态发生变化的时候，就会回调Dialog中的callback实现。这个和Activity的一模一样，之前已经分析过了。当你new AlertDialog()之后，**到此,Dialog所需要的Window就有了。**接下来，就要分析，Dialogd的视图怎么与Window做关联了，继续往下面走。\n\n在AlertDialog创建之后，就调用 P.apply(dialog.mAlert)，将P中的参数赋值给dialog的mAlert，mAlert是AlertController类型。我们看一下apply函数。\n\n```\n public void apply(AlertController dialog) {\n            if (mCustomTitleView != null) {\n                dialog.setCustomTitle(mCustomTitleView);\n            } else {\n                if (mTitle != null) {\n                    dialog.setTitle(mTitle);\n                }\n                if (mIcon != null) {\n                    dialog.setIcon(mIcon);\n                }\n                if (mIconId != 0) {\n                    dialog.setIcon(mIconId);\n                }\n                if (mIconAttrId != 0) {\n                    dialog.setIcon(dialog.getIconAttributeResId(mIconAttrId));\n                }\n            }\n            if (mMessage != null) {\n                dialog.setMessage(mMessage);\n            }\n            if (mPositiveButtonText != null) {\n                dialog.setButton(DialogInterface.BUTTON_POSITIVE, mPositiveButtonText,\n                        mPositiveButtonListener, null);\n            }\n            if (mNegativeButtonText != null) {\n                dialog.setButton(DialogInterface.BUTTON_NEGATIVE, mNegativeButtonText,\n                        mNegativeButtonListener, null);\n            }\n            if (mNeutralButtonText != null) {\n                dialog.setButton(DialogInterface.BUTTON_NEUTRAL, mNeutralButtonText,\n                        mNeutralButtonListener, null);\n            }\n            if ((mItems != null) || (mCursor != null) || (mAdapter != null)) {\n                createListView(dialog);\n            }\n            if (mView != null) {\n                if (mViewSpacingSpecified) {\n                    dialog.setView(mView, mViewSpacingLeft, mViewSpacingTop, mViewSpacingRight,\n                            mViewSpacingBottom);\n                } else {\n                    dialog.setView(mView);\n                }\n            } else if (mViewLayoutResId != 0) {\n                dialog.setView(mViewLayoutResId);\n            }\n        }\n\n```\n\n代码很简单，就纯粹做一件事，把P中的参数赋值给dialog的mAlert中对应的参数，比如标题，按钮等等。这些都没有什么，下面干货来了。继续看Dialog的show方法，记住，我们现在的任务是，**分析Dialog视图是怎么与Window做关联的！**。\n\n```\n    public void show() {\n        if (mShowing) {\n            if (mDecor != null) {\n                if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {\n                    mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);\n                }\n                mDecor.setVisibility(View.VISIBLE);\n            }\n            return;\n        }\n        mCanceled = false;\n        if (!mCreated) {\n            dispatchOnCreate(null);\n        }\n        onStart();\n        mDecor = mWindow.getDecorView();\n        if (mActionBar == null && mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {\n            final ApplicationInfo info = mContext.getApplicationInfo();\n            mWindow.setDefaultIcon(info.icon);\n            mWindow.setDefaultLogo(info.logo);\n            mActionBar = new WindowDecorActionBar(this);\n        }\n        WindowManager.LayoutParams l = mWindow.getAttributes();\n        if ((l.softInputMode\n                & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) {\n            WindowManager.LayoutParams nl = new WindowManager.LayoutParams();\n            nl.copyFrom(l);\n            nl.softInputMode |=\n                    WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;\n            l = nl;\n        }\n        mWindowManager.addView(mDecor, l);\n        mShowing = true;\n        sendShowMessage();\n    }\n\n```\n\n看下面，当mCreated为假的时候，调用dispatchOnCreate，最终是回调了Dialog的onCreate方法。\n\n```\n  if (!mCreated) {\n      dispatchOnCreate(null);\n   }\n\n```\n\n```\n void dispatchOnCreate(Bundle savedInstanceState) {\n        if (!mCreated) {\n            onCreate(savedInstanceState);\n            mCreated = true;\n        }\n    }\nprotected void onCreate(Bundle savedInstanceState) {\n}\n\n```\n\nDialog里面的onCreate是个空实现，我们要看看AlertDialog的onCreate方法的里面的东西。\n\n```\n   @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mAlert.installContent();\n    }\n\n```\n\n调用 mAlert.installContent()方法，上面说了mAlert是AlertController类型，AlertController中有Dialog所需要的样式参数。\n\n```\n  public void installContent() {\n        final int contentView = selectContentView();\n        mDialog.setContentView(contentView);\n        setupView();\n    }\n\n```\n\n有木有！！！终于发现了setContentView方法，先通过selectContentView布局文件的ID，然后调用Window的setContentView方法，加载指定的文件到DecorView的Content部分，并且回调onContentChanged方法通知Dialog。\n\n```\n   @Override\n    public void setContentView(int resId) {\n        ensureSubDecor();\n        ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content);\n        contentParent.removeAllViews();\n        LayoutInflater.from(mContext).inflate(resId, contentParent);\n        mOriginalWindowCallback.onContentChanged();\n    }\n\n```\n\nsetContentView执行之后，调用了setupView方法和setupDector方法，这两个方法的主要作用就是初始化布局文件中的组件和Window对象中的mDector成员变量。现在回到我们的show方法，在执行了dispatchOnCreate方法之后我们又调用了onStart方法。在看show方法里面，会调用下面三行代码。\n\n```\n    mDecor = mWindow.getDecorView();\n\n    WindowManager.LayoutParams l = mWindow.getAttributes();\n\n   mWindowManager.addView(mDecor, l);\n\n```\n\n最终会通过WindowManager将DecorView添加到Window之中，OK到这里整个Dialog的界面就会被绘制出来了。\n总结一下：AlertDialog和Activity一样，内部有一个Window，我们构造AlertDialog.Builder，通过Builder设置Dialog各种属性，,这些参数会被放在一个名为P（AlertController类型）的变量中，在调用AlertDialog.Builder.create方法的时候，内部首先会new一个 AlertDialog，AlertDialog的父类Dialog的构造函数中会new一个PhoneWindow赋值给AlertDialog中的Window，并且为它设置了回调。AlertDialog创建之后执行apply方法，将P中的参数设置赋值给Dialog,后我们调用Dialog.show方法展示窗口，内部调用dispatchOnCreate，最终会走到setContentView，到此Dialog的Window和Dialog视图关联到了一起，最后执行mWindowManager.addView方法，通过WindowManager将DecorView添加到Window之中,此时Dialog显示在了我们面前。\n\n作者：LooperJing\n链接：https://www.jianshu.com/p/f9303d30eb2b\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[0,0],[11911,11911]]],[1521019685191,["gengmei_pxf@gengmei123.local",[[-1,11815,"作者：LooperJing\n链接：https://www.jianshu.com/p/f9303d30eb2b\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[11815,11911],[11815,11815]]],[1521019698911,["gengmei_pxf@gengmei123.local",[[1,17,"# Android源码解析Window系列第（二）篇---Dialog加载绘制流程"]],[17,17],[58,58]]],[1521019701510,["gengmei_pxf@gengmei123.local",[[-1,17,"#"]],[18,18],[17,17]]],[1521019703191,["gengmei_pxf@gengmei123.local",[[-1,16,"\n"]],[17,17],[16,16]]],[1521019704302,["gengmei_pxf@gengmei123.local",[[1,16,"\n"]],[16,16],[17,17]]],[1521019709343,["gengmei_pxf@gengmei123.local",[[-1,17," "]],[18,18],[17,17]]],[1521019710334,["gengmei_pxf@gengmei123.local",[[1,17,"【"]],[17,17],[18,18]]],[1521019711077,["gengmei_pxf@gengmei123.local",[[-1,17,"【"]],[18,18],[17,17]]],[1521019711632,["gengmei_pxf@gengmei123.local",[[1,17,"["]],[17,17],[18,18]]],[1521019714687,["gengmei_pxf@gengmei123.local",[[1,57,"])"]],[57,57],[59,59]]],[1521019715342,["gengmei_pxf@gengmei123.local",[[-1,58,")"]],[59,59],[58,58]]],[1521019715969,["gengmei_pxf@gengmei123.local",[[1,58,"()"]],[58,58],[60,60]]],[1521019723465,["gengmei_pxf@gengmei123.local",[[1,59,"https://www.jianshu.com/p/f9303d30eb2b"]],[59,59],[97,97]]],[1521020083076,["gengmei_pxf@gengmei123.local",[[1,11415,"##"]],[11415,11415],[11417,11417]]],[1521020086248,["gengmei_pxf@gengmei123.local",[[1,11422,"\n"]],[11422,11422],[11423,11423]]],[1521020087087,["gengmei_pxf@gengmei123.local",[[-1,11422,"\n"]],[11423,11423],[11422,11422]]],[1521020088594,["gengmei_pxf@gengmei123.local",[[-1,11422,"："]],[11423,11423],[11422,11422]]],[1521020088978,["gengmei_pxf@gengmei123.local",[[1,11422,"\n"]],[11422,11422],[11423,11423]]],[1521020100229,["gengmei_pxf@gengmei123.local",[[1,100,"## "]],[100,100],[103,103]]],[1521020133891,["gengmei_pxf@gengmei123.local",[[1,1352,"## "]],[1352,1352],[1355,1355]]]]],["d4fa57a0-0eb4-4af9-829a-f31358b1a8ad",1521188494749,"Dialog加载绘制流程\n===\n[Android源码解析Window系列第（二）篇---Dialog加载绘制流程](https://www.jianshu.com/p/f9303d30eb2b)\n\n## 首先创建一个Dialog，回顾下创建Dialog的流程。\n\n```\n\npublic class MainActivity extends Activity {\n    AlertDialog alertDialog=null;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this);\n        builder.setIcon(R.mipmap.ic_launcher);\n        builder.setMessage(\"Message部分\");\n        builder.setTitle(\"Title部分\");\n        builder.setView(R.layout.activity_main);\n\n        builder.setPositiveButton(\"确定\", new DialogInterface.OnClickListener() {\n            @Override\n            public void onClick(DialogInterface dialog, int which) {\n                alertDialog.dismiss();\n            }\n        });\n        builder.setNegativeButton(\"取消\", new DialogInterface.OnClickListener() {\n            @Override\n            public void onClick(DialogInterface dialog, int which) {\n                alertDialog.dismiss();\n            }\n        });\n        alertDialog = builder.create();\n        alertDialog.show();\n    }\n}\n\n```\n\n运行效果如下，截图中hello world是main布局里面的。\n\n![](//upload-images.jianshu.io/upload_images/1836169-b9651076221d4b6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/516)\n\n## 我们看一下Dialog的部分代码\n\n```\npublic class AlertDialog extends AppCompatDialog implements DialogInterface {\n\n    final AlertController mAlert;\n    static final int LAYOUT_HINT_NONE = 0;\n    static final int LAYOUT_HINT_SIDE = 1;\n\n    protected AlertDialog(@NonNull Context context) {\n        this(context, 0);\n    }\n\n    /**\n     *构造函数，可以指定主题，比如 R.attr#alertDialogTheme\n     */\n    protected AlertDialog(@NonNull Context context, @StyleRes int themeResId) {\n        super(context, resolveDialogTheme(context, themeResId));\n        mAlert = new AlertController(getContext(), this, getWindow());\n    }\n\n    /**\n     *构造函数，点击外部是否可取消，取消时候的回调\n     */\n    protected AlertDialog(@NonNull Context context, boolean cancelable,\n            @Nullable OnCancelListener cancelListener) {\n        this(context, 0);\n        setCancelable(cancelable);\n        setOnCancelListener(cancelListener);\n    }\n\n    /**\n    获取对话框中的按钮，比如可以获取BUTTON_POSITIVE\n     */\n    public Button getButton(int whichButton) {\n        return mAlert.getButton(whichButton);\n    }\n\n    //设置标题，内部调用了  mAlert.setTitle(title)\n    @Override\n    public void setTitle(CharSequence title) {\n        super.setTitle(title);\n        mAlert.setTitle(title);\n    }\n\n    /**\n     * 标题也可能是一个View，此时设置标题用这个方法\n     */\n    public void setCustomTitle(View customTitleView) {\n        mAlert.setCustomTitle(customTitleView);\n    }\n\n    public void setMessage(CharSequence message) {\n        mAlert.setMessage(message);\n    }\n    .......\n    public static class Builder {\n        private final AlertController.AlertParams P;\n        private final int mTheme;\n\n         //构造函数\n        public Builder(@NonNull Context context) {\n            this(context, resolveDialogTheme(context, 0));\n        }\n\n         //构造函数\n        public Builder(@NonNull Context context, @StyleRes int themeResId) {\n            P = new AlertController.AlertParams(new ContextThemeWrapper(\n                    context, resolveDialogTheme(context, themeResId)));\n            mTheme = themeResId;\n        }\n\n        @NonNull\n        public Context getContext() {\n            return P.mContext;\n        }\n\n        public Builder setTitle(@StringRes int titleId) {\n            P.mTitle = P.mContext.getText(titleId);\n            return this;\n        }\n\n        public Builder setTitle(CharSequence title) {\n            P.mTitle = title;\n            return this;\n        }\n\n        public Builder setCustomTitle(View customTitleView) {\n            P.mCustomTitleView = customTitleView;\n            return this;\n        }\n\n        public Builder setMessage(@StringRes int messageId) {\n            P.mMessage = P.mContext.getText(messageId);\n            return this;\n        }\n\n        public Builder setMessage(CharSequence message) {\n            P.mMessage = message;\n            return this;\n        }\n       .......  \n        public AlertDialog create() {\n\n            final AlertDialog dialog = new AlertDialog(P.mContext, mTheme);\n        //Dialog的参数其实保存在P这个类里面\n            P.apply(dialog.mAlert);\n            dialog.setCancelable(P.mCancelable);\n            if (P.mCancelable) {\n                dialog.setCanceledOnTouchOutside(true);\n            }\n            dialog.setOnCancelListener(P.mOnCancelListener);\n            dialog.setOnDismissListener(P.mOnDismissListener);\n            if (P.mOnKeyListener != null) {\n                dialog.setOnKeyListener(P.mOnKeyListener);\n            }\n            return dialog;\n        }\n\n        public AlertDialog show() {\n            final AlertDialog dialog = create();\n            dialog.show();\n            return dialog;\n        }\n    }\n}\n\n```\n\n从代码中可以看到，我们创建的Dialog是什么样式，可以通过Builder的set系列方法指定，是当我们调用Builder的set系列方法的时候，会将我们传递的参数保存在P中，这个P是什么呢？在Builder有一个成员\n\n```\nprivate final AlertController.AlertParams P;\n\n```\n\nP是AlertController的内部类AlertParams类型的变量。AlertParams中包含了与AlertDialog视图中对应的成员变量。调用Builder的set系列方法之后，我们传递的参数就保存在P中了。P存在之后，我们就可以创建对话框了。这个就好像，我们要建造房子，得先有设计图纸，图纸决定了房子的样子。\n\n```\npublic AlertDialog create() {\n    final AlertDialog dialog = new AlertDialog(P.mContext, mTheme);\n    P.apply(dialog.mAlert);\n}\n\n```\n\n用new的方式创建一个AlertDialog，AlertDialog的构造函数中调用了super,AlertDialog继承Dialog,看一下Dialog的构造函数。\n\n```\n Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) {\n   ....\n        mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);\n        final Window w = new PhoneWindow(mContext);\n        mWindow = w;\n        w.setCallback(this);\n        w.setOnWindowDismissedCallback(this);\n        w.setWindowManager(mWindowManager, null, null);\n        w.setGravity(Gravity.CENTER);\n\n        mListenersHandler = new ListenersHandler(this);\n    }\n\n```\n\n可以发现直接new了一个PhoneWindow赋值给mWindow，并且设置了callback回调，当窗口状态发生变化的时候，就会回调Dialog中的callback实现。这个和Activity的一模一样，之前已经分析过了。当你new AlertDialog()之后，**到此,Dialog所需要的Window就有了。**接下来，就要分析，Dialogd的视图怎么与Window做关联了，继续往下面走。\n\n在AlertDialog创建之后，就调用 P.apply(dialog.mAlert)，将P中的参数赋值给dialog的mAlert，mAlert是AlertController类型。我们看一下apply函数。\n\n```\n public void apply(AlertController dialog) {\n            if (mCustomTitleView != null) {\n                dialog.setCustomTitle(mCustomTitleView);\n            } else {\n                if (mTitle != null) {\n                    dialog.setTitle(mTitle);\n                }\n                if (mIcon != null) {\n                    dialog.setIcon(mIcon);\n                }\n                if (mIconId != 0) {\n                    dialog.setIcon(mIconId);\n                }\n                if (mIconAttrId != 0) {\n                    dialog.setIcon(dialog.getIconAttributeResId(mIconAttrId));\n                }\n            }\n            if (mMessage != null) {\n                dialog.setMessage(mMessage);\n            }\n            if (mPositiveButtonText != null) {\n                dialog.setButton(DialogInterface.BUTTON_POSITIVE, mPositiveButtonText,\n                        mPositiveButtonListener, null);\n            }\n            if (mNegativeButtonText != null) {\n                dialog.setButton(DialogInterface.BUTTON_NEGATIVE, mNegativeButtonText,\n                        mNegativeButtonListener, null);\n            }\n            if (mNeutralButtonText != null) {\n                dialog.setButton(DialogInterface.BUTTON_NEUTRAL, mNeutralButtonText,\n                        mNeutralButtonListener, null);\n            }\n            if ((mItems != null) || (mCursor != null) || (mAdapter != null)) {\n                createListView(dialog);\n            }\n            if (mView != null) {\n                if (mViewSpacingSpecified) {\n                    dialog.setView(mView, mViewSpacingLeft, mViewSpacingTop, mViewSpacingRight,\n                            mViewSpacingBottom);\n                } else {\n                    dialog.setView(mView);\n                }\n            } else if (mViewLayoutResId != 0) {\n                dialog.setView(mViewLayoutResId);\n            }\n        }\n\n```\n\n代码很简单，就纯粹做一件事，把P中的参数赋值给dialog的mAlert中对应的参数，比如标题，按钮等等。这些都没有什么，下面干货来了。继续看Dialog的show方法，记住，我们现在的任务是，**分析Dialog视图是怎么与Window做关联的！**。\n\n```\n    public void show() {\n        if (mShowing) {\n            if (mDecor != null) {\n                if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {\n                    mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);\n                }\n                mDecor.setVisibility(View.VISIBLE);\n            }\n            return;\n        }\n        mCanceled = false;\n        if (!mCreated) {\n            dispatchOnCreate(null);\n        }\n        onStart();\n        mDecor = mWindow.getDecorView();\n        if (mActionBar == null && mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {\n            final ApplicationInfo info = mContext.getApplicationInfo();\n            mWindow.setDefaultIcon(info.icon);\n            mWindow.setDefaultLogo(info.logo);\n            mActionBar = new WindowDecorActionBar(this);\n        }\n        WindowManager.LayoutParams l = mWindow.getAttributes();\n        if ((l.softInputMode\n                & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) {\n            WindowManager.LayoutParams nl = new WindowManager.LayoutParams();\n            nl.copyFrom(l);\n            nl.softInputMode |=\n                    WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;\n            l = nl;\n        }\n        mWindowManager.addView(mDecor, l);\n        mShowing = true;\n        sendShowMessage();\n    }\n\n```\n\n看下面，当mCreated为假的时候，调用dispatchOnCreate，最终是回调了Dialog的onCreate方法。\n\n```\n  if (!mCreated) {\n      dispatchOnCreate(null);\n   }\n\n```\n\n```\n void dispatchOnCreate(Bundle savedInstanceState) {\n        if (!mCreated) {\n            onCreate(savedInstanceState);\n            mCreated = true;\n        }\n    }\nprotected void onCreate(Bundle savedInstanceState) {\n}\n\n```\n\nDialog里面的onCreate是个空实现，我们要看看AlertDialog的onCreate方法的里面的东西。\n\n```\n   @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mAlert.installContent();\n    }\n\n```\n\n调用 mAlert.installContent()方法，上面说了mAlert是AlertController类型，AlertController中有Dialog所需要的样式参数。\n\n```\n  public void installContent() {\n        final int contentView = selectContentView();\n        mDialog.setContentView(contentView);\n        setupView();\n    }\n\n```\n\n有木有！！！终于发现了setContentView方法，先通过selectContentView布局文件的ID，然后调用Window的setContentView方法，加载指定的文件到DecorView的Content部分，并且回调onContentChanged方法通知Dialog。\n\n```\n   @Override\n    public void setContentView(int resId) {\n        ensureSubDecor();\n        ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content);\n        contentParent.removeAllViews();\n        LayoutInflater.from(mContext).inflate(resId, contentParent);\n        mOriginalWindowCallback.onContentChanged();\n    }\n\n```\n\nsetContentView执行之后，调用了setupView方法和setupDector方法，这两个方法的主要作用就是初始化布局文件中的组件和Window对象中的mDector成员变量。现在回到我们的show方法，在执行了dispatchOnCreate方法之后我们又调用了onStart方法。在看show方法里面，会调用下面三行代码。\n\n```\n    mDecor = mWindow.getDecorView();\n\n    WindowManager.LayoutParams l = mWindow.getAttributes();\n\n   mWindowManager.addView(mDecor, l);\n\n```\n\n最终会通过WindowManager将DecorView添加到Window之中，OK到这里整个Dialog的界面就会被绘制出来了。\n## 总结一下\nAlertDialog和Activity一样，内部有一个Window，我们构造AlertDialog.Builder，通过Builder设置Dialog各种属性，,这些参数会被放在一个名为P（AlertController类型）的变量中，在调用AlertDialog.Builder.create方法的时候，内部首先会new一个 AlertDialog，AlertDialog的父类Dialog的构造函数中会new一个PhoneWindow赋值给AlertDialog中的Window，并且为它设置了回调。AlertDialog创建之后执行apply方法，将P中的参数设置赋值给Dialog,后我们调用Dialog.show方法展示窗口，内部调用dispatchOnCreate，最终会走到setContentView，到此Dialog的Window和Dialog视图关联到了一起，最后执行mWindowManager.addView方法，通过WindowManager将DecorView添加到Window之中,此时Dialog显示在了我们面前。\n\n",[[1521188486803,["gengmei_pxf@gengmei123.local",[[-1,100,"## 首先创建一个Dialog，回顾下创建Dialog的流程。\n\n```\n\npublic class MainActivity extends Activity {\n    AlertDialog alertDialog=null;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this);\n        builder.setIcon(R.mipmap.ic_launcher);\n        builder.setMessage(\"Message部分\");\n        builder.setTitle(\"Title部分\");\n        builder.setView(R.layout.activity_main);\n\n        builder.setPositiveButton(\"确定\", new DialogInterface.OnClickListener() {\n            @Override\n            public void onClick(DialogInterface dialog, int which) {\n                alertDialog.dismiss();\n            }\n        });\n        builder.setNegativeButton(\"取消\", new DialogInterface.OnClickListener() {\n            @Override\n            public void onClick(DialogInterface dialog, int which) {\n                alertDialog.dismiss();\n            }\n        });\n        alertDialog = builder.create();\n        alertDialog.show();\n    }\n}\n\n```\n\n运行效果如下，截图中hello world是main布局里面的。\n\n![](//upload-images.jianshu.io/upload_images/1836169-b9651076221d4b6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/516)\n\n## 我们看一下Dialog的部分代码\n\n```\npublic class AlertDialog extends AppCompatDialog implements DialogInterface {\n\n    final AlertController mAlert;\n    static final int LAYOUT_HINT_NONE = 0;\n    static final int LAYOUT_HINT_SIDE = 1;\n\n    protected AlertDialog(@NonNull Context context) {\n        this(context, 0);\n    }\n\n    /"],[-1,1670,"*\n     *构造函数，可以指定主题，比如 R.attr#alertDialogTheme\n     */\n    protected"],[-1,1750,"(@NonNull Context context, @StyleRes int themeResId) {\n        super(context, resolveDialogTheme(context, themeResId));\n        mAlert = new AlertController(getContext(), this, getWindow());\n    }\n\n    /**\n     *构造函数，点击外部是否可取消，取消时候的回调\n     */\n    protected AlertDialog(@NonNull Context context, boolean cancelable,\n            @Nullable OnCancelListener cancelListener) {\n        this(context, 0);\n        setCancelable(cancelable);\n        setOnCancelListener(cancelListener);\n    }\n\n    /**\n    获取对话框中的按钮，比如可以获取BUTTON_POSITIVE\n     */\n    public Button getButton(int whichButton) {\n        return mAlert.getButton(whichButton);\n    }\n\n    //设置标题，内部调用了  mAlert.setTitle(title)\n    @Override\n    public void setTitle(CharSequence title) {\n        super.setTitle(title);\n        mAlert.setTitle(title);\n    }\n\n    /**\n     * 标题也可能是一个View，此时设置标题用这个方法\n     */\n    public void setCustomTitle(View customTitleView) {\n        mAlert.setCustomTitle(customTitleView);\n    }\n\n    public void setMessage(CharSequence message) {\n        mAlert.setMessage(message);\n    }\n    .......\n    public static class Builder {\n        private final AlertController.AlertParams P;\n        private final int mTheme;\n\n         //构造函数\n        public Builder(@NonNull Context context) {\n            this(context, resolveDialogTheme(context, 0));\n        }\n\n         //构造函数\n        public Builder(@NonNull Context context, @StyleRes int themeResId) {\n            P = new AlertController.AlertParams(new ContextThemeWrapper(\n                    context, resolveDialogTheme(context, themeResId)));\n            mTheme = themeResId;\n        }\n\n        @NonNull\n        public Context getContext() {\n            return P.mContext;\n        }\n\n        public Builder setTitle(@StringRes int titleId) {\n            P.mTitle = P.mContext.getText(titleId);\n            return this;\n        }\n\n        public Builder setTitle(CharSequence title) {\n            P.mTitle = title;\n            return this;\n        }\n\n        public Builder setCustomTitle(View customTitleView) {\n            P.mCustomTitleView = customTitleView;\n            return this;\n        }\n\n        public Builder setMessage(@StringRes int messageId) {\n            P.mMessage = P.mContext.getText(messageId);\n            return this;\n        }\n\n        public Builder setMessage(CharSequence message) {\n            P.mMessage = message;\n            return this;\n        }\n       .......  \n        public AlertDialog create() {\n\n            final AlertDialog dialog = new AlertDialog(P.mContext, mTheme);\n        //Dialog的参数其实保存在P这个类里面\n            P.apply(dialog.mAlert);\n            dialog.setCancelable(P.mCancelable);\n            if (P.mCancelable) {\n                dialog.setCanceledOnTouchOutside(true);\n            }\n            dialog.setOnCancelListener(P.mOnCancelListener);\n            dialog.setOnDismissListener(P.mOnDismissListener);\n            if (P.mOnKeyListener != null) {\n                dialog.setOnKeyListener(P.mOnKeyListener);\n            }\n            return dialog;\n        }\n\n        public AlertDialog show() {\n            final AlertDialog dialog = create();\n            dialog.show();\n            return dialog;\n        }\n    }\n}\n\n```\n\n从代码中可以看到，我们创建的Dialog是什么样式，可以通过Builder的set系列方法指定，是当我们调用Builder的set系列方法的时候，会将我们传递的参数保存在P中，这个P是什么呢？在Builder有一个成员\n\n```\nprivate final AlertController.AlertParams P;\n\n```\n\nP是AlertController的内部类AlertParams类型的变量。AlertParams中包含了与AlertDialog视图中对应的成员变量。调用Builder的set系列方法之后，我们传递的参数就保存在P中了。P存在之后，我们就可以创建对话框了。这个就好像，我们要建造房子，得先有设计图纸，图纸决定了房子的样子。\n\n```\npublic AlertDialog create() {\n    final AlertDialog dialog = new AlertDialog(P.mContext, mTheme);\n    P.apply(dialog.mAlert);\n}\n\n```\n\n用new的方式创建一个AlertDialog，AlertDialog的构造函数中调用了super,AlertDialog继承Dialog,看一下Dialog的构造函数。\n\n```\n Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) {\n   ....\n        mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);\n        final Window w = new PhoneWindow(mContext);\n        mWindow = w;\n        w.setCallback(this);\n        w.setOnWindowDismissedCallback(this);\n        w.setWindowManager(mWindowManager, null, null);\n        w.setGravity(Gravity.CENTER);\n\n        mListenersHandler = new ListenersHandler(this);\n    }\n\n```\n\n可以发现直接new了一个PhoneWindow赋值给mWindow，并且设置了callback回调，当窗口状态发生变化的时候，就会回调Dialog中的callback实现。这个和Activity的一模一样，之前已经分析过了。当你new AlertDialog()之后，**到此,Dialog所需要的Window就有了。**接下来，就要分析，Dialogd的视图怎么与Window做关联了，继续往下面走。\n\n在AlertDialog创建之后，就调用 P.apply(dialog.mAlert)，将P中的参数赋值给dialog的mAlert，mAlert是AlertController类型。我们看一下apply函数。\n\n```\n public void apply(AlertController dialog) {\n            if (mCustomTitleView != null) {\n                dialog.setCustomTitle(mCustomTitleView);\n            } else {\n                if (mTitle != null) {\n                    dialog.setTitle(mTitle);\n                }\n                if (mIcon != null) {\n                    dialog.setIcon(mIcon);\n                }\n                if (mIconId != 0) {\n                    dialog.setIcon(mIconId);\n                }\n                if (mIconAttrId != 0) {\n                    dialog.setIcon(dialog.getIconAttributeResId(mIconAttrId));\n                }\n            }\n            if (mMessage != null) {\n                dialog.setMessage(mMessage);\n            }\n            if (mPositiveButtonText != null) {\n                dialog.setButton(DialogInterface.BUTTON_POSITIVE, mPositiveButtonText,\n                        mPositiveButtonListener, null);\n            }\n            if (mNegativeButtonText != null) {\n                dialog.setButton(DialogInterface.BUTTON_NEGATIVE, mNegativeButtonText,\n                        mNegativeButtonListener, null);\n            }\n            if (mNeutralButtonText != null) {\n                dialog.setButton(DialogInterface.BUTTON_NEUTRAL, mNeutralButtonText,\n                        mNeutralButtonListener, null);\n            }\n            if ((mItems != null) || (mCursor != null) || (mAdapter != null)) {\n                createListView(dialog);\n            }\n            if (mView != null) {\n                if (mViewSpacingSpecified) {\n                    dialog.setView(mView, mViewSpacingLeft, mViewSpacingTop, mViewSpacingRight,\n                            mViewSpacingBottom);\n                } else {\n                    dialog.setView(mView);\n                }\n            } else if (mViewLayoutResId != 0) {\n                dialog.setView(mViewLayoutResId);\n            }\n        }\n\n```\n\n代码很简单，就纯粹做一件事，把P中的参数赋值给dialog的mAlert中对应的参数，比如标题，按钮等等。这些都没有什么，下面干货来了。继续看Dialog的show方法，记住，我们现在的任务是，**分析Dialog视图是怎么与Window做关联的！**。\n\n```\n    public void show() {\n        if (mShowing) {\n            if (mDecor != null) {\n                if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {\n                    mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);\n                }\n                mDecor.setVisibility(View.VISIBLE);\n            }\n            return;\n        }\n        mCanceled = false;\n        if (!mCreated) {\n            dispatchOnCreate(null);\n        }\n        onStart();\n        mDecor = mWindow.getDecorView();\n        if (mActionBar == null && mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {\n            final ApplicationInfo info = mContext.getApplicationInfo();\n            mWindow.setDefaultIcon(info.icon);\n            mWindow.setDefaultLogo(info.logo);\n            mActionBar = new WindowDecorActionBar(this);\n        }\n        WindowManager.LayoutParams l = mWindow.getAttributes();\n        if ((l.softInputMode\n                & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) {\n            WindowManager.LayoutParams nl = new WindowManager.LayoutParams();\n            nl.copyFrom(l);\n            nl.softInputMode |=\n                    WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;\n            l = nl;\n        }\n        mWindowManager.addView(mDecor, l);\n        mShowing = true;\n        sendShowMessage();\n    }\n\n```\n\n看下面，当mCreated为假的时候，调用dispatchOnCreate，最终是回调了Dialog的onCreate方法。\n\n```\n  if (!mCreated) {\n      dispatchOnCreate(null);\n   }\n\n```\n\n```\n void dispatchOnCreate(Bundle savedInstanceState) {\n        if (!mCreated) {\n            onCreate(savedInstanceState);\n            mCreated = true;\n        }\n    }\nprotected void onCreate(Bundle savedInstanceState) {\n}\n\n```\n\nDialog里面的onCreate是个空实现，我们要看看AlertDialog的onCreate方法的里面的东西。\n\n```\n   @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mAlert.installContent();\n    }\n\n```\n\n调用 mAlert.installContent()方法，上面说了mAlert是AlertController类型，AlertController中有Dialog所需要的样式参数。\n\n```\n  public void installContent() {\n        final int contentView = selectContentView();\n        mDialog.setContentView(contentView);\n        setupView();\n    }\n\n```\n\n有木有！！！终于发现了setContentView方法，先通过selectContentView布局文件的ID，然后调用Window的setContentView方法，加载指定的文件到DecorView的Content部分，并且回调onContentChanged方法通知Dialog。\n\n```\n   @Override\n    public void setContentView(int resId) {\n        ensureSubDecor();\n        ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content);\n        contentParent.removeAllViews();\n        LayoutInflater.from(mContext).inflate(resId, contentParent);\n        mOriginalWindowCallback.onContentChanged();\n    }\n\n```\n\nsetContentView执行之后，调用了setupView方法和setupDector方法，这两个方法的主要作用就是初始化布局文件中的组件和Window对象中的mDector成员变量。现在回到我们的show方法，在执行了dispatchOnCreate方法之后我们又调用了onStart方法。在看show方法里面，会调用下面三行代码。\n\n```\n    mDecor = mWindow.getDecorView();\n\n    WindowManager.LayoutParams l = mWindow.getAttributes();\n\n   mWindowManager.addView(mDecor, l);\n\n```\n\n最终会通过WindowManager将DecorView添加到Window之中，OK到这里整个Dialog的界面就会被绘制出来了。\n## 总结一下\nAlertDialog"],[1,11548,"\n\n* "],[1,11682,"\n\n* "],[1,11820,"\n\n* "],[1,11905,"[Android源码解析Window系列第（二）篇---Dialog加载绘制流程](https://www.jianshu.com/p/f9303d30eb2b)\n"]],[100,11904],[671,671]]],[1521188492745,["gengmei_pxf@gengmei123.local",[[-1,590,"[Android源码解析Window系列第（二）篇---Dialog加载绘制流程](https://www.jianshu.com/p/f9303d30eb2b)"]],[590,671],[590,590]]],[1521188493175,["gengmei_pxf@gengmei123.local",[[-1,590,"\n"]],[590,590],[589,589]]],[1521188493736,["gengmei_pxf@gengmei123.local",[[-1,589,"\n"]],[589,589],[588,588]]]]]]}