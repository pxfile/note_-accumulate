{"compress":true,"commitItems":[["34beb8a2-63c3-4fc5-a02b-45380ead19d8",1521095539257,"",[[1521095489342,["gengmei_pxf@gengmei123.local",[[1,0,"面试题3\n===\n\n\n"]],[0,0],[11,11]]],[1521095495409,["gengmei_pxf@gengmei123.local",[[-1,0,"面试题3\n"],[1,5,"m"]],[0,5],[0,1]]],[1521095495574,["gengmei_pxf@gengmei123.local",[[1,1,"'s"]],[0,1],[0,3]]],[1521095495980,["gengmei_pxf@gengmei123.local",[[-1,1,"'"]],[0,3],[2,2]]],[1521095497904,["gengmei_pxf@gengmei123.local",[[1,2,"\n"]],[2,2],[3,3]]],[1521095700152,["gengmei_pxf@gengmei123.local",[[1,9,"\n"]],[6,6],[7,7]]],[1521095786327,["gengmei_pxf@gengmei123.local",[[1,10,"\n"]],[6,6],[7,7]]]]],["fde493a6-227f-4d7f-a328-760595157e18",1521169704420,"ms\n===\n\n\n\n\n",[[1521169647792,["gengmei_pxf@gengmei123.local",[[1,7,"# Android应用程序内部启动Activity过程（startActivity）"]],[7,7],[49,49]]],[1521169662930,["gengmei_pxf@gengmei123.local",[[1,53,"\n"]],[49,49],[50,50]]],[1521169664349,["gengmei_pxf@gengmei123.local",[[1,50,"【】"]],[50,50],[52,52]]],[1521169664850,["gengmei_pxf@gengmei123.local",[[-1,50,"【】"]],[52,52],[50,50]]],[1521169666412,["gengmei_pxf@gengmei123.local",[[1,50,"[]()"]],[50,50],[54,54]]],[1521169668013,["gengmei_pxf@gengmei123.local",[[1,51,"# Android应用程序内部启动Activity过程（startActivity）"]],[51,51],[93,93]]],[1521169670779,["gengmei_pxf@gengmei123.local",[[-1,51,"# "]],[53,53],[51,51]]],[1521169677589,["gengmei_pxf@gengmei123.local",[[1,93,"http://blog.csdn.net/luoshengyang/article/details/6703247"]],[93,93],[150,150]]],[1521169679722,["gengmei_pxf@gengmei123.local",[[1,155,"\n"]],[151,151],[152,152]]],[1521169679937,["gengmei_pxf@gengmei123.local",[[1,156,"\n"]],[152,152],[153,153]]],[1521169698700,["gengmei_pxf@gengmei123.local",[[1,153,"一. Step 1 - Step 10：应用程序的MainActivity通过Binder进程间通信机制通知ActivityManagerService，它要启动一个新的Activity；\n       二. Step 11 - Step 15：ActivityManagerService通过Binder进程间通信机制通知MainActivity进入Paused状态；\n       三. Step 16 - Step 22：MainActivity通过Binder进程间通信机制通知ActivityManagerService，它已经准备就绪进入Paused状态，于是ActivityManagerService就准备要在MainActivity所在的进程和任务中启动新的Activity了；\n       四. Step 23 - Step 29：ActivityManagerService通过Binder进程间通信机制通知MainActivity所在的ActivityThread，现在一切准备就绪，它可以真正执行Activity的启动操作了。\n\n       和上一篇文章[Android应用程序启动过程源代码分析](http://blog.csdn.net/luoshengyang/article/details/6689748)中启动应用程序的默认Activity相比，这里在应用程序内部启动新的Activity的过程少了中间创建新的进程这一步，这是因为新的Activity是在已有的进程和任务中执行的，无须创建新的进程和任务。"]],[153,153],[826,826]]],[1521169702288,["gengmei_pxf@gengmei123.local",[[-1,248,"      "],[1,254,"     "],[-1,339,"      "],[1,345,"      "],[-1,502,"      "],[1,508,"      "],[-1,632,"      "],[1,638,"      "]],[255,255],[254,254]]],[1521169704209,["gengmei_pxf@gengmei123.local",[[-1,248,"      "]],[254,254],[248,248]]],[1521169708417,["gengmei_pxf@gengmei123.local",[[-1,332,"       "]],[332,339],[332,332]]],[1521169712337,["gengmei_pxf@gengmei123.local",[[-1,488,"       "]],[488,495],[488,488]]],[1521169716722,["gengmei_pxf@gengmei123.local",[[-1,153,"一."],[1,155,"*"]],[153,155],[154,154]]],[1521169718888,["gengmei_pxf@gengmei123.local",[[1,247,"\n"]],[247,247],[248,248]]],[1521169720440,["gengmei_pxf@gengmei123.local",[[-1,248,"二."],[1,250,"*"]],[248,250],[249,249]]],[1521169722266,["gengmei_pxf@gengmei123.local",[[1,331,"\n"]],[331,331],[332,332]]],[1521169724442,["gengmei_pxf@gengmei123.local",[[-1,332,"三."],[1,334,"*"]],[332,334],[333,333]]],[1521169726166,["gengmei_pxf@gengmei123.local",[[1,487,"\n"]],[487,487],[488,488]]],[1521169727545,["gengmei_pxf@gengmei123.local",[[-1,488,"四."],[1,490,"*"]],[488,490],[489,489]]],[1521169733767,["gengmei_pxf@gengmei123.local",[[-1,610,"       "]],[610,617],[610,610]]],[1521169779813,["gengmei_pxf@gengmei123.local",[[-1,155,"Step 1 - Step 10："]],[155,172],[155,155]]],[1521169787187,["gengmei_pxf@gengmei123.local",[[-1,233,"Step 11 - Step 15："]],[233,251],[233,233]]],[1521169793356,["gengmei_pxf@gengmei123.local",[[-1,299,"Step 16 - Step 22："]],[299,317],[299,299]]],[1521169799363,["gengmei_pxf@gengmei123.local",[[-1,437,"Step 23 - Step 29："]],[437,455],[437,437]]],[1521169945299,["gengmei_pxf@gengmei123.local",[[-1,540,"上一篇文章"]],[540,545],[540,540]]],[1521169952506,["gengmei_pxf@gengmei123.local",[[1,725,"\n"]],[721,721],[722,722]]],[1521169952858,["gengmei_pxf@gengmei123.local",[[1,726,"\n"]],[722,722],[723,723]]],[1521172092203,["gengmei_pxf@gengmei123.local",[[1,723,"1.Activity组件通信 binder\n2.Measure 中的binder\n3.对象的几种引用方式，软引用在Java中做缓存\n4.插件化，热修复\n5.Dalvik和ART 区别的原理\n6.RecyclerView ListView的区别，缓存机制是啥\n7.组件怎么封装，怎么调用\n8.性能优化的工具，经验\n9.MVVM中大dataBinding 是怎么实现双向绑定\n10.evenbus 用什么区替代的"]],[723,723],[927,927]]],[1521172095294,["gengmei_pxf@gengmei123.local",[[-1,723,"1.Activity组件通信 binder"]],[723,744],[723,723]]],[1521172096653,["gengmei_pxf@gengmei123.local",[[-1,723,"\n"]],[723,723],[722,722]]],[1521172104120,["gengmei_pxf@gengmei123.local",[[1,8,"#"]],[8,8],[9,9]]],[1521172111223,["gengmei_pxf@gengmei123.local",[[-1,778,"5"],[1,779,"##"]],[778,779],[780,780]]],[1521172113023,["gengmei_pxf@gengmei123.local",[[-1,780,"."],[1,781," "]],[780,781],[781,781]]],[1521172114766,["gengmei_pxf@gengmei123.local",[[1,798,"\n"]],[797,797],[798,798]]],[1521172164309,["gengmei_pxf@gengmei123.local",[[1,798,"[]()"]],[798,798],[802,802]]],[1521172165663,["gengmei_pxf@gengmei123.local",[[1,799,"# Android中的Dalvik和ART详解及区别分析"]],[799,799],[827,827]]],[1521172168910,["gengmei_pxf@gengmei123.local",[[-1,799,"# "]],[801,801],[799,799]]],[1521172176774,["gengmei_pxf@gengmei123.local",[[1,827,"http://www.jb51.net/article/88708.htm"]],[827,827],[864,864]]],[1521172180507,["gengmei_pxf@gengmei123.local",[[1,866,"\n"]],[865,865],[866,866]]],[1521172186627,["gengmei_pxf@gengmei123.local",[[-1,743,"3."]],[745,745],[743,743]]],[1521172188164,["gengmei_pxf@gengmei123.local",[[1,743,"## "]],[743,743],[746,746]]],[1521172190321,["gengmei_pxf@gengmei123.local",[[1,769,"\n"]],[768,768],[769,769]]],[1521173168397,["gengmei_pxf@gengmei123.local",[[1,769,"# android开发四种引用的详解"]],[769,769],[787,787]]],[1521173169417,["gengmei_pxf@gengmei123.local",[[-1,769,"# android开发四种引用的详解"]],[787,787],[769,769]]],[1521173170899,["gengmei_pxf@gengmei123.local",[[1,769,"【】"]],[769,769],[771,771]]],[1521173171451,["gengmei_pxf@gengmei123.local",[[-1,769,"【】"]],[771,771],[769,769]]],[1521173173564,["gengmei_pxf@gengmei123.local",[[1,769,"[]()"]],[769,769],[773,773]]],[1521173174861,["gengmei_pxf@gengmei123.local",[[1,770,"# android开发四种引用的详解"]],[770,770],[788,788]]],[1521173178243,["gengmei_pxf@gengmei123.local",[[-1,770,"# "]],[771,771],[770,770]]],[1521173185884,["gengmei_pxf@gengmei123.local",[[1,788,"http://blog.csdn.net/qq_20280683/article/details/77897876"]],[788,788],[845,845]]],[1521173187761,["gengmei_pxf@gengmei123.local",[[1,743,"\n"]],[742,742],[743,743]]],[1521173189970,["gengmei_pxf@gengmei123.local",[[-1,724,"2"]],[725,725],[724,724]]],[1521173192123,["gengmei_pxf@gengmei123.local",[[1,724,"##"]],[724,724],[726,726]]],[1521173194137,["gengmei_pxf@gengmei123.local",[[-1,726,"."]],[727,727],[726,726]]],[1521173195794,["gengmei_pxf@gengmei123.local",[[1,726," zid"]],[726,726],[730,730]]],[1521173197001,["gengmei_pxf@gengmei123.local",[[-1,727,"zid"]],[730,730],[727,727]]],[1521173204651,["gengmei_pxf@gengmei123.local",[[1,727,"自定义View "]],[727,727],[735,735]]],[1521173207041,["gengmei_pxf@gengmei123.local",[[1,857,"\n"]],[856,856],[857,857]]],[1521173211185,["gengmei_pxf@gengmei123.local",[[-1,859,"."]],[860,860],[859,859]]],[1521173214098,["gengmei_pxf@gengmei123.local",[[1,858,"## "]],[858,858],[861,861]]],[1521173215409,["gengmei_pxf@gengmei123.local",[[1,869,"\n"]],[868,868],[869,869]]],[1521185630834,[null,[[-1,861,"4"]],[861,861],[861,861]]],[1521185630834,[null,[[1,861,"4"]],[861,861],[861,861]]],[1521185582368,["gengmei_pxf@gengmei123.local",[[1,993,"\n"]],[992,992],[993,993]]],[1521185585049,["gengmei_pxf@gengmei123.local",[[-1,959,"6."]],[961,961],[959,959]]],[1521185586498,["gengmei_pxf@gengmei123.local",[[1,959,"## "]],[959,959],[962,962]]],[1521185589736,["gengmei_pxf@gengmei123.local",[[1,995,"\n"]],[993,993],[994,994]]],[1521185590813,["gengmei_pxf@gengmei123.local",[[1,994,"RecyclerView 缓存机制（Recycler）大致可以分为5级。 \n第一级 通过mChangedScrap匹配 position或者id获取holder缓存。 \n第二级 从mAttachedScrap中通过匹配position获取holder缓存，或者通过ChildHelper找到隐藏但是没有被移除的View，通过getChildViewHolderInt(view)方法获取holder缓存，或者 \n从mCachedViews中通过匹配position获取holder缓存。 \n第三级 从mAttachedScrap中通过匹配id获取holder缓存，或者 \n从mCachedViews中通过匹配id获取holder缓存。 \n第四级 从ViewCacheExtension获取holder缓存。 \n第五级 通过RecyclerView 的ViewHolder缓存池获取holder。"]],[994,994],[1391,1391]]],[1521187850116,[null,[[-1,861,"4"],[1,959,"\n"],[-1,962,"."],[1,994,"\n"],[-1,1391,"\n"]],[861,861],[1391,1391]]],[1521187850116,[null,[[1,861,"4"],[-1,958,"\n"],[1,962,"."],[-1,993,"\n"],[1,1391,"\n"]],[1391,1391],[861,861]]],[1521187847953,["gengmei_pxf@gengmei123.local",[[-1,994,"RecyclerView 缓存机制（Recycler）大致可以分为5级。 \n第一级 通过mChangedScrap匹配 position或者id获取holder缓存。 \n第二级 从mAttachedScrap中通过匹配position获取holder缓存，或者通过ChildHelper找到隐藏但是没有被移除的View，通过getChildViewHolderInt(view)方法获取holder缓存，或者 \n从mCachedViews中通过匹配position获取holder缓存。 \n第三级 从mAttachedScrap中通过匹配id获取holder缓存，或者 \n从mCachedViews中通过匹配id获取holder缓存。 \n第四级 从ViewCacheExtension获取holder缓存。 \n第五级 通过RecyclerView 的ViewHolder缓存池获取holder。"]],[994,1391],[994,994]]]]],["54a75086-43b9-4b80-ba5f-509492dc904e",1521190956231,"ms\n===\n## Android应用程序内部启动Activity过程（startActivity）\n[Android应用程序内部启动Activity过程（startActivity）](http://blog.csdn.net/luoshengyang/article/details/6703247)\n\n* 应用程序的MainActivity通过Binder进程间通信机制通知ActivityManagerService，它要启动一个新的Activity；\n\n* ActivityManagerService通过Binder进程间通信机制通知MainActivity进入Paused状态；\n\n* MainActivity通过Binder进程间通信机制通知ActivityManagerService，它已经准备就绪进入Paused状态，于是ActivityManagerService就准备要在MainActivity所在的进程和任务中启动新的Activity了；\n\n* ActivityManagerService通过Binder进程间通信机制通知MainActivity所在的ActivityThread，现在一切准备就绪，它可以真正执行Activity的启动操作了。\n\n和[Android应用程序启动过程源代码分析](http://blog.csdn.net/luoshengyang/article/details/6689748)中启动应用程序的默认Activity相比，这里在应用程序内部启动新的Activity的过程少了中间创建新的进程这一步，这是因为新的Activity是在已有的进程和任务中执行的，无须创建新的进程和任务。\n\n## 自定义View Measure 中的binder\n\n## 对象的几种引用方式，软引用在Java中做缓存\n[android开发四种引用的详解](http://blog.csdn.net/qq_20280683/article/details/77897876)\n\n## 插件化，热修复\n\n## Dalvik和ART 区别的原理\n[Android中的Dalvik和ART详解及区别分析](http://www.jb51.net/article/88708.htm)\n\n## RecyclerView ListView的区别，缓存机制是啥\n\n\n7.组件怎么封装，怎么调用\n8.性能优化的工具，经验\n9.MVVM中大dataBinding 是怎么实现双向绑定\n10.evenbus 用什么区替代的\n\n\n\n",[[1521190954491,["gengmei_pxf@gengmei123.local",[[1,994,"* 1、[Bugly-Android ListView 与 RecyclerView 对比浅析--缓存机制](https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653578065&idx=2&sn=25e64a8bb7b5934cf0ce2e49549a80d6&chksm=84b3b156b3c43840061c28869671da915a25cf3be54891f040a3532e1bb17f9d32e244b79e3f&scene=21#wechat_redirect)\n\n* 2、[RecyclerView 必知必会](https://mp.weixin.qq.com/s/CzrKotyupXbYY6EY2HP_dA)"]],[994,994],[1340,1340]]],[1521190961127,["gengmei_pxf@gengmei123.local",[[1,1356,"\n"]],[1355,1355],[1356,1356]]],[1521190963800,["gengmei_pxf@gengmei123.local",[[-1,1342,"7."]],[1344,1344],[1342,1342]]],[1521190965409,["gengmei_pxf@gengmei123.local",[[1,1342,"## "]],[1342,1342],[1345,1345]]],[1521193600072,["gengmei_pxf@gengmei123.local",[[-1,745,"binder"]],[745,751],[745,745]]],[1521193601771,["gengmei_pxf@gengmei123.local",[[1,745,"c"]],[745,745],[746,746]]],[1521193602451,["gengmei_pxf@gengmei123.local",[[-1,745,"c"]],[746,746],[745,745]]],[1521193604007,["gengmei_pxf@gengmei123.local",[[1,745,"参数"]],[745,745],[747,747]]],[1521193604362,["gengmei_pxf@gengmei123.local",[[1,749,"\n"]],[747,747],[748,748]]],[1521193605510,["gengmei_pxf@gengmei123.local",[[1,748," \n\n# [Android进阶——Android视图工作机制之measure、layout、draw](http://blog.csdn.net/qq_30379689/article/details/54588736)"]],[748,748],[858,858]]],[1521193606949,["gengmei_pxf@gengmei123.local",[[-1,748," \n\n# [Android进阶——Android视图工作机制之measure、layout、draw](http://blog.csdn.net/qq_30379689/article/details/54588736)"]],[858,858],[748,748]]],[1521193607837,["gengmei_pxf@gengmei123.local",[[1,748," \n\n# [Android进阶——Android视图工作机制之measure、layout、draw](http://blog.csdn.net/qq_30379689/article/details/54588736)"]],[748,748],[858,858]]],[1521193610818,["gengmei_pxf@gengmei123.local",[[-1,748," "],[1,749," "],[-1,751,"# "]],[753,753],[751,751]]],[1521193611706,["gengmei_pxf@gengmei123.local",[[-1,750,"\n"]],[751,751],[750,750]]],[1521193613073,["gengmei_pxf@gengmei123.local",[[1,750,"* "]],[750,750],[752,752]]],[1521193615152,["gengmei_pxf@gengmei123.local",[[1,859,"\n"]],[857,857],[858,858]]],[1521193615634,["gengmei_pxf@gengmei123.local",[[1,860,"\n"]],[858,858],[859,859]]],[1521193629549,["gengmei_pxf@gengmei123.local",[[1,859,"* # Android View 测量流程(Measure)完全解析"]],[859,859],[893,893]]],[1521193631029,["gengmei_pxf@gengmei123.local",[[-1,859,"* # Android View 测量流程(Measure)完全解析"]],[893,893],[859,859]]],[1521193633701,["gengmei_pxf@gengmei123.local",[[1,859,"* 【】"]],[859,859],[863,863]]],[1521193634401,["gengmei_pxf@gengmei123.local",[[-1,861,"【】"]],[863,863],[861,861]]],[1521193636306,["gengmei_pxf@gengmei123.local",[[1,861,"[]()"]],[861,861],[865,865]]],[1521193638076,["gengmei_pxf@gengmei123.local",[[1,862,"# Android View 测量流程(Measure)完全解析"]],[862,862],[894,894]]],[1521193640536,["gengmei_pxf@gengmei123.local",[[-1,862,"# "]],[864,864],[862,862]]],[1521193647404,["gengmei_pxf@gengmei123.local",[[1,894,"https://www.jianshu.com/p/3299c3de0b7d"]],[894,894],[932,932]]],[1521261391623,["gengmei_pxf@gengmei123.local",[[1,1553,"\n"]],[1552,1552],[1553,1553]]],[1521261394799,["gengmei_pxf@gengmei123.local",[[-1,1540,"8."]],[1542,1542],[1540,1540]]],[1521261396370,["gengmei_pxf@gengmei123.local",[[1,1540,"## "]],[1540,1540],[1543,1543]]],[1521261405934,["gengmei_pxf@gengmei123.local",[[1,1555,"\n"]],[1553,1553],[1554,1554]]],[1521261435177,["gengmei_pxf@gengmei123.local",[[1,1554," [## 性能优化](https://pxfile.github.io/2018/03/08/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/)"]],[1554,1554],[1639,1639]]],[1521261437534,["gengmei_pxf@gengmei123.local",[[-1,1556,"## "]],[1559,1559],[1556,1556]]],[1521261440149,["gengmei_pxf@gengmei123.local",[[1,1668,"\n"]],[1667,1667],[1668,1668]]],[1521261443853,["gengmei_pxf@gengmei123.local",[[-1,1638,"9."]],[1640,1640],[1638,1638]]],[1521261445447,["gengmei_pxf@gengmei123.local",[[1,1638,"## "]],[1638,1638],[1641,1641]]],[1521261448462,["gengmei_pxf@gengmei123.local",[[-1,1670,"10."]],[1673,1673],[1670,1670]]],[1521261449903,["gengmei_pxf@gengmei123.local",[[1,1670,"## "]],[1670,1670],[1673,1673]]],[1521261458908,["gengmei_pxf@gengmei123.local",[[1,1692,"\n"]],[1688,1688],[1689,1689]]],[1521262679796,["gengmei_pxf@gengmei123.local",[[1,1689,"### EventBus的机制是什么？和Handler的区别怎样？\n\n`EventBus`是采用观察者模式实现的事件订阅总线，可以用在应用程序中，组件之间，线程之间的通信，并且由于事件可以是任意类型的对象，所以使用起来更加的方便快捷。\n`Handler`是 Android 的消息机制，集中解决线程间通信问题。"]],[1689,1689],[1844,1844]]],[1521262683048,["gengmei_pxf@gengmei123.local",[[1,1689,"\n"]],[1688,1688],[1689,1689]]],[1521262687490,["gengmei_pxf@gengmei123.local",[[1,1725,"* "]],[1725,1725],[1727,1727]]],[1521262689408,["gengmei_pxf@gengmei123.local",[[1,1810,"\n"]],[1810,1810],[1811,1811]]],[1521262690247,["gengmei_pxf@gengmei123.local",[[1,1811,"* "]],[1811,1811],[1813,1813]]],[1521270900257,["gengmei_pxf@gengmei123.local",[[-1,1673,"evenbus 用什么区替代的"],[1,1688,"EventBus作用，实现方式，代替EventBus的方式"]],[1673,1688],[1702,1702]]],[1521270926605,["gengmei_pxf@gengmei123.local",[[1,1868,"\n"]],[1864,1864],[1865,1865]]],[1521270926893,["gengmei_pxf@gengmei123.local",[[1,1869,"\n"]],[1865,1865],[1866,1866]]],[1521270927441,["gengmei_pxf@gengmei123.local",[[1,1866,"### RxBus、EventBus 对比：\n\n**1.从引入依赖包对比**\n\n  RxBus 需要引入两个包，EventBus需要引入一个，如果项目中没有使用到RxJava编程的话，并不能减少包的依赖。\n\n**2 .从开发难度上对比**\n\n  上面也提到了实现RxBus是基于RxJava的，作为一个新的编程方式函数式编程，对开发者的要求多多少少提高了那么一点，而且每一个订阅都需要返回一个Observable，由订阅者写具体的代码 需要执行在哪个线程中，而EventBus 最新版本采用注解预编译的方式，订阅者注册解注册只需调用一个函数，而且通过注解的方式可以标明事件的优先级，接收事件运行在哪个线程，并且能够实现粘性事件，这些RxBus都需要进行二次开发。\n\n**3.）从开发效率上对比**\n\n   RxBus 需要进行大量的二次开发，否则只能实现简单的事件传递，而EventBus只需简单了解一下API就能上手。如果一个订阅者需要注册多个事件的时候，需要多个Observable全局变量，这不是疯掉了吗，而EventBus已经实现了一个订阅者订阅多个事件，和一个事件对应多个订阅者。\n\n**4.）从功能完善上对比**\n\n 上面三个对比也说明了，EventBus实现了事件的优先级，订阅事件运行的线程场景，以及粘性事件，这些在RxBus上面都需要进行二次实现。\n\n### 总结：\n\n    基于RxJava实现简单的事件总线管理是可以的，但是个人觉得想要取代EventBus难免有点说过头了。所以如果项目中没有使用RxJava的话 还是采用EventBus比较靠谱。"]],[1866,1866],[2552,2552]]],[1521271151804,["gengmei_pxf@gengmei123.local",[[1,1825,"\n"],[-1,1906," "],[1,1907," "],[-1,1987," "],[1,1988," "],[-1,2216,"   "],[1,2219,"   "],[-1,2380," "],[1,2381," "],[-1,2460,"   "],[1,2463,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"]],[1823,1823],[2043,2043]]],[1521271157217,["gengmei_pxf@gengmei123.local",[[1,1824,"\n"]],[1824,1824],[1825,1825]]],[1521271170976,["gengmei_pxf@gengmei123.local",[[1,1951,"\n"]],[1950,1950],[1951,1951]]],[1521271225207,[null,[[-1,1825,""],[1,1825,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[-1,1951,"\n"],[1,1952,""],[-1,2466,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"]],[1825,1825],[2466,2466]]],[1521271225207,[null,[[1,1825,""],[-1,1825,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[1,2171,"\n"],[-1,2171,""],[1,2685,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"]],[2466,2466],[1825,1825]]],[1521271220217,["gengmei_pxf@gengmei123.local",[[1,1825,"* "]],[1825,1825],[1827,1827]]],[1521271222758,["gengmei_pxf@gengmei123.local",[[1,1954,"* "]],[1954,1954],[1956,1956]]],[1521271238874,[null,[[-1,1827,""],[1,1827,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[-1,1953,"\n* "],[1,1956,""],[-1,2470,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"]],[1827,1827],[2470,2470]]],[1521271238874,[null,[[1,1827,""],[-1,1827,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[1,2175,"\n* "],[-1,2175,""],[1,2689,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"]],[2470,2470],[1827,1827]]],[1521271236872,["gengmei_pxf@gengmei123.local",[[-1,2686,"    "]],[2690,2690],[2686,2686]]],[1521271358891,[null,[[-1,1827,""],[1,1827,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[-1,1953,"\n* "],[1,1956,""],[-1,2467,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[1827,1827],[2467,2467]]],[1521271358891,[null,[[1,1827,""],[-1,1827,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[1,2175,"\n* "],[-1,2175,""],[1,2686,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[2467,2467],[1827,1827]]],[1521271347422,["gengmei_pxf@gengmei123.local",[[1,1670,"\n"]],[1668,1668],[1669,1669]]],[1521271385953,[null,[[-1,1828,""],[1,1828,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[-1,1954,"\n* "],[1,1957,""],[-1,2468,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[1828,1828],[2468,2468]]],[1521271385953,[null,[[1,1828,""],[-1,1828,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[1,2176,"\n* "],[-1,2176,""],[1,2687,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[2468,2468],[1828,1828]]],[1521271365166,["gengmei_pxf@gengmei123.local",[[1,1705,"\n"]],[1704,1704],[1705,1705]]],[1521271365669,["gengmei_pxf@gengmei123.local",[[1,1706,"\n"]],[1705,1705],[1706,1706]]],[1521271366576,["gengmei_pxf@gengmei123.local",[[1,1705,"# EventBus 源码解析"]],[1705,1705],[1720,1720]]],[1521271368587,["gengmei_pxf@gengmei123.local",[[-1,1705,"# EventBus 源码解析"]],[1720,1720],[1705,1705]]],[1521271369799,["gengmei_pxf@gengmei123.local",[[1,1705,"【】"]],[1705,1705],[1707,1707]]],[1521271370453,["gengmei_pxf@gengmei123.local",[[-1,1705,"【】"]],[1707,1707],[1705,1705]]],[1521271371151,["gengmei_pxf@gengmei123.local",[[1,1705,"[]"]],[1705,1705],[1707,1707]]],[1521271372728,["gengmei_pxf@gengmei123.local",[[1,1706,"# EventBus 源码解析"]],[1706,1706],[1721,1721]]],[1521271374517,["gengmei_pxf@gengmei123.local",[[-1,1706,"# "]],[1708,1708],[1706,1706]]],[1521271376879,["gengmei_pxf@gengmei123.local",[[1,1720,"()"]],[1720,1720],[1722,1722]]],[1521271383303,["gengmei_pxf@gengmei123.local",[[1,1721,"http://www.trinea.cn/android/eventbus-source-analysis/"]],[1721,1721],[1775,1775]]],[1521272030542,[null,[[-1,1901,""],[1,1901,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[-1,2027,"\n* "],[1,2030,""],[-1,2541,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[1901,1901],[2541,2541]]],[1521272030542,[null,[[1,1901,""],[-1,1901,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[1,2249,"\n* "],[-1,2249,""],[1,2760,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[2541,2541],[1901,1901]]],[1521272025401,["gengmei_pxf@gengmei123.local",[[1,2850,"## EventBus 带来的好处和引入的问题\n\n好处比较明显，就是独立出一个`发布订阅模块`，调用者可以通过使用这个模块，屏蔽一些线程切换问题，简单地实现发布订阅功能。\n\n坏处可能比较隐晦，但这些需要足够引起我们的重视\n\n*   大量的滥用，将导致逻辑的分散，出现问题后很难定位。\n*   没办法实现强类型，在编译的时候就发现问题，（Otto实现了这个，但性能有问题）。在实现上通过一个很弱的协议，比如onEvent{XXX}, {XXX}表示ThreadModel，来实现线程的切换。后面在代码解析的时候，会说明这个问题。\n*   代码可读性有些问题，IDE无法识别这些协议，对IDE不友好。\n\n总得来说，如果项目里面有大量的事件交互，那么还是可以通过`EventBus`来实现，否则还是推荐自己在模块内部实现`观察者模式`"]],[2850,2850],[3214,3214]]],[1521272028327,["gengmei_pxf@gengmei123.local",[[1,2852,"#"]],[2852,2852],[2853,2853]]],[1521272038891,[null,[[-1,1901,""],[1,1901,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[-1,2027,"\n* "],[1,2030,""],[-1,2541,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[1901,1901],[2541,2541]]],[1521272038891,[null,[[1,1901,""],[-1,1901,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[1,2249,"\n* "],[-1,2249,""],[1,2760,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[2541,2541],[1901,1901]]],[1521272035902,["gengmei_pxf@gengmei123.local",[[1,2993,"\n"]],[2993,2993],[2994,2994]]],[1521272037661,["gengmei_pxf@gengmei123.local",[[1,3116,"\n"]],[3116,3116],[3117,3117]]],[1521277379259,[null,[[-1,1901,""],[1,1901,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[-1,2027,"\n* "],[1,2030,""],[-1,2541,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[1901,1901],[2541,2541]]],[1521277379259,[null,[[1,1901,""],[-1,1901,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[1,2249,"\n* "],[-1,2249,""],[1,2760,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[2541,2541],[1901,1901]]],[1521277361489,["gengmei_pxf@gengmei123.local",[[1,1669,"## DataBinding做了些什么事\n\nDataBinding主要做了两件事：\n1.取代烦琐的findviewbyid，自动在binding中生成对应的view\n2.绑定VM层和V层的监听关系，使得VM和V层的交互更简单\n这里的交互是指两个方向的交互，一是VM通知V层作改变，比如setText,setColor，二是V层通知VM作改变，比如click事件，edittext的输入"]],[1669,1669],[1861,1861]]],[1521277364360,["gengmei_pxf@gengmei123.local",[[1,1671,"#"]],[1671,1671],[1672,1672]]],[1521277367573,["gengmei_pxf@gengmei123.local",[[1,1669,"\n"]],[1669,1669],[1670,1670]]],[1521277372277,["gengmei_pxf@gengmei123.local",[[1,1713,"\n"]],[1713,1713],[1714,1714]]],[1521277373640,["gengmei_pxf@gengmei123.local",[[1,1714,"* "]],[1714,1714],[1716,1716]]],[1521277375559,["gengmei_pxf@gengmei123.local",[[1,1757,"* "]],[1757,1757],[1759,1759]]],[1521277439253,[null,[[-1,2100,""],[1,2100,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[-1,2226,"\n* "],[1,2229,""],[-1,2740,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[2100,2100],[2740,2740]]],[1521277439253,[null,[[1,2100,""],[-1,2100,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[1,2448,"\n* "],[-1,2448,""],[1,2959,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[2740,2740],[2100,2100]]],[1521277379741,["gengmei_pxf@gengmei123.local",[[1,1870,"\n"]],[1868,1868],[1869,1869]]],[1521277380445,["gengmei_pxf@gengmei123.local",[[1,1871,"\n"]],[1869,1869],[1870,1870]]],[1521277414895,["gengmei_pxf@gengmei123.local",[[1,1870,"###### 1.DataBindingUtil.setContentView方法将xml中的各个View赋值给ViewDataBinding，完成findviewbyid的任务\n\n###### 2.ViewDataBinding的setVariable方法建立了ViewDataBinding与VM之间的联系，也就搭建了一个可以互相通信的桥梁\n\n###### 3.当VM层调用notifyPropertyChanged方法时，最终在ViewDataBinding的executeBindings方法中处理逻辑"]],[1870,1870],[2125,2125]]],[1521277425195,["gengmei_pxf@gengmei123.local",[[1,1870,"\n"]],[1869,1869],[1870,1870]]],[1521277430462,["gengmei_pxf@gengmei123.local",[[1,1870,"### 总结"]],[1870,1870],[1876,1876]]],[1521277434564,["gengmei_pxf@gengmei123.local",[[-1,1881,"##"]],[1883,1883],[1881,1881]]],[1521277436827,["gengmei_pxf@gengmei123.local",[[1,1877,"\n"]],[1877,1877],[1878,1878]]],[1521277446819,[null,[[-1,2363,""],[1,2363,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[-1,2489,"\n* "],[1,2492,""],[-1,3003,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[2363,2363],[3003,3003]]],[1521277446819,[null,[[1,2363,""],[-1,2363,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[1,2711,"\n* "],[-1,2711,""],[1,3222,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[3003,3003],[2363,2363]]],[1521277440291,["gengmei_pxf@gengmei123.local",[[-1,1971,"##"]],[1971,1973],[1971,1971]]],[1521277443859,["gengmei_pxf@gengmei123.local",[[-1,2052,"##"]],[2052,2054],[2052,2052]]],[1521277462289,[null,[[-1,2359,""],[1,2359,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[-1,2485,"\n* "],[1,2488,""],[-1,2999,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[2359,2359],[2999,2999]]],[1521277462289,[null,[[1,2359,""],[-1,2359,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[1,2707,"\n* "],[-1,2707,""],[1,3218,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[2999,2999],[2359,2359]]],[1521277451443,["gengmei_pxf@gengmei123.local",[[-1,1878,"####"]],[1880,1882],[1878,1878]]],[1521277452453,["gengmei_pxf@gengmei123.local",[[1,1878,"*"]],[1878,1878],[1879,1879]]],[1521277458892,["gengmei_pxf@gengmei123.local",[[-1,1964,"####"],[1,1968,"*"]],[1964,1968],[1965,1965]]],[1521277461291,["gengmei_pxf@gengmei123.local",[[-1,2042,"####"],[1,2046,"*"]],[2042,2046],[2043,2043]]],[1521277579311,[null,[[-1,2350,""],[1,2350,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[-1,2476,"\n* "],[1,2479,""],[-1,2990,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[2350,2350],[2990,2990]]],[1521277579311,[null,[[1,2350,""],[-1,2350,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[1,2698,"\n* "],[-1,2698,""],[1,3209,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[2990,2990],[2350,2350]]],[1521277534174,["gengmei_pxf@gengmei123.local",[[1,1670,"\n"]],[1669,1669],[1670,1670]]],[1521277536066,["gengmei_pxf@gengmei123.local",[[1,1669,"【】"]],[1669,1669],[1671,1671]]],[1521277536672,["gengmei_pxf@gengmei123.local",[[-1,1669,"【】"]],[1671,1671],[1669,1669]]],[1521277537587,["gengmei_pxf@gengmei123.local",[[1,1669,"[]"]],[1669,1669],[1671,1671]]],[1521277539995,["gengmei_pxf@gengmei123.local",[[1,1670,"# DataBinding实现原理探析"]],[1670,1670],[1689,1689]]],[1521277541746,["gengmei_pxf@gengmei123.local",[[1,1690,"()"]],[1690,1690],[1692,1692]]],[1521277544392,["gengmei_pxf@gengmei123.local",[[-1,1670,"# "]],[1672,1672],[1670,1670]]],[1521277551153,["gengmei_pxf@gengmei123.local",[[1,1689,"https://juejin.im/entry/59b53330f265da066b3925a1"]],[1689,1689],[1737,1737]]],[1521277553959,["gengmei_pxf@gengmei123.local",[[1,1740,"\n"]],[1738,1738],[1739,1739]]],[1521277554279,["gengmei_pxf@gengmei123.local",[[1,1741,"\n"]],[1739,1739],[1740,1740]]],[1521277557026,["gengmei_pxf@gengmei123.local",[[1,1740,"[]()"]],[1740,1740],[1744,1744]]],[1521277569073,["gengmei_pxf@gengmei123.local",[[1,1741,"# Android DataBinding原理解析"]],[1741,1741],[1766,1766]]],[1521277571070,["gengmei_pxf@gengmei123.local",[[-1,1741,"# "]],[1743,1743],[1741,1741]]],[1521277578320,["gengmei_pxf@gengmei123.local",[[1,1766,"http://blog.csdn.net/haizishiwo/article/details/51175145"]],[1766,1766],[1822,1822]]],[1521278299310,[null,[[-1,2505,""],[1,2505,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[-1,2631,"\n* "],[1,2634,""],[-1,3145,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[2505,2505],[3145,3145]]],[1521278299310,[null,[[1,2505,""],[-1,2505,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[1,2853,"\n* "],[-1,2853,""],[1,3364,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[3145,3145],[2505,2505]]],[1521278290786,["gengmei_pxf@gengmei123.local",[[1,2275,"\n"]],[2273,2273],[2274,2274]]],[1521278290953,["gengmei_pxf@gengmei123.local",[[1,2276,"\n"]],[2274,2274],[2275,2275]]],[1521278291444,["gengmei_pxf@gengmei123.local",[[1,2275,"#### 总结MVVM： \n\n* 1）低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。 \n\n* 2） 可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。 \n\n* 3） 独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xaml代码。 \n\n* 4）可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。 \n由上面各个架构的讨论，我们可以得到以下的结果：\n\n### 4、总结三种架构：\n\nMVC 架构适合于大型系统，它可以分层且可以在实体层面切割为不同的机器或服务，只要彼此间具有适当的通讯协定即可。 \nMVVM 架构适合像XAML 这种与程式码无关(code ignorance) 的使用者介面设计，只要View 中下特定的指令与ViewModel 串接，就可以享有ViewModel 沟通的功能，而ViewModel 只需做一些特别的介面实作，即可平顺的和View 沟通。 \nMVP 架构适合集中由程式码决定View 动作的应用程式，而View 只需要实作特定的介面即可，不需要太复杂的工作，但Presenter 则可能会受限于View 介面的动作，而无法做更进一步对View 的控制。\n\n### 5、小结\n\n在Android开发中原有的MVC（Activity+layout）模式越来越不适用，首先，视图逻辑和业务逻辑不分，导致代码容易出问题、难以可持续性维护；其次，由于业务逻辑混在视图逻辑里面，视图基本无法复用，layout本身是代码文件，但是又不像java代码那样可维护，灵活，可以有逻辑，所以很少复用layout文件，有经验的Android程序员会尽可能避免复用Layout文件特别是复用别人写的layout文件。所以出于视图复用的目的原有的MVC也不适用，MVVM成了一种必要的选择。\n\n* 1.  MVC 架构适合于大型系统，它可以分层且可以在实体层面切割为不同的机器或服务，只要彼此间具有适当的通讯协定即可。\n* 2.  MVVM 架构适合像XAML 这种与程式码无关(code ignorance) 的使用者介面设计，只要View 中下特定的指令与ViewModel 串接，就可以享有ViewModel 沟通的功能，而ViewModel 只需做一些特别的介面实作，即可平顺的和View 沟通。\n* 3.  MVP 架构适合集中由程式码决定View 动作的应用程式，而View 只需要实作特定的介面即可，不需要太复杂的工作，但Presenter 则可能会受限于View 介面的动作，而无法做更进一步对View 的控制。"]],[2275,2275],[3502,3502]]],[1521278408540,[null,[[-1,3734,""],[1,3734,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[-1,3860,"\n* "],[1,3863,""],[-1,4374,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[3734,3734],[4374,4374]]],[1521278408541,[null,[[1,3734,""],[-1,3734,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[1,4082,"\n* "],[-1,4082,""],[1,4593,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[4374,4374],[3734,3734]]],[1521278386206,["gengmei_pxf@gengmei123.local",[[1,3248,"\n"]],[3247,3247],[3248,3248]]],[1521278388942,["gengmei_pxf@gengmei123.local",[[1,3392,"\n"]],[3391,3391],[3392,3392]]],[1521278448431,[null,[[-1,3736,""],[1,3736,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[-1,3862,"\n* "],[1,3865,""],[-1,4376,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[3736,3736],[4376,4376]]],[1521278448431,[null,[[1,3736,""],[-1,3736,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[1,4084,"\n* "],[-1,4084,""],[1,4595,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[4376,4376],[3736,3736]]],[1521278432107,["gengmei_pxf@gengmei123.local",[[1,1540,"\n"]],[1538,1538],[1539,1539]]],[1521278433244,["gengmei_pxf@gengmei123.local",[[1,1539,"()"]],[1539,1539],[1541,1541]]],[1521278442021,["gengmei_pxf@gengmei123.local",[[1,1540,"结合自己项目建议"]],[1540,1540],[1548,1548]]],[1521278442675,["gengmei_pxf@gengmei123.local",[[-1,1546,"建议"]],[1548,1548],[1546,1546]]],[1521278447173,["gengmei_pxf@gengmei123.local",[[1,1546,"经验说说"]],[1546,1546],[1550,1550]]],[1521278548531,[null,[[-1,3749,""],[1,3749,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[-1,3875,"\n* "],[1,3878,""],[-1,4389,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[3749,3749],[4389,4389]]],[1521278548531,[null,[[1,3749,""],[-1,3749,"EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n\n* 传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。"],[1,4097,"\n* "],[-1,4097,""],[1,4608,"   EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。\n传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分"]],[4389,4389],[3749,3749]]],[1521278546042,["gengmei_pxf@gengmei123.local",[[-1,0,"ms"],[1,2,"面试题总结并附上答案2"]],[0,2],[11,11]]],[1521278547442,["gengmei_pxf@gengmei123.local",[[-1,10,"2"]],[11,11],[10,10]]],[1521278547628,["gengmei_pxf@gengmei123.local",[[1,10,"3"]],[10,10],[11,11]]]]]]}