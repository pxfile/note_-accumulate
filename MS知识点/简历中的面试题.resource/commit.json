{"compress":true,"commitItems":[["ce7b3bee-da4a-478e-befe-12c640cce4a9",1520508465442,"",[[1520508435762,["gengmei_pxf@gengmei123.local",[[1,0,"简历中的sm"]],[0,0],[6,6]]],[1520508437735,["gengmei_pxf@gengmei123.local",[[-1,4,"sm"]],[6,6],[4,4]]],[1520508451648,["gengmei_pxf@gengmei123.local",[[1,4,"questions"]],[4,4],[13,13]]],[1520508454366,["gengmei_pxf@gengmei123.local",[[1,13,"\n\n"]],[13,13],[14,14]]],[1520508455551,["gengmei_pxf@gengmei123.local",[[-1,14,"\n"],[1,15,"=="]],[14,14],[16,16]]],[1520508456782,["gengmei_pxf@gengmei123.local",[[1,16,"\n\n"]],[16,16],[17,17]]],[1520508488505,["gengmei_pxf@gengmei123.local",[[-1,17,"\n"],[1,18,"## Android中的设计模式"]],[17,17],[33,33]]],[1520508488853,["gengmei_pxf@gengmei123.local",[[1,33,"\n\n"]],[33,33],[34,34]]],[1520508536093,["gengmei_pxf@gengmei123.local",[[-1,34,"\n"],[1,35,"###"]],[34,34],[37,37]]],[1520508538892,["gengmei_pxf@gengmei123.local",[[1,34,"\n"]],[34,34],[35,35]]],[1520508541478,["gengmei_pxf@gengmei123.local",[[1,38," 单例"]],[38,38],[41,41]]],[1520508542115,["gengmei_pxf@gengmei123.local",[[1,41,"\n\n"]],[41,41],[42,42]]],[1520508542731,["gengmei_pxf@gengmei123.local",[[1,43,"\n"]],[42,42],[43,43]]],[1520508548498,["gengmei_pxf@gengmei123.local",[[-1,43,"\n"],[1,44,"封装的攻击类"]],[43,43],[49,49]]],[1520508549267,["gengmei_pxf@gengmei123.local",[[-1,46,"攻击类"]],[49,49],[46,46]]],[1520508551638,["gengmei_pxf@gengmei123.local",[[1,46,"工具类"]],[46,46],[49,49]]],[1520508552267,["gengmei_pxf@gengmei123.local",[[1,49,"\n\n"]],[49,49],[50,50]]],[1520508553843,["gengmei_pxf@gengmei123.local",[[1,51,"\n"]],[50,50],[51,51]]],[1520508558046,["gengmei_pxf@gengmei123.local",[[-1,51,"\n"],[1,52,"参考"]],[51,51],[53,53]]],[1520508558707,["gengmei_pxf@gengmei123.local",[[-1,51,"参考"]],[53,53],[51,51]]],[1520508560115,["gengmei_pxf@gengmei123.local",[[1,51,"\n\n"]],[51,51],[52,52]]],[1520508561075,["gengmei_pxf@gengmei123.local",[[-1,52,"\n"]],[52,52],[51,51]]],[1520508561443,["gengmei_pxf@gengmei123.local",[[-1,51,"\n"]],[51,51],[50,50]]],[1520508562748,["gengmei_pxf@gengmei123.local",[[-1,50,"\n"],[1,51,"[]"]],[50,50],[52,52]]],[1520508564859,["gengmei_pxf@gengmei123.local",[[1,43,"c"]],[43,43],[44,44]]],[1520508565414,["gengmei_pxf@gengmei123.local",[[-1,43,"c"]],[44,44],[43,43]]],[1520508568789,["gengmei_pxf@gengmei123.local",[[1,43,"场景："]],[43,43],[46,46]]],[1520508570820,["gengmei_pxf@gengmei123.local",[[1,55,"()"]],[55,55],[57,57]]],[1520508735432,["gengmei_pxf@gengmei123.local",[[1,54,"# 单例的最佳实现方式"]],[54,54],[65,65]]],[1520508738461,["gengmei_pxf@gengmei123.local",[[-1,54,"# "]],[56,56],[54,54]]],[1520508744912,["gengmei_pxf@gengmei123.local",[[1,65,"https://pxfile.github.io/2018/03/08/%E5%8D%95%E4%BE%8B%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"]],[65,65],[183,183]]],[1520508748325,["gengmei_pxf@gengmei123.local",[[1,53,"\n"]],[52,52],[53,53]]],[1520508770606,["gengmei_pxf@gengmei123.local",[[1,54,"answer:"]],[54,54],[61,61]]],[1520508775620,["gengmei_pxf@gengmei123.local",[[-1,60,":"]],[61,61],[60,60]]],[1520508776366,["gengmei_pxf@gengmei123.local",[[1,60,"："]],[60,60],[61,61]]],[1520508785371,["gengmei_pxf@gengmei123.local",[[1,192,"\n\n"]],[192,192],[193,193]]],[1520508789506,["gengmei_pxf@gengmei123.local",[[1,194,"\n"]],[193,193],[194,194]]],[1520508792404,["gengmei_pxf@gengmei123.local",[[-1,194,"\n"],[1,195,"### "]],[194,194],[198,198]]],[1520508930308,["gengmei_pxf@gengmei123.local",[[1,43,"\n"]],[42,42],[43,43]]],[1520508931135,["gengmei_pxf@gengmei123.local",[[1,42,"1、概念\n\n单例模式是一种对象创建模式，它用于产生一个对象的具体实例，它可以确保系统中的一个类只产生一个实例\n\n2、好处\n\n*   省略创建对象所花费的时间\n*   对系统内存的使用频率降低，减轻GC压力，缩短GC停顿时间"]],[42,42],[153,153]]],[1520508936678,["gengmei_pxf@gengmei123.local",[[1,155,"2、"]],[155,155],[157,157]]],[1520508938812,["gengmei_pxf@gengmei123.local",[[-1,155,"2"]],[156,156],[155,155]]],[1520508939038,["gengmei_pxf@gengmei123.local",[[1,155,"3"]],[155,155],[156,156]]],[1520508959315,["gengmei_pxf@gengmei123.local",[[1,168,"```j"],[1,169,"va\npublic class Singleton {\n\t// Private co"],[-1,171,"wer：[单例的最佳实现方式](https://pxfi"],[1,199,"tructor prevents instantiation from other classes\n\tprivate Singleton() { }\n\n\t/**\n\t* SingletonHolder is loaded on the first execution of Sing"],[1,201,"ton"],[-1,203,"ithub.io/2018/03/08/%E5%8D%95%E4%BE%8B%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/)"],[1,306,"etInstance() \n\t* or the first access to SingletonHolder.INSTANCE, not before.\n\t*/\n\tprivate static class SingletonHolder { \n\t\t\tpublic static final Singleton INSTANCE = new Singleton();\n\t}\n\n\tpublic static Singleton getInstance() {\n\t\t\treturn SingletonHolder.INSTANCE;\n\t}\n}\n```\n**优点**\n\n*   运用类中静态变量的唯一性\n*   JVM本身同步控制机制（final、static）保证了线程安全\n*   没有使用Synchronized，保证了性能的优化\n*   静态内部类是私有的，除了外部类其他是无法访问的\n"]],[168,306],[758,758]]],[1520508962115,["gengmei_pxf@gengmei123.local",[[-1,759,"\n"]],[758,758],[757,757]]],[1520508978678,["gengmei_pxf@gengmei123.local",[[1,763,"## 建造者模式\n\n1、概念\n\n建造者模式是较为复杂的创建型模式，它将客户端与包含多个组成部分的复杂对象的创建过程分离\n\n2、使用场景\n\n当构造一个对象需要很多参数的时候，并且参数的个数或者类型不固定的时候"]],[763,763],[866,866]]],[1520508981339,["gengmei_pxf@gengmei123.local",[[-1,762," ##"]],[765,765],[762,762]]],[1520508995378,["gengmei_pxf@gengmei123.local",[[1,863,"\n\n"]],[863,863],[864,864]]],[1520508996346,["gengmei_pxf@gengmei123.local",[[1,865,"\n"]],[864,864],[865,865]]],[1520508996653,["gengmei_pxf@gengmei123.local",[[1,865,"4、在Android中应用\n\nAlertDialog、Glide、OkHttp"]],[865,865],[904,904]]],[1520508999072,["gengmei_pxf@gengmei123.local",[[-1,865,"4"]],[866,866],[865,865]]],[1520508999275,["gengmei_pxf@gengmei123.local",[[1,865,"3"]],[865,865],[866,866]]],[1520509007956,["gengmei_pxf@gengmei123.local",[[-1,157,"场景"],[1,159,"在Android中应用"]],[157,159],[168,168]]],[1520509010906,["gengmei_pxf@gengmei123.local",[[-1,168,"："]],[169,169],[168,168]]],[1520509011313,["gengmei_pxf@gengmei123.local",[[1,168,"\n"]],[168,168],[169,169]]],[1520509013657,["gengmei_pxf@gengmei123.local",[[1,169,"\n"]],[168,168],[169,169]]],[1520509073768,["gengmei_pxf@gengmei123.local",[[1,915,"\n"]],[914,914],[915,915]]],[1520509073975,["gengmei_pxf@gengmei123.local",[[1,916,"\n"]],[915,915],[916,916]]],[1520509074855,["gengmei_pxf@gengmei123.local",[[1,916,"## 适配器模式\n\n1、概念\n\n将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名又称包装类\n\n2、分类\n\n*   类适配器\n*   对象适配器\n\n3、类适配器定义\n\n类的适配器模式把适配的类的API转换成为目标类的API"]],[916,916],[1046,1046]]],[1520509077587,["gengmei_pxf@gengmei123.local",[[1,918,"#"]],[918,918],[919,919]]],[1520509113506,["gengmei_pxf@gengmei123.local",[[1,1048,"\n"]],[1047,1047],[1048,1048]]],[1520509114529,["gengmei_pxf@gengmei123.local",[[1,1049,"\n"]],[1048,1048],[1049,1049]]],[1520509114868,["gengmei_pxf@gengmei123.local",[[1,1049,"7、在Android中应用\n\nBaseAdapter类"]],[1049,1049],[1076,1076]]],[1520509116652,["gengmei_pxf@gengmei123.local",[[-1,1049,"7"]],[1050,1050],[1049,1049]]],[1520509116802,["gengmei_pxf@gengmei123.local",[[1,1049,"4"]],[1049,1049],[1050,1050]]],[1520509140385,["gengmei_pxf@gengmei123.local",[[1,1077,"\n"]],[1076,1076],[1077,1077]]],[1520509141079,["gengmei_pxf@gengmei123.local",[[1,1078,"\n"]],[1077,1077],[1078,1078]]],[1520509141473,["gengmei_pxf@gengmei123.local",[[1,1078,"## 装饰模式\n\n1、概念\n\n动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活\n\n2、使用场景\n\n*   在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责\n*   当不能采用集成的方式对系统进行拓展或者采用继承不利于系统拓展和维护时可以使用装饰模式"]],[1078,1078],[1228,1228]]],[1520509143307,["gengmei_pxf@gengmei123.local",[[1,1080,"#"]],[1080,1080],[1081,1081]]],[1520509146189,["gengmei_pxf@gengmei123.local",[[1,1230,"\n"]],[1229,1229],[1230,1230]]],[1520509146496,["gengmei_pxf@gengmei123.local",[[1,1231,"\n"]],[1230,1230],[1231,1231]]],[1520509158291,["gengmei_pxf@gengmei123.local",[[1,1231,"4、优点\n\n*   对于拓展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加\n*   可以通过一种动态的方式来拓展一个对象的功能\n*   可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合\n\n5、在Android中应用\n\ncontext类"]],[1231,1231],[1371,1371]]],[1520509162830,["gengmei_pxf@gengmei123.local",[[-1,1231,"4"]],[1232,1232],[1231,1231]]],[1520509163002,["gengmei_pxf@gengmei123.local",[[1,1231,"3"]],[1231,1231],[1232,1232]]],[1520509253243,["gengmei_pxf@gengmei123.local",[[1,1372,"\n"]],[1371,1371],[1372,1372]]],[1520509253578,["gengmei_pxf@gengmei123.local",[[1,1373,"\n"]],[1372,1372],[1373,1373]]],[1520509253983,["gengmei_pxf@gengmei123.local",[[1,1373,"## 外观模式\n\n1、概念\n\n外观模式的主要目的在于让外部减少与子系统内部多个模块的交互，从而让外部能够更简单得使用子系统，它负责把客户端的请求转发给子系统内部的各个的模块进行处理\n\n2、使用场景\n\n*   当你要为一个复杂子系统提供一个简单接口时\n*   客户程序与抽象类的实现部分之间存在很大的依赖性\n*   当你需要构建一个层次结构的子系统时"]],[1373,1373],[1547,1547]]],[1520509255891,["gengmei_pxf@gengmei123.local",[[1,1375,"#"]],[1375,1375],[1376,1376]]],[1520509321916,["gengmei_pxf@gengmei123.local",[[1,1549,"\n"]],[1548,1548],[1549,1549]]],[1520509322300,["gengmei_pxf@gengmei123.local",[[1,1550,"\n"]],[1549,1549],[1550,1550]]],[1520509322759,["gengmei_pxf@gengmei123.local",[[1,1550,"4、优点\n\n*   由于Facade类封装了各个模块交互的过程，如果今后内部模块调用关系发生了变化，只需要修改Facade实现就可以了\n*   Facade实现是可以被多个客户端调用的\n\n5、在Android中应用\n\ncontextImpl类"]],[1550,1550],[1671,1671]]],[1520509324972,["gengmei_pxf@gengmei123.local",[[-1,1550,"4"]],[1551,1551],[1550,1550]]],[1520509325133,["gengmei_pxf@gengmei123.local",[[1,1550,"3"]],[1550,1550],[1551,1551]]],[1520509327436,["gengmei_pxf@gengmei123.local",[[-1,1644,"5"]],[1645,1645],[1644,1644]]],[1520509327621,["gengmei_pxf@gengmei123.local",[[1,1644,"4"]],[1644,1644],[1645,1645]]],[1520509329899,["gengmei_pxf@gengmei123.local",[[1,1672,"\n"]],[1671,1671],[1672,1672]]],[1520509330227,["gengmei_pxf@gengmei123.local",[[1,1673,"\n"]],[1672,1672],[1673,1673]]],[1520509333181,["gengmei_pxf@gengmei123.local",[[1,1659,"**"]],[1659,1659],[1661,1661]]],[1520509336422,["gengmei_pxf@gengmei123.local",[[1,1673,"**"]],[1673,1673],[1675,1675]]],[1520509342694,["gengmei_pxf@gengmei123.local",[[1,1363,"**"]],[1363,1363],[1365,1365]]],[1520509343894,["gengmei_pxf@gengmei123.local",[[1,1373,"**"]],[1373,1373],[1375,1375]]],[1520509346654,["gengmei_pxf@gengmei123.local",[[1,1064,"**"]],[1064,1064],[1066,1066]]],[1520509347669,["gengmei_pxf@gengmei123.local",[[1,1078,"**"]],[1078,1078],[1080,1080]]],[1520509350541,["gengmei_pxf@gengmei123.local",[[1,890,"**"]],[890,890],[892,892]]],[1520509351542,["gengmei_pxf@gengmei123.local",[[1,916,"**"]],[916,916],[918,918]]],[1520509357972,["gengmei_pxf@gengmei123.local",[[1,170,"**"]],[170,170],[172,172]]],[1520509359011,["gengmei_pxf@gengmei123.local",[[1,178,"**"]],[178,178],[180,180]]],[1520509492032,["gengmei_pxf@gengmei123.local",[[1,178,"ResourcesUtil"]],[178,178],[191,191]]],[1520509503310,["gengmei_pxf@gengmei123.local",[[1,1707,"\n"]],[1705,1705],[1706,1706]]],[1520509538316,["gengmei_pxf@gengmei123.local",[[1,1706,"## 组合模式\n\n1、概念\n\n将对象以树形结构组织起来，以达到“部分-整体”的层次结构，使得客户端对单个对象和组合对象的使用具有一致性\n\n2、使用场景\n\n*   需要表示一个对象整体或部分层次\n*   让客户能够忽略不同对象层次的变化\n\n3、UML图分析\n\n![这里写图片描述](http://img.blog.csdn.net/20170818011844620?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzAzNzk2ODk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n4、优点\n\n*   高层模块调用简单\n*   节点自由增加\n\n5、在Android中应用\n\nView、ViewGroup\n\n## 策略模式\n\n1、概念\n\n定义一系列的算法，把它们一个个封装起来，并且使他们可互相替换，本模式使得算法可独立于使用它的客户而变化\n\n2、使用场景\n\n一个类定义了多种行为，并且这些行为在这个类的方法中以多个条件语句的形式出现，那么可以使用策略模式避免在类中使用大量的条件语句\n\n3、UML图分析\n\n![这里写图片描述](http://img.blog.csdn.net/20170818011856084?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzAzNzk2ODk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n4、优点\n\n*   上下文（Context）和具体策略（AbstractStrange）是松耦合关系\n*   策略模式满足“开闭原则”\n\n5、在Android中应用\n\nVolley、属性动画、插值器\n\n## 模板方法模式\n\n1、概念\n\n模板方法是通过定义一个算法骨架，而将算法中的步骤延迟到子类，这样子类就可以复写这些步骤的实现来实现特定的算法\n\n2、使用场景\n\n*   多个子类有公有的方法，并且逻辑基本相同时\n*   重要、复杂的算法，可以把核心算法设计为模板方法\n*   重构时，模板方法模式是一个经常使用的模式\n\n3、UML图分析\n\n![这里写图片描述](http://img.blog.csdn.net/20170818011907342?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzAzNzk2ODk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n4、在Android中应用\n\nActivity和Fragment生命周期、AsyncTask、BaseActivity\n\n## 观察者模式\n\n1、概念\n\n定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新\n\n2、使用场景\n\n*   一个抽象模型由两个方面，其中一个方面依赖于另一个方面\n*   一个对象的改变将导致一个或多个其他对象也发生改变\n*   需要在系统中创建一个触发链\n\n3、UML图分析\n\n![这里写图片描述](http://img.blog.csdn.net/20170818011917867?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzAzNzk2ODk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n4、在Android中应用\n\nListView、RxJava\n\n## 责任链模式\n\n1、概念\n\n是一个请求有多个对象来处理，这些对象是一条链，但具体由哪个对象来处理，根据条件判断来确定，如果不能处理会传递给该链中的下一个对象，直到有对象处理它为止\n\n2、使用场景\n\n*   有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定\n*   在不明确指定接收者的情况下，向多个对象中的一个提交一个请求\n*   可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求\n\n3、UML图分析\n\n![这里写图片描述](http://img.blog.csdn.net/20170818011927440?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzAzNzk2ODk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n4、在Android中应用\n\ntry-catch语句、有序广播、事件分发机制"]],[1706,1706],[3801,3801]]],[1520509546047,["gengmei_pxf@gengmei123.local",[[1,1708,"#"]],[1708,1708],[1709,1709]]],[1520509554303,["gengmei_pxf@gengmei123.local",[[-1,1828,"UML图分析\n\n![这里写图片描述](http://img.blog.csdn.net/20170818011844620?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzAzNzk2ODk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n4、"]],[1826,2030],[1827,1827]]],[1520509557717,["gengmei_pxf@gengmei123.local",[[-1,1857,"5"]],[1858,1858],[1857,1857]]],[1520509557918,["gengmei_pxf@gengmei123.local",[[1,1857,"4"]],[1857,1857],[1858,1858]]],[1520509560783,["gengmei_pxf@gengmei123.local",[[1,1890,"#"]],[1889,1889],[1890,1890]]],[1520509573708,["gengmei_pxf@gengmei123.local",[[-1,2031,"UML图分析\n\n![这里写图片描述](http://img.blog.csdn.net/20170818011856084?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzAzNzk2ODk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n4、优点"]],[2031,2236],[2031,2031]]],[1520509575457,["gengmei_pxf@gengmei123.local",[[1,2031,"UML图分析\n\n![这里写图片描述](http://img.blog.csdn.net/20170818011856084?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzAzNzk2ODk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n4、优点"]],[2031,2031],[2031,2236]]],[1520509583179,["gengmei_pxf@gengmei123.local",[[-1,2031,"UML图分析\n\n![这里写图片描述](http://img.blog.csdn.net/20170818011856084?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzAzNzk2ODk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n4、"]],[2031,2234],[2031,2031]]],[1520509596290,["gengmei_pxf@gengmei123.local",[[1,1872,"**"]],[1872,1872],[1874,1874]]],[1520509598446,["gengmei_pxf@gengmei123.local",[[1,1888,"**"]],[1888,1888],[1890,1890]]],[1520509614635,["gengmei_pxf@gengmei123.local",[[-1,2102,"5"]],[2103,2103],[2102,2102]]],[1520509614860,["gengmei_pxf@gengmei123.local",[[1,2102,"4"]],[2102,2102],[2103,2103]]],[1520509616413,["gengmei_pxf@gengmei123.local",[[1,2117,"**"]],[2117,2117],[2119,2119]]],[1520509617357,["gengmei_pxf@gengmei123.local",[[1,2134,"**"]],[2134,2134],[2136,2136]]],[1520509628477,["gengmei_pxf@gengmei123.local",[[1,2140,"#"]],[2140,2140],[2141,2141]]],[1520509633642,["gengmei_pxf@gengmei123.local",[[-1,2301,"UML图分析\n\n![这里写图片描述](http://img.blog.csdn.net/20170818011907342?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzAzNzk2ODk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n4、"]],[2301,2504],[2301,2301]]],[1520509636756,["gengmei_pxf@gengmei123.local",[[1,2314,"**"]],[2314,2314],[2316,2316]]],[1520509638308,["gengmei_pxf@gengmei123.local",[[1,2360,"**"]],[2360,2360],[2362,2362]]],[1520509640588,["gengmei_pxf@gengmei123.local",[[1,2366,"#"]],[2366,2366],[2367,2367]]],[1520509651826,["gengmei_pxf@gengmei123.local",[[-1,2523,"UML图分析\n\n![这里写图片描述](http://img.blog.csdn.net/20170818011917867?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzAzNzk2ODk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n4、"]],[2523,2726],[2523,2523]]],[1520509654274,["gengmei_pxf@gengmei123.local",[[1,2536,"**"]],[2536,2536],[2538,2538]]],[1520509655483,["gengmei_pxf@gengmei123.local",[[1,2553,"**"]],[2553,2553],[2555,2555]]],[1520509658692,["gengmei_pxf@gengmei123.local",[[1,2559,"#"]],[2559,2559],[2560,2560]]],[1520509665715,["gengmei_pxf@gengmei123.local",[[-1,2771,"UML图分析\n\n![这里写图片描述](http://img.blog.csdn.net/20170818011927440?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzAzNzk2ODk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n4、"]],[2771,2974],[2771,2771]]],[1520509667459,["gengmei_pxf@gengmei123.local",[[1,2784,"**"]],[2784,2784],[2786,2786]]],[1520509668331,["gengmei_pxf@gengmei123.local",[[1,2809,"**"]],[2809,2809],[2811,2811]]],[1520509777727,["gengmei_pxf@gengmei123.local",[[1,2813,"\n"]],[2812,2812],[2813,2813]]],[1520509780545,["gengmei_pxf@gengmei123.local",[[-1,2813,"\n"],[1,2814,"## "]],[2813,2813],[2816,2816]]],[1520509811758,["gengmei_pxf@gengmei123.local",[[1,2816,"*   Android各组件和机制"]],[2816,2816],[2833,2833]]],[1520509814784,["gengmei_pxf@gengmei123.local",[[-1,2815," *"]],[2817,2817],[2815,2815]]],[1520509816606,["gengmei_pxf@gengmei123.local",[[1,2831,"\n\n"]],[2831,2831],[2832,2832]]],[1520509817000,["gengmei_pxf@gengmei123.local",[[1,2833,"\n"]],[2832,2832],[2833,2833]]],[1520509818792,["gengmei_pxf@gengmei123.local",[[-1,2817," "]],[2818,2818],[2817,2817]]],[1520509820792,["gengmei_pxf@gengmei123.local",[[1,2833,"\n"]],[2832,2832],[2833,2833]]],[1520509834220,["gengmei_pxf@gengmei123.local",[[-1,2833,"\n"],[1,2834,"## *   模块化和组件化开发"]],[2833,2833],[2849,2849]]],[1520509836832,["gengmei_pxf@gengmei123.local",[[-1,2836,"*   "]],[2840,2840],[2836,2836]]],[1520509838178,["gengmei_pxf@gengmei123.local",[[1,2836," "]],[2836,2836],[2837,2837]]],[1520509839143,["gengmei_pxf@gengmei123.local",[[1,2846,"\n\n"]],[2846,2846],[2847,2847]]],[1520509839495,["gengmei_pxf@gengmei123.local",[[1,2848,"\n"]],[2847,2847],[2848,2848]]],[1520509869560,["gengmei_pxf@gengmei123.local",[[-1,2848,"\n"],[1,2849,"{}"]],[2848,2848],[2850,2850]]],[1520509870247,["gengmei_pxf@gengmei123.local",[[-1,2848,"{}"]],[2850,2850],[2848,2848]]],[1520509871648,["gengmei_pxf@gengmei123.local",[[-1,2847,"\n"],[1,2848,"[]()"]],[2848,2848],[2851,2851]]],[1520509873410,["gengmei_pxf@gengmei123.local",[[1,2848,"https://pxfile.github.io/2018/03/02/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"]],[2848,2848],[2966,2966]]],[1520509874298,["gengmei_pxf@gengmei123.local",[[-1,2848,"https://pxfile.github.io/2018/03/02/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"]],[2966,2966],[2848,2848]]],[1520509875610,["gengmei_pxf@gengmei123.local",[[1,2850,"https://pxfile.github.io/2018/03/02/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"]],[2850,2850],[2968,2968]]],[1520509880377,["gengmei_pxf@gengmei123.local",[[1,2848,"模块化和组件化开发"]],[2848,2848],[2857,2857]]],[1520509885566,["gengmei_pxf@gengmei123.local",[[1,2978,"\n\n"]],[2978,2978],[2979,2979]]],[1520509887061,["gengmei_pxf@gengmei123.local",[[1,2980,"\n"]],[2979,2979],[2980,2980]]],[1520509904793,["gengmei_pxf@gengmei123.local",[[-1,2980,"\n"],[1,2981,"## *   Android开发模式(MVC，MVVM，MVP)"]],[2980,2980],[3012,3012]]],[1520509907646,["gengmei_pxf@gengmei123.local",[[-1,2983,"*   "]],[2983,2987],[2983,2983]]],[1520509911103,["gengmei_pxf@gengmei123.local",[[1,2983," "]],[2983,2983],[2984,2984]]],[1520509912381,["gengmei_pxf@gengmei123.local",[[1,3009,"\n\n"]],[3009,3009],[3010,3010]]],[1520509912877,["gengmei_pxf@gengmei123.local",[[1,3011,"\n"]],[3010,3010],[3011,3011]]],[1520509961910,["gengmei_pxf@gengmei123.local",[[1,3010,"[]()"]],[3010,3010],[3014,3014]]],[1520509962807,["gengmei_pxf@gengmei123.local",[[1,3013,"https://www.cnblogs.com/guwei4037/p/5591183.html"]],[3013,3013],[3061,3061]]],[1520509971470,["gengmei_pxf@gengmei123.local",[[1,3011,"# [浅谈MVC、MVP、MVVM架构模式的区别和联系](http://www.cnblogs.com/guwei4037/p/5591183.html)"]],[3011,3011],[3088,3088]]],[1520509978118,["gengmei_pxf@gengmei123.local",[[-1,3010,"["],[-1,3044,"://www.cnblogs.com/guwei4037/p/5591183.html)](https"]],[3010,3139],[3087,3087]]],[1520509979929,["gengmei_pxf@gengmei123.local",[[1,3010,"["],[1,3043,"://www.cnblogs.com/guwei4037/p/5591183.html)](https"]],[3087,3087],[3010,3139]]],[1520510749769,["gengmei_pxf@gengmei123.local",[[-1,3011,"# [浅谈MVC、MVP、MVVM架构模式的区别和联系](http://www.cnblogs.com/guwei4037/p/5591183.html)"]],[3088,3088],[3011,3011]]],[1520510754577,["gengmei_pxf@gengmei123.local",[[1,3010,"# "],[1,3011,"浅谈MVC、MVP、MVVM架构模式的区别和联系"],[-1,3017,"s"]],[3010,3062],[3087,3087]]],[1520510758838,["gengmei_pxf@gengmei123.local",[[-1,3010,"#"]],[3011,3011],[3010,3010]]],[1520510759917,["gengmei_pxf@gengmei123.local",[[-1,3009,"\n"]],[3010,3010],[3009,3009]]],[1520510761365,["gengmei_pxf@gengmei123.local",[[1,3009,"\n"]],[3009,3009],[3010,3010]]],[1520510762614,["gengmei_pxf@gengmei123.local",[[-1,3010," "]],[3011,3011],[3010,3010]]],[1520510940217,["gengmei_pxf@gengmei123.local",[[1,3087,"\n"]],[3086,3086],[3087,3087]]],[1520510945483,["gengmei_pxf@gengmei123.local",[[-1,3087,"\n"],[1,3088,"## 事件"]],[3087,3087],[3092,3092]]],[1520510948235,["gengmei_pxf@gengmei123.local",[[1,3092,"分发机制"]],[3092,3092],[3096,3096]]],[1520510949845,["gengmei_pxf@gengmei123.local",[[1,3096,"\n\n*   https://www.jianshu.com/p/38015afcdb58"]],[3096,3096],[3139,3139]]],[1520510950741,["gengmei_pxf@gengmei123.local",[[-1,3097,"*   https://www.jianshu.com/p/38015afcdb58"]],[3139,3139],[3097,3097]]],[1520510952484,["gengmei_pxf@gengmei123.local",[[-1,3097,"\n"],[1,3098,"{}"]],[3097,3097],[3099,3099]]],[1520510953049,["gengmei_pxf@gengmei123.local",[[-1,3098,"}"]],[3099,3099],[3098,3098]]],[1520510953209,["gengmei_pxf@gengmei123.local",[[-1,3097,"{"],[1,3098,"\n"]],[3098,3098],[3097,3097]]],[1520510953827,["gengmei_pxf@gengmei123.local",[[-1,3097,"\n"],[1,3098,"【】"]],[3097,3097],[3099,3099]]],[1520510954529,["gengmei_pxf@gengmei123.local",[[-1,3098,"】"]],[3099,3099],[3098,3098]]],[1520510954705,["gengmei_pxf@gengmei123.local",[[-1,3097,"【"],[1,3098,"\n"]],[3098,3098],[3097,3097]]],[1520510956578,["gengmei_pxf@gengmei123.local",[[-1,3097,"\n"],[1,3098,"[]()"]],[3097,3097],[3101,3101]]],[1520510958246,["gengmei_pxf@gengmei123.local",[[1,3100,"*   https://www.jianshu.com/p/38015afcdb58"]],[3100,3100],[3142,3142]]],[1520510961959,["gengmei_pxf@gengmei123.local",[[-1,3100,"*   "]],[3100,3103],[3100,3100]]],[1520510966448,["gengmei_pxf@gengmei123.local",[[1,3098,"事件分发机制"]],[3098,3098],[3104,3104]]],[1520511330449,["gengmei_pxf@gengmei123.local",[[1,3145,"\n\n"]],[3145,3145],[3146,3146]]],[1520511330808,["gengmei_pxf@gengmei123.local",[[1,3147,"\n"]],[3146,3146],[3147,3147]]],[1520511332772,["gengmei_pxf@gengmei123.local",[[-1,3147,"\n"],[1,3148,"## # 机型适配"]],[3147,3147],[3156,3156]]],[1520511335960,["gengmei_pxf@gengmei123.local",[[-1,3150,"# "]],[3152,3152],[3150,3150]]],[1520511337784,["gengmei_pxf@gengmei123.local",[[1,3154,"\n\n"]],[3154,3154],[3155,3155]]],[1520511352482,["gengmei_pxf@gengmei123.local",[[-1,3155,"\n"],[1,3156,"[]()"]],[3155,3155],[3159,3159]]],[1520511353403,["gengmei_pxf@gengmei123.local",[[1,3158,"http://blog.csdn.net/mwq384807683/article/details/72594027"]],[3158,3158],[3216,3216]]],[1520511358754,["gengmei_pxf@gengmei123.local",[[1,3156,"机型适配"]],[3156,3156],[3160,3160]]],[1520511365863,["gengmei_pxf@gengmei123.local",[[1,3087,"\n"]],[3085,3085],[3086,3086]]],[1520511366069,["gengmei_pxf@gengmei123.local",[[1,3088,"\n"]],[3086,3086],[3087,3087]]],[1520511445289,["gengmei_pxf@gengmei123.local",[[-1,3088,"\n"]],[3087,3087],[3086,3086]]],[1520511445841,["gengmei_pxf@gengmei123.local",[[-1,3087,"\n"]],[3086,3086],[3085,3085]]],[1520511450984,["gengmei_pxf@gengmei123.local",[[1,3221,"\n\n"]],[3221,3221],[3222,3222]]],[1520511451272,["gengmei_pxf@gengmei123.local",[[1,3223,"\n"]],[3222,3222],[3223,3223]]],[1520511453922,["gengmei_pxf@gengmei123.local",[[-1,3223,"\n"],[1,3224,"## "]],[3223,3223],[3226,3226]]],[1520511454704,["gengmei_pxf@gengmei123.local",[[1,3226,"\n\n"]],[3226,3226],[3227,3227]]],[1520511456540,["gengmei_pxf@gengmei123.local",[[-1,3227,"\n"],[1,3228,"[]()"]],[3227,3227],[3231,3231]]],[1520511457356,["gengmei_pxf@gengmei123.local",[[1,3230,"http://blog.csdn.net/angel_w/article/details/79103141"]],[3230,3230],[3283,3283]]],[1520511467507,["gengmei_pxf@gengmei123.local",[[1,3228,"[Android面试题](http://blog.csdn.net/angel_w/article/details/79103141)"]],[3228,3228],[3295,3295]]],[1520511469749,["gengmei_pxf@gengmei123.local",[[-1,3228,"[Android面试题](http://blog.csdn.net/angel_w/article/details/79103141)"]],[3295,3295],[3228,3228]]],[1520511472100,["gengmei_pxf@gengmei123.local",[[1,3228,"Android面试题"]],[3227,3284],[3294,3294]]],[1520511478123,["gengmei_pxf@gengmei123.local",[[1,3226,"Android面试题"]],[3226,3226],[3236,3236]]],[1520511662411,["gengmei_pxf@gengmei123.local",[[1,17,"\n"]],[16,16],[17,17]]],[1520511662570,["gengmei_pxf@gengmei123.local",[[1,18,"\n"]],[17,17],[18,18]]],[1520511663454,["gengmei_pxf@gengmei123.local",[[1,17,"*   **基础知识 – 四大组件（生命周期，使用场景，如何启动）**\n*   **java基础 – 数据结构，线程，mvc框架**\n*   **通信 – 网络连接（HttpClient，HttpUrlConnetion），Socket**\n*   **数据持久化 – SQLite，SharedPreferences，ContentProvider**\n*   **性能优化 – 布局优化，内存优化，电量优化**\n*   **安全 – 数据加密，代码混淆，WebView/Js调用，https**\n*   **UI– 动画**\n*   **其他 – JNI，AIDL，Handler，Intent等**\n*   **开源框架 – Volley，Gilde，RxJava等（简历上写你会的，用过的）**\n*   **拓展 – Android6.0/7.0/8.0特性，kotlin语言，I/O大会**"]],[17,17],[417,417]]],[1520512150047,["gengmei_pxf@gengmei123.local",[[1,3235,"\n"]],[3232,3232],[3233,3233]]],[1520512202936,["gengmei_pxf@gengmei123.local",[[1,3550,"\n"]],[3548,3548],[3549,3549]]],[1520512203407,["gengmei_pxf@gengmei123.local",[[1,3551,"\n"]],[3549,3549],[3550,3550]]],[1520512205937,["gengmei_pxf@gengmei123.local",[[1,3550,"## [## Handler机制](https://pxfile.github.io/2018/03/08/%E7%B2%BE%E9%80%9AAndroid%E4%B8%8B%E7%9A%84Handler%E6%9C%BA%E5%88%B6/)"]],[3550,3550],[3674,3674]]],[1520512207701,["gengmei_pxf@gengmei123.local",[[-1,3550,"## [## Handler机制](https://pxfile.github.io/2018/03/08/%E7%B2%BE%E9%80%9AAndroid%E4%B8%8B%E7%9A%84Handler%E6%9C%BA%E5%88%B6/)"]],[3674,3674],[3550,3550]]],[1520512208498,["gengmei_pxf@gengmei123.local",[[1,3550," [## Handler机制](https://pxfile.github.io/2018/03/08/%E7%B2%BE%E9%80%9AAndroid%E4%B8%8B%E7%9A%84Handler%E6%9C%BA%E5%88%B6/)"]],[3550,3550],[3672,3672]]],[1520512214335,["gengmei_pxf@gengmei123.local",[[-1,3552,"## "]],[3552,3554],[3552,3552]]],[1520512216671,["gengmei_pxf@gengmei123.local",[[-1,3550," "]],[3551,3551],[3550,3550]]],[1520512218566,["gengmei_pxf@gengmei123.local",[[1,3550,"\n"]],[3549,3549],[3550,3550]]],[1520512224353,["gengmei_pxf@gengmei123.local",[[1,3550,"## Handler机制"]],[3550,3550],[3562,3562]]],[1520512261510,["gengmei_pxf@gengmei123.local",[[1,3234,"\t"]],[3234,3234],[3235,3235]]],[1520512262494,["gengmei_pxf@gengmei123.local",[[-1,3234,"\t"]],[3235,3235],[3234,3234]]],[1520512263053,["gengmei_pxf@gengmei123.local",[[-1,3235,"\n"]],[3234,3234],[3233,3233]]],[1520512264651,["gengmei_pxf@gengmei123.local",[[1,3233,"\t"]],[3233,3233],[3234,3234]]],[1520512265557,["gengmei_pxf@gengmei123.local",[[-1,3233,"\t"]],[3234,3234],[3233,3233]]],[1520512268325,["gengmei_pxf@gengmei123.local",[[1,3235,"\n"]],[3233,3233],[3234,3234]]],[1520512272280,["gengmei_pxf@gengmei123.local",[[1,3234,"###  [## Activity](https://pxfile.github.io/2018/03/08/%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3Activity/)"]],[3234,3234],[3335,3335]]],[1520512273263,["gengmei_pxf@gengmei123.local",[[-1,3234,"###  [## Activity](https://pxfile.github.io/2018/03/08/%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3Activity/)"]],[3335,3335],[3234,3234]]],[1520512274360,["gengmei_pxf@gengmei123.local",[[1,3234," [## Activity](https://pxfile.github.io/2018/03/08/%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3Activity/)"]],[3234,3234],[3331,3331]]],[1520512276095,["gengmei_pxf@gengmei123.local",[[1,3238,"#"]],[3238,3238],[3239,3239]]],[1520512279696,["gengmei_pxf@gengmei123.local",[[-1,3236,"### "]],[3236,3240],[3236,3236]]],[1520512281399,["gengmei_pxf@gengmei123.local",[[1,3235,"### "]],[3235,3235],[3239,3239]]],[1520512284157,["gengmei_pxf@gengmei123.local",[[-1,3234," "]],[3235,3235],[3234,3234]]],[1520512287540,["gengmei_pxf@gengmei123.local",[[1,3333,"\n"]],[3331,3331],[3332,3332]]],[1520512288044,["gengmei_pxf@gengmei123.local",[[1,3334,"\n"]],[3332,3332],[3333,3333]]],[1520512289255,["gengmei_pxf@gengmei123.local",[[1,3333,"###"]],[3333,3333],[3336,3336]]],[1520512300199,["gengmei_pxf@gengmei123.local",[[1,3336,"  [## Service](https://pxfile.github.io/2018/03/08/Service%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93/)"]],[3336,3336],[3432,3432]]],[1520512303564,["gengmei_pxf@gengmei123.local",[[-1,3339,"## "]],[3341,3341],[3339,3339]]],[1520512306923,["gengmei_pxf@gengmei123.local",[[1,3431,"\n"]],[3429,3429],[3430,3430]]],[1520512307451,["gengmei_pxf@gengmei123.local",[[1,3432,"\n"]],[3430,3430],[3431,3431]]],[1520512316527,["gengmei_pxf@gengmei123.local",[[1,3431,"###  [## ContentProvider](https://pxfile.github.io/2018/03/08/ContentProvider%E5%AE%9E%E4%BE%8B%E8%AF%A6%E8%A7%A3/)"]],[3431,3431],[3546,3546]]],[1520512319859,["gengmei_pxf@gengmei123.local",[[-1,3437,"## "]],[3437,3440],[3437,3437]]],[1520512322083,["gengmei_pxf@gengmei123.local",[[1,3545,"\n"]],[3543,3543],[3544,3544]]],[1520512322289,["gengmei_pxf@gengmei123.local",[[1,3546,"\n"]],[3544,3544],[3545,3545]]],[1520512335654,["gengmei_pxf@gengmei123.local",[[1,3545,"###  [## BroadcastReceiver](https://pxfile.github.io/2018/03/08/BroadcastReceiver%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/)"]],[3545,3545],[3664,3664]]],[1520512338691,["gengmei_pxf@gengmei123.local",[[-1,3551,"## "]],[3551,3554],[3551,3551]]],[1520512392891,["gengmei_pxf@gengmei123.local",[[1,4186,"\n"]],[4184,4184],[4185,4185]]],[1520512393150,["gengmei_pxf@gengmei123.local",[[1,4187,"\n"]],[4185,4185],[4186,4186]]],[1520512399277,["gengmei_pxf@gengmei123.local",[[1,4186,"## 内存"]],[4186,4186],[4191,4191]]],[1520512400359,["gengmei_pxf@gengmei123.local",[[1,4191,"泄漏"]],[4191,4191],[4193,4193]]],[1520512400696,["gengmei_pxf@gengmei123.local",[[1,4195,"\n"]],[4193,4193],[4194,4194]]],[1520512401204,["gengmei_pxf@gengmei123.local",[[1,4194," [## 内存泄漏](https://pxfile.github.io/2018/02/14/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/)"]],[4194,4194],[4286,4286]]],[1520512405434,["gengmei_pxf@gengmei123.local",[[-1,4196,"## "]],[4196,4199],[4196,4196]]],[1520512430322,["gengmei_pxf@gengmei123.local",[[1,4285,"\n"]],[4283,4283],[4284,4284]]],[1520512430601,["gengmei_pxf@gengmei123.local",[[1,4286,"\n"]],[4284,4284],[4285,4285]]],[1520512436676,["gengmei_pxf@gengmei123.local",[[1,4285,"## Binder机制"]],[4285,4285],[4296,4296]]],[1520512437041,["gengmei_pxf@gengmei123.local",[[1,4298,"\n"]],[4296,4296],[4297,4297]]],[1520512437748,["gengmei_pxf@gengmei123.local",[[1,4297," [## Binder机制](https://pxfile.github.io/2018/03/07/Binder%E6%9C%BA%E5%88%B6/)"]],[4297,4297],[4374,4374]]],[1520512440857,["gengmei_pxf@gengmei123.local",[[-1,4299,"## "]],[4299,4302],[4299,4299]]],[1520512611300,["gengmei_pxf@gengmei123.local",[[1,4186,"\n"]],[4184,4184],[4185,4185]]],[1520512611619,["gengmei_pxf@gengmei123.local",[[1,4187,"\n"]],[4185,4185],[4186,4186]]],[1520512616198,["gengmei_pxf@gengmei123.local",[[1,4186,"## 性能优化"]],[4186,4186],[4193,4193]]],[1520512616735,["gengmei_pxf@gengmei123.local",[[1,4195,"\n"]],[4193,4193],[4194,4194]]],[1520512617167,["gengmei_pxf@gengmei123.local",[[1,4194," [## 性能优化](https://pxfile.github.io/2018/03/08/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/)"]],[4194,4194],[4279,4279]]],[1520512620036,["gengmei_pxf@gengmei123.local",[[-1,4196,"## "]],[4199,4199],[4196,4196]]],[1520512639651,["gengmei_pxf@gengmei123.local",[[1,4465,"\n"]],[4463,4463],[4464,4464]]],[1520512639946,["gengmei_pxf@gengmei123.local",[[1,4466,"\n"]],[4464,4464],[4465,4465]]],[1520512647045,["gengmei_pxf@gengmei123.local",[[1,4465,"## 混合开发"]],[4465,4465],[4472,4472]]],[1520512689852,["gengmei_pxf@gengmei123.local",[[-1,437,"### 单例\n1、概念\n\n单例模式是一种对象创建模式，它用于产生一个对象的具体实例，它可以确保系统中的一个类只产生一个实例\n\n2、好处\n\n*   省略创建对象所花费的时间\n*   对系统内存的使用频率降低，减轻GC压力，缩短GC停顿时间\n\n3、在Android中应用\n\n**封装的工具类ResourcesUtil**\n\n```java\npublic class Singleton {\n\t// Private constructor prevents instantiation from other classes\n\tprivate Singleton() { }\n\n\t/**\n\t* SingletonHolder is loaded on the first execution of Singleton.getInstance() \n\t* or the first access to SingletonHolder.INSTANCE, not before.\n\t*/\n\tprivate static class SingletonHolder { \n\t\t\tpublic static final Singleton INSTANCE = new Singleton();\n\t}\n\n\tpublic static Singleton getInstance() {\n\t\t\treturn SingletonHolder.INSTANCE;\n\t}\n}\n```\n**优点**\n\n*   运用类中静态变量的唯一性\n*   JVM本身同步控制机制（final、static）保证了线程安全\n*   没有使用Synchronized，保证了性能的优化\n*   静态内部类是私有的，除了外部类其他是无法访问的\n\n### 建造者模式\n\n1、概念\n\n建造者模式是较为复杂的创建型模式，它将客户端与包含多个组成部分的复杂对象的创建过程分离\n\n2、使用场景\n\n当构造一个对象需要很多参数的时候，并且参数的个数或者类型不固定的时候\n\n3、在Android中应用\n\n**AlertDialog、Glide、OkHttp**\n\n### 适配器模式\n\n1、概念\n\n将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名又称包装类\n\n2、分类\n\n*   类适配器\n*   对象适配器\n\n3、类适配器定义\n\n类的适配器模式把适配的类的API转换成为目标类的API\n\n4、在Android中应用\n\n**BaseAdapter类**\n\n### 装饰模式\n\n1、概念\n\n动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活\n\n2、使用场景\n\n*   在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责\n*   当不能采用集成的方式对系统进行拓展或者采用继承不利于系统拓展和维护时可以使用装饰模式\n\n3、优点\n\n*   对于拓展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加\n*   可以通过一种动态的方式来拓展一个对象的功能\n*   可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合\n\n5、在Android中应用\n\n**context类**\n\n### 外观模式\n\n1、概念\n\n外观模式的主要目的在于让外部减少与子系统内部多个模块的交互，从而让外部能够更简单得使用子系统，它负责把客户端的请求转发给子系统内部的各个的模块进行处理\n\n2、使用场景\n\n*   当你要为一个复杂子系统提供一个简单接口时\n*   客户程序与抽象类的实现部分之间存在很大的依赖性\n*   当你需要构建一个层次结构的子系统时\n\n3、优点\n\n*   由于Facade类封装了各个模块交互的过程，如果今后内部模块调用关系发生了变化，只需要修改Facade实现就可以了\n*   Facade实现是可以被多个客户端调用的\n\n4、在Android中应用\n\n**contextImpl类**\n\n### 组合模式\n\n1、概念\n\n将对象以树形结构组织起来，以达到“部分-整体”的层次结构，使得客户端对单个对象和组合对象的使用具有一致性\n\n2、使用场景\n\n*   需要表示一个对象整体或部分层次\n*   让客户能够忽略不同对象层次的变化\n\n3、优点\n\n*   高层模块调用简单\n*   节点自由增加\n\n4、在Android中应用\n\n**View、ViewGroup**\n\n### 策略模式\n\n1、概念\n\n定义一系列的算法，把它们一个个封装起来，并且使他们可互相替换，本模式使得算法可独立于使用它的客户而变化\n\n2、使用场景\n\n一个类定义了多种行为，并且这些行为在这个类的方法中以多个条件语句的形式出现，那么可以使用策略模式避免在类中使用大量的条件语句\n\n3、优点\n\n*   上下文（Context）和具体策略（AbstractStrange）是松耦合关系\n*   策略模式满足“开闭原则”\n\n4、在Android中应用\n\n**Volley、属性动画、插值器**\n\n### 模板方法模式\n\n1、概念\n\n模板方法是通过定义一个算法骨架，而将算法中的步骤延迟到子类，这样子类就可以复写这些步骤的实现来实现特定的算法\n\n2、使用场景\n\n*   多个子类有公有的方法，并且逻辑基本相同时\n*   重要、复杂的算法，可以把核心算法设计为模板方法\n*   重构时，模板方法模式是一个经常使用的模式\n\n3、在Android中应用\n\n**Activity和Fragment生命周期、AsyncTask、BaseActivity**\n\n### 观察者模式\n\n1、概念\n\n定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新\n\n2、使用场景\n\n*   一个抽象模型由两个方面，其中一个方面依赖于另一个方面\n*   一个对象的改变将导致一个或多个其他对象也发生改变\n*   需要在系统中创建一个触发链\n\n3、在Android中应用\n\n**ListView、RxJava**\n\n### 责任链模式\n\n1、概念\n\n是一个请求有多个对象来处理，这些对象是一条链，但具体由哪个对象来处理，根据条件判断来确定，如果不能处理会传递给该链中的下一个对象，直到有对象处理它为止\n\n2、使用场景\n\n*   有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定\n*   在不明确指定接收者的情况下，向多个对象中的一个提交一个请求\n*   可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求\n\n3、在Android中应用\n\n**try-catch语句、有序广播、事件分发机制**"]],[437,3213],[437,437]]],[1520512800968,["gengmei_pxf@gengmei123.local",[[1,437," [## Android中的设计模式](https://pxfile.github.io/2018/03/08/Android%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/)"]],[437,437],[556,556]]],[1520512803445,["gengmei_pxf@gengmei123.local",[[-1,439,"## "]],[439,442],[439,439]]]]],["28b2f73c-fe42-47f9-8440-18171655c633",1520567193378,"简历中的questions\n==\n*   **基础知识 – 四大组件（生命周期，使用场景，如何启动）**\n*   **java基础 – 数据结构，线程，mvc框架**\n*   **通信 – 网络连接（HttpClient，HttpUrlConnetion），Socket**\n*   **数据持久化 – SQLite，SharedPreferences，ContentProvider**\n*   **性能优化 – 布局优化，内存优化，电量优化**\n*   **安全 – 数据加密，代码混淆，WebView/Js调用，https**\n*   **UI– 动画**\n*   **其他 – JNI，AIDL，Handler，Intent等**\n*   **开源框架 – Volley，Gilde，RxJava等（简历上写你会的，用过的）**\n*   **拓展 – Android6.0/7.0/8.0特性，kotlin语言，I/O大会**\n\n## Android中的设计模式\n\n [Android中的设计模式](https://pxfile.github.io/2018/03/08/Android%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/)\n\n##  Android各组件和机制\n\n### [Activity](https://pxfile.github.io/2018/03/08/%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3Activity/)\n\n###  [Service](https://pxfile.github.io/2018/03/08/Service%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93/)\n\n###  [ContentProvider](https://pxfile.github.io/2018/03/08/ContentProvider%E5%AE%9E%E4%BE%8B%E8%AF%A6%E8%A7%A3/)\n\n###  [BroadcastReceiver](https://pxfile.github.io/2018/03/08/BroadcastReceiver%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/)\n\n##  模块化和组件化开发\n[模块化和组件化开发](https://pxfile.github.io/2018/03/02/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/)\n\n##  Android开发模式(MVC，MVVM，MVP)\n[浅谈MVC、MVP、MVVM架构模式的区别和联系](http://www.cnblogs.com/guwei4037/p/5591183.html)\n\n## 事件分发机制\n[事件分发机制](https://www.jianshu.com/p/38015afcdb58)\n\n## Handler机制\n[Handler机制](https://pxfile.github.io/2018/03/08/%E7%B2%BE%E9%80%9AAndroid%E4%B8%8B%E7%9A%84Handler%E6%9C%BA%E5%88%B6/)\n\n## 机型适配\n[机型适配](http://blog.csdn.net/mwq384807683/article/details/72594027)\n\n## 性能优化\n [性能优化](https://pxfile.github.io/2018/03/08/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/)\n\n## 内存泄漏\n [内存泄漏](https://pxfile.github.io/2018/02/14/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/)\n\n## Binder机制\n [Binder机制](https://pxfile.github.io/2018/03/07/Binder%E6%9C%BA%E5%88%B6/)\n\n## 混合开发\n\n## Android面试题\n[Android面试题](http://blog.csdn.net/angel_w/article/details/79103141)",[[1520567165100,["gengmei_pxf@gengmei123.local",[[1,555,"\n"]],[553,553],[554,554]]],[1520567165443,["gengmei_pxf@gengmei123.local",[[1,556,"\n"]],[554,554],[555,555]]],[1520567165815,["gengmei_pxf@gengmei123.local",[[1,555,"1.单例 全局性 减少对象创建，降低系统内存的消耗，减少gc次数和卡顿时间 初始化资源的工具类\n2.创建者模式 创建对象的参数很多且不定，参数个数和类型不确定， AlertDialog glide okhttp\n3.适配器模式 baseAdapter\n4.装饰模式 context\n5.外观模式 contextImple\n6.策略模式 属性动画 插值器\n7.组合模式 view和viewGroup\n8.模板方法 Activity fragment\n9.观察者模式 RxJava\n10.责任链模式 try catch，事件分发机制"]],[555,555],[819,819]]],[1520567175574,["gengmei_pxf@gengmei123.local",[[1,939,"\n"]],[937,937],[938,938]]],[1520567176157,["gengmei_pxf@gengmei123.local",[[1,940,"\n"]],[938,938],[939,939]]],[1520567176622,["gengmei_pxf@gengmei123.local",[[1,939,"Activity\n\n1.四大组件中Activity是用的最多也是最基础的，Activity提供窗口来与用户进行交互\n\n2.Android默认会为每一个App应用提供一个task的栈老存放和管理该App所有的Activity task默认的name是该App的包名 也可以在mainfest清单文件中设置Activity的taskAffinity属性来自定义task，但是不建议这样使用，如果别App也设置一样的task，它就可能启动你的Activity，带来各种安全隐患\n\n3.Activity的生命周期 onCreate -> onStart -> onResume -> onPause -> onStop -> onDestroy\n\n正常情况下生命周期的调用\n（1）A页面打开B页面或者切回到桌面 A Activity：onPause -》 onStop，如果B Activity采用了透明主题 则不会调用 onStop\n\n（2）先调用A的onPause再调用B的onResume方法\n\n（3）再回到A页面时，onRestart -》 onStart -》onResume\n\n（4）按返回键时，onPause -》 onStop -》onDestroy\n\n异常情况下在生命周期的调用\n\n（1）资源相关的系统配置发生改变时，Activity被杀死 例如Activity竖屏，突然旋转屏幕，Activity默认会销毁并重新创建\n\nonSaveInstanceState -》 onDestroy   重新创建  onCreate 。。。-》 onDestroy\n\n（2）系统资源不足导致优先级低的Activity被回收\n\nonSaveInstanceState -》 onDestroy   重新创建  onCreate 。。。-》 onDestroy\n\n4.Activity信息保存和恢复\n\n系统会调用onSaveInstanceState来保存当前Activity的状态，这个方法调用的时机是在onStop之前，他和onPause没有既定的时序关系，他即可能在onPause之前调用，也有可能在之后调用，需要强调的是，这个方法只出现在Activity被异常终止的情况下，正常情况下是不会走这个方法的，当我们onSaveInstanceState保存到Bundler对象作为参数传递给onRestoreInstanceState和onCreate方法，因此我们可以通过onRestoreInstanceState和onCreate方法来判断Activity是否被重建。如果被重建了，我们就取出之前的数据恢复，从时序上来说，onRestoreInstanceState的调用时机应该在onStart之后\n\n5.启动模式\n\n（1）定义启动模式的方法\n\nmanifest中声明 \n\n<activity\n            ．．．．．．\n            android:launchMode=\"standard\"\n             >\n           ．．．．．．．\n        </activity>\n\n 使用Intent标志\n\nIntent i = new Intent(this,ＮewActivity.class);\n\t\ti.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\t\tstartActivity(i);\n\n（2）模式类型\n\nstandard 默认模式\nsingleTop 当目标Activity位于task栈的栈顶时，直接复用，不会创建新的Activity，否则泽创建新的Activity并添加到task栈中\nsingleTask 如果目标Activity位于Task栈顶中，则复用，如果没有位于栈顶就将目标Activity之前的Activity移除栈，然后调用，否则就创建新的Activity并添加到栈中\nsingleInstance 如果目标Activity不存在，创建一个新的task栈添加目标Activity并调用，如果Activity已存在就将Activity所在的task移到前台并调用"]],[939,939],[2677,2677]]],[1520567194412,["gengmei_pxf@gengmei123.local",[[1,2390,"**"]],[2390,2390],[2392,2392]]],[1520567199075,["gengmei_pxf@gengmei123.local",[[1,2400,"**"]],[2400,2400],[2402,2402]]],[1520567199812,["gengmei_pxf@gengmei123.local",[[1,2417,"**"]],[2417,2417],[2419,2419]]],[1520567200853,["gengmei_pxf@gengmei123.local",[[1,2408,"**"]],[2408,2408],[2410,2410]]],[1520567201906,["gengmei_pxf@gengmei123.local",[[1,2491,"**"]],[2491,2491],[2493,2493]]],[1520567203428,["gengmei_pxf@gengmei123.local",[[1,2503,"**"]],[2503,2503],[2505,2505]]],[1520567204779,["gengmei_pxf@gengmei123.local",[[1,2594,"**"]],[2594,2594],[2596,2596]]],[1520567206142,["gengmei_pxf@gengmei123.local",[[1,2610,"**"]],[2610,2610],[2612,2612]]],[1520567228451,["gengmei_pxf@gengmei123.local",[[1,949,"#### "]],[949,949],[954,954]]],[1520567233749,["gengmei_pxf@gengmei123.local",[[1,1003,"#### "]],[1003,1003],[1008,1008]]],[1520567239773,["gengmei_pxf@gengmei123.local",[[1,1186,"#### "]],[1186,1186],[1191,1191]]],[1520567244516,["gengmei_pxf@gengmei123.local",[[1,1733,"#### "]],[1733,1733],[1738,1738]]],[1520567247371,["gengmei_pxf@gengmei123.local",[[1,2113,"#### "]],[2113,2113],[2118,2118]]]]],["d0cc2b44-733f-4270-8275-1965e9b1217d",1520579745593,"简历中的questions\n==\n*   **基础知识 – 四大组件（生命周期，使用场景，如何启动）**\n*   **java基础 – 数据结构，线程，mvc框架**\n*   **通信 – 网络连接（HttpClient，HttpUrlConnetion），Socket**\n*   **数据持久化 – SQLite，SharedPreferences，ContentProvider**\n*   **性能优化 – 布局优化，内存优化，电量优化**\n*   **安全 – 数据加密，代码混淆，WebView/Js调用，https**\n*   **UI– 动画**\n*   **其他 – JNI，AIDL，Handler，Intent等**\n*   **开源框架 – Volley，Gilde，RxJava等（简历上写你会的，用过的）**\n*   **拓展 – Android6.0/7.0/8.0特性，kotlin语言，I/O大会**\n\n## Android中的设计模式\n\n [Android中的设计模式](https://pxfile.github.io/2018/03/08/Android%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/)\n\n1.单例 全局性 减少对象创建，降低系统内存的消耗，减少gc次数和卡顿时间 初始化资源的工具类\n2.创建者模式 创建对象的参数很多且不定，参数个数和类型不确定， AlertDialog glide okhttp\n3.适配器模式 baseAdapter\n4.装饰模式 context\n5.外观模式 contextImple\n6.策略模式 属性动画 插值器\n7.组合模式 view和viewGroup\n8.模板方法 Activity fragment\n9.观察者模式 RxJava\n10.责任链模式 try catch，事件分发机制\n\n##  Android各组件和机制\n\n### [Activity](https://pxfile.github.io/2018/03/08/%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3Activity/)\n\nActivity\n\n#### 1.四大组件中Activity是用的最多也是最基础的，Activity提供窗口来与用户进行交互\n\n#### 2.Android默认会为每一个App应用提供一个task的栈老存放和管理该App所有的Activity task默认的name是该App的包名 也可以在mainfest清单文件中设置Activity的taskAffinity属性来自定义task，但是不建议这样使用，如果别App也设置一样的task，它就可能启动你的Activity，带来各种安全隐患\n\n#### 3.Activity的生命周期 onCreate -> onStart -> onResume -> onPause -> onStop -> onDestroy\n\n正常情况下生命周期的调用\n（1）A页面打开B页面或者切回到桌面 A Activity：onPause -》 onStop，如果B Activity采用了透明主题 则不会调用 onStop\n\n（2）先调用A的onPause再调用B的onResume方法\n\n（3）再回到A页面时，onRestart -》 onStart -》onResume\n\n（4）按返回键时，onPause -》 onStop -》onDestroy\n\n异常情况下在生命周期的调用\n\n（1）资源相关的系统配置发生改变时，Activity被杀死 例如Activity竖屏，突然旋转屏幕，Activity默认会销毁并重新创建\n\nonSaveInstanceState -》 onDestroy   重新创建  onCreate 。。。-》 onDestroy\n\n（2）系统资源不足导致优先级低的Activity被回收\n\nonSaveInstanceState -》 onDestroy   重新创建  onCreate 。。。-》 onDestroy\n\n#### 4.Activity信息保存和恢复\n\n系统会调用onSaveInstanceState来保存当前Activity的状态，这个方法调用的时机是在onStop之前，他和onPause没有既定的时序关系，他即可能在onPause之前调用，也有可能在之后调用，需要强调的是，这个方法只出现在Activity被异常终止的情况下，正常情况下是不会走这个方法的，当我们onSaveInstanceState保存到Bundler对象作为参数传递给onRestoreInstanceState和onCreate方法，因此我们可以通过onRestoreInstanceState和onCreate方法来判断Activity是否被重建。如果被重建了，我们就取出之前的数据恢复，从时序上来说，onRestoreInstanceState的调用时机应该在onStart之后\n\n#### 5.启动模式\n\n（1）定义启动模式的方法\n\nmanifest中声明 \n\n<activity\n            ．．．．．．\n            android:launchMode=\"standard\"\n             >\n           ．．．．．．．\n        </activity>\n\n 使用Intent标志\n\nIntent i = new Intent(this,ＮewActivity.class);\n\t\ti.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\t\tstartActivity(i);\n\n（2）模式类型\n\n**standard** 默认模式\n**singleTop** 当目标Activity位于task栈的栈顶时，直接复用，不会创建新的Activity，否则泽创建新的Activity并添加到task栈中\n**singleTask** 如果目标Activity位于Task栈顶中，则复用，如果没有位于栈顶就将目标Activity之前的Activity移除栈，然后调用，否则就创建新的Activity并添加到栈中\n**singleInstance** 如果目标Activity不存在，创建一个新的task栈添加目标Activity并调用，如果Activity已存在就将Activity所在的task移到前台并调用\n\n###  [Service](https://pxfile.github.io/2018/03/08/Service%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93/)\n\n###  [ContentProvider](https://pxfile.github.io/2018/03/08/ContentProvider%E5%AE%9E%E4%BE%8B%E8%AF%A6%E8%A7%A3/)\n\n###  [BroadcastReceiver](https://pxfile.github.io/2018/03/08/BroadcastReceiver%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/)\n\n##  模块化和组件化开发\n[模块化和组件化开发](https://pxfile.github.io/2018/03/02/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/)\n\n##  Android开发模式(MVC，MVVM，MVP)\n[浅谈MVC、MVP、MVVM架构模式的区别和联系](http://www.cnblogs.com/guwei4037/p/5591183.html)\n\n## 事件分发机制\n[事件分发机制](https://www.jianshu.com/p/38015afcdb58)\n\n## Handler机制\n[Handler机制](https://pxfile.github.io/2018/03/08/%E7%B2%BE%E9%80%9AAndroid%E4%B8%8B%E7%9A%84Handler%E6%9C%BA%E5%88%B6/)\n\n## 机型适配\n[机型适配](http://blog.csdn.net/mwq384807683/article/details/72594027)\n\n## 性能优化\n [性能优化](https://pxfile.github.io/2018/03/08/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/)\n\n## 内存泄漏\n [内存泄漏](https://pxfile.github.io/2018/02/14/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/)\n\n## Binder机制\n [Binder机制](https://pxfile.github.io/2018/03/07/Binder%E6%9C%BA%E5%88%B6/)\n\n## 混合开发\n\n## Android面试题\n[Android面试题](http://blog.csdn.net/angel_w/article/details/79103141)",[[1520579720500,["gengmei_pxf@gengmei123.local",[[1,2720,"\n"]],[2718,2718],[2719,2719]]],[1520579720835,["gengmei_pxf@gengmei123.local",[[1,2721,"\n"]],[2719,2719],[2720,2720]]],[1520579728787,["gengmei_pxf@gengmei123.local",[[-1,2721,"\n"]],[2720,2720],[2719,2719]]],[1520579729194,["gengmei_pxf@gengmei123.local",[[-1,2720,"\n"]],[2719,2719],[2718,2718]]],[1520579731251,["gengmei_pxf@gengmei123.local",[[1,2818,"\n"]],[2816,2816],[2817,2817]]],[1520579731395,["gengmei_pxf@gengmei123.local",[[1,2819,"\n"]],[2817,2817],[2818,2818]]],[1520579732031,["gengmei_pxf@gengmei123.local",[[1,2818,"二 Service\n\nService 应用程序组件 能够在后台执行耗时较长的操作，并且不提供界面\n\nService分类\n\n按运行分类\n\n前台Service \n\nstartForeground 开启前台服务 \n\nstopForeground  移除前台服务\n\n后台Service\n\n按使用分类\n\n本地服务 运用于应用程序内部实现一些耗时操作，并不占用Activity的线程，而是新开一个线程在后台执行 \n\nContext.startService 启动\n\nContext.stopService 结束\n\n在内部可以调用Service.stopSelf() 或 Service.stopSelfResult()来自己停止。\n\n远程服务 用于应用程序之间，可被其他应用程序复用 例如天气预报，其他应用程序不需要在写这样的服务，调用即可\n\n通过暴露接口供其他应用程序调用\n\nContex.bindService 连接\n\nContext.unbinService 断开连接\n\nService生命周期\n\nonCreate -》 onStartCommand -》 onDestroy\n\nonCreate -》 onBind =》onUnBind -》onDestroy\n\nonStartCommand()方法必须返回一个整数。\n\nSTART_NOT_STICKY 杀死了服务，则不会重建服务\n\nSTART_STICKY  杀死了服务，则将重建服务并调用onStartCommand()，但不会再次送入上一个intent  这适用于媒体播放器（或类似服务），它们不执行命令，但需要一直运行并随时待命\n\nSTART_REDELIVER_INTENT 杀死了服务，则将重建服务并用上一个已送过的intent调用onStartCommand() 适用于那些需要立即恢复工作的活跃服务，比如下载文件\n\nstart服务\n\nbind服务\n\n在mainfest中声明服务"]],[2818,2818],[3639,3639]]],[1520579738446,["gengmei_pxf@gengmei123.local",[[1,2868,"## "]],[2868,2868],[2871,2871]]],[1520579745542,["gengmei_pxf@gengmei123.local",[[1,2870,"##"]],[2870,2870],[2872,2872]]],[1520579760603,["gengmei_pxf@gengmei123.local",[[-1,2818,"二 Service\n\n"]],[2819,2819],[2818,2818]]],[1520579780292,["gengmei_pxf@gengmei123.local",[[1,2873,"##### "]],[2873,2873],[2879,2879]]],[1520579784020,["gengmei_pxf@gengmei123.local",[[1,2886,"* "]],[2886,2886],[2888,2888]]],[1520579786220,["gengmei_pxf@gengmei123.local",[[1,2949,"* "]],[2949,2949],[2951,2951]]],[1520579788070,["gengmei_pxf@gengmei123.local",[[1,2962,"￥"]],[2962,2962],[2963,2963]]],[1520579788787,["gengmei_pxf@gengmei123.local",[[-1,2962,"￥"]],[2963,2963],[2962,2962]]],[1520579791308,["gengmei_pxf@gengmei123.local",[[1,2962,"##### "]],[2962,2962],[2968,2968]]],[1520579795724,["gengmei_pxf@gengmei123.local",[[1,2975,"* "]],[2975,2975],[2977,2977]]],[1520579802195,["gengmei_pxf@gengmei123.local",[[1,3141,"* "]],[3141,3141],[3143,3143]]],[1520579808737,["gengmei_pxf@gengmei123.local",[[1,2981,"\n"]],[2981,2981],[2982,2982]]],[1520579809281,["gengmei_pxf@gengmei123.local",[[1,2982,"\n"]],[2982,2982],[2983,2983]]],[1520579810471,["gengmei_pxf@gengmei123.local",[[-1,2983," "]],[2984,2984],[2983,2983]]],[1520579813536,["gengmei_pxf@gengmei123.local",[[1,3149,"\n"]],[3149,3149],[3150,3150]]],[1520579814168,["gengmei_pxf@gengmei123.local",[[1,3150,"\n"]],[3150,3150],[3151,3151]]],[1520579828522,["gengmei_pxf@gengmei123.local",[[1,3268,"#### "]],[3268,3268],[3273,3273]]],[1520579840778,["gengmei_pxf@gengmei123.local",[[1,3286,"* "]],[3286,3294],[3288,3288]]],[1520579842634,["gengmei_pxf@gengmei123.local",[[1,3329,"* "]],[3329,3329],[3331,3331]]],[1520579847674,["gengmei_pxf@gengmei123.local",[[1,3374,"* "]],[3374,3374],[3376,3376]]],[1520579849524,["gengmei_pxf@gengmei123.local",[[-1,3374,"* "]],[3376,3376],[3374,3374]]],[1520579852378,["gengmei_pxf@gengmei123.local",[[1,3374,"#### "]],[3374,3374],[3379,3379]]],[1520579855988,["gengmei_pxf@gengmei123.local",[[1,3408,"* "]],[3408,3408],[3410,3410]]],[1520579858042,["gengmei_pxf@gengmei123.local",[[1,3442,"* "]],[3442,3442],[3444,3444]]],[1520579859962,["gengmei_pxf@gengmei123.local",[[1,3547,"* "]],[3547,3547],[3549,3549]]],[1520579873066,["gengmei_pxf@gengmei123.local",[[1,3645,"#### "]],[3645,3645],[3650,3650]]],[1520579874482,["gengmei_pxf@gengmei123.local",[[1,3659,"#### "]],[3659,3659],[3664,3664]]],[1520579876345,["gengmei_pxf@gengmei123.local",[[1,3672,"#### "]],[3672,3672],[3677,3677]]],[1520579880505,["gengmei_pxf@gengmei123.local",[[1,3218,"#### "]],[3218,3218],[3223,3223]]],[1520579882593,["gengmei_pxf@gengmei123.local",[[1,3246,"#### "]],[3246,3246],[3251,3251]]],[1520579921719,["gengmei_pxf@gengmei123.local",[[1,3703,"\n"]],[3701,3701],[3702,3702]]],[1520579921996,["gengmei_pxf@gengmei123.local",[[1,3704,"\n"]],[3702,3702],[3703,3703]]],[1520579922432,["gengmei_pxf@gengmei123.local",[[1,3703,"``` \n<manifest ... >\n\t... \n\t<application ... >\n\t <service android:name=\".ExampleService\" /> \n\t... \n\t</application> \n</manifest>\n```"]],[3703,3703],[3834,3834]]],[1520579991276,["gengmei_pxf@gengmei123.local",[[1,4068,"\n"]],[4066,4066],[4067,4067]]],[1520579991867,["gengmei_pxf@gengmei123.local",[[1,4069,"\n"]],[4067,4067],[4068,4068]]],[1520580831292,["gengmei_pxf@gengmei123.local",[[1,4068,"广播是一种广泛运用的在应用程序之间传输信息的机制，主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。\n\n　　在实现开机启动服务和网络状态改变、电量变化、短信和来电时通过接收系统的广播让应用程序作出相应的处理。\n\n　　BroadcastReceiver 自身并不实现图形用户界面，但是当它收到某个通知后， BroadcastReceiver 可以通过启动 Service 、启动 Activity 或是 NotificationMananger 提醒用户。"]],[4068,4068],[4325,4325]]],[1520580858150,["gengmei_pxf@gengmei123.local",[[1,4327,"\n"]],[4325,4325],[4326,4326]]],[1520580858533,["gengmei_pxf@gengmei123.local",[[1,4328,"\n"]],[4326,4326],[4327,4327]]],[1520580866944,["gengmei_pxf@gengmei123.local",[[1,4327,"静态注册"]],[4327,4327],[4331,4331]]],[1520580867293,["gengmei_pxf@gengmei123.local",[[1,4333,"\n"]],[4331,4331],[4332,4332]]],[1520580867501,["gengmei_pxf@gengmei123.local",[[1,4334,"\n"]],[4332,4332],[4333,4333]]],[1520580873623,["gengmei_pxf@gengmei123.local",[[1,4333,"动态注册"]],[4333,4333],[4337,4337]]],[1520580874149,["gengmei_pxf@gengmei123.local",[[1,4339,"\n"]],[4337,4337],[4338,4338]]],[1520580888565,["gengmei_pxf@gengmei123.local",[[1,4333,"\n"]],[4331,4331],[4332,4332]]],[1520580888756,["gengmei_pxf@gengmei123.local",[[1,4334,"\n"]],[4332,4332],[4333,4333]]],[1520580889216,["gengmei_pxf@gengmei123.local",[[1,4333,"在AndroidManifest.xml的application里面定义receiver并设置要接收的action。\n\n``` < receiver android:name = \".MyBroadcastReceiver\" > \n < intent-filter android:priority = \"777\" > <action android:name = \"android.provider.Telephony.SMS_RECEIVED\" /> </ intent-filter >  </ receiver > ```"]],[4333,4333],[4598,4598]]],[1520580893019,["gengmei_pxf@gengmei123.local",[[1,4595,"\n"]],[4595,4595],[4596,4596]]],[1520580895204,["gengmei_pxf@gengmei123.local",[[1,4397,"\n"]],[4397,4397],[4398,4398]]],[1520580913284,["gengmei_pxf@gengmei123.local",[[-1,4601,"\n"]],[4601,4601],[4600,4600]]],[1520580914976,["gengmei_pxf@gengmei123.local",[[1,4606,"在Activity中声明BroadcastReceiver的扩展对象，在onResume中注册，onPause中卸载.\n\n``` public class MainActivity extends Activity {\n MyBroadcastReceiver receiver; @Override protected void onResume() { // 动态注册广播 (代码执行到这才会开始监听广播消息，并对广播消息作为相应的处理) receiver = new MyBroadcastReceiver(); IntentFilter intentFilter = new IntentFilter( \"android.provider.Telephony.SMS_RECEIVED\" ); registerReceiver( receiver , intentFilter);       super.onResume();\n } @Override protected void onPause() {      // 撤销注册 (撤销注册后广播接收者将不会再监听系统的广播消息)\n unregisterReceiver(receiver); super.onPause(); } } ```"]],[4606,4606],[5159,5159]]],[1520580918523,["gengmei_pxf@gengmei123.local",[[1,4671,"\n"]],[4671,4671],[4672,4672]]],[1520580921089,["gengmei_pxf@gengmei123.local",[[1,5156,"\n"]],[5156,5156],[5157,5157]]],[1520580927539,["gengmei_pxf@gengmei123.local",[[-1,4667,"``` \npublic class MainActivity extends Activity {\n MyBroadcastReceiver receiver; @Override protected void onResume() { // 动态注册广播 (代码执行到这才会开始监听广播消息，并对广播消息作为相应的处理) receiver = new MyBroadcastReceiver(); IntentFilter intentFilter = new IntentFilter( \"android.provider.Telephony.SMS_RECEIVED\" ); registerReceiver( receiver , intentFilter);       super.onResume();\n } @Override protected void onPause() {      // 撤销注册 (撤销注册后广播接收者将不会再监听系统的广播消息)\n unregisterReceiver(receiver); super.onPause(); } }\n ```\n"]],[4666,5161],[4666,4666]]],[1520580929179,["gengmei_pxf@gengmei123.local",[[1,4668,"\n"]],[4666,4666],[4667,4667]]],[1520580949294,["gengmei_pxf@gengmei123.local",[[1,4667,"静态注册和动态注册的区别   　　1、静态注册的广播接收者一经安装就常驻在系统之中，不需要重新启动唤醒接收者；\n　　动态注册的广播接收者随着应用的生命周期，由registerReceiver开始监听，由unregisterReceiver撤销监听，如果应用退出后，没有撤销已经注册的接收者应用应用将会报错。\n\n　　2、当广播接收者通过intent启动一个activity或者service时，如果intent中无法匹配到相应的组件。　\n　　动态注册的广播接收者将会导致应用报错\n　　而静态注册的广播接收者将不会有任何报错，因为自从应用安装完成后，广播接收者跟应用已经脱离了关系。"]],[4667,4667],[4956,4956]]],[1520580952890,["gengmei_pxf@gengmei123.local",[[1,4680,"\n"]],[4680,4680],[4681,4681]]],[1520580963636,["gengmei_pxf@gengmei123.local",[[1,4667,"#### "]],[4667,4667],[4672,4672]]],[1520580968897,["gengmei_pxf@gengmei123.local",[[1,4964,"\n"]],[4962,4962],[4963,4963]]],[1520580969153,["gengmei_pxf@gengmei123.local",[[1,4965,"\n"]],[4963,4963],[4964,4964]]],[1520580991765,["gengmei_pxf@gengmei123.local",[[1,4964,"- 静态广播接收的处理器是由PackageManagerService负责，当手机启动或者新安装了应用的时候，PackageManagerService会扫描手机中所有已安装的APP应用，将AndroidManifest.xml中有关注册广播的信息解析出来，存储至一个全局静态变量当中。\n\n - 动态广播接收的处理器是由ActivityManagerService负责，当APP的服务或者进程起来之后，执行了注册广播接收的代码逻辑，即进行加载，最后会存储在一个另外的全局静态变量中。需要注意的是：\n\n　　 1、 这个并非是一成不变的，当程序被杀死之后，已注册的动态广播接收器也会被移出全局变量，直到下次程序启动，再进行动态广播的注册，当然这里面的顺序也已经变更了一次。\n\n　　 2、这里也并没完整的进行广播的排序，只记录的注册的先后顺序，并未有结合优先级的处理。\n\n - 广播发出的时候，广播接收者接收的顺序如下：\n\n　　１．当广播为**普通广播**时，有如下的接收顺序：\n\n　　无视优先级\n　　动态优先于静态\n　　同优先级的动态广播接收器，**先注册的大于后注册的** 　　同优先级的静态广播接收器，**先扫描的大于后扫描的**　\n\n　　２．如果广播为**有序广播**，那么会将动态广播处理器和静态广播处理器合并在一起处理广播的消息，最终确定广播接收的顺序：　\n\n　　优先级高的先接收　\n　　同优先级的动静态广播接收器，**动态优先于静态** 　　同优先级的动态广播接收器，**先注册的大于后注册的** 　　同优先级的静态广播接收器，**先扫描的大于后扫描的**"]],[4964,4964],[5646,5646]]],[1520581020712,["gengmei_pxf@gengmei123.local",[[1,4964,"\n"]],[4963,4963],[4964,4964]]],[1520581022379,["gengmei_pxf@gengmei123.local",[[1,4964,"总结"]],[4964,4964],[4966,4966]]],[1520581025978,["gengmei_pxf@gengmei123.local",[[1,4964,"#### "]],[4964,4964],[4969,4969]]],[1520581028479,["gengmei_pxf@gengmei123.local",[[1,4972,"\n"]],[4971,4971],[4972,4972]]],[1520581031647,["gengmei_pxf@gengmei123.local",[[1,4684,"\n"]],[4684,4684],[4685,4685]]],[1520581043479,["gengmei_pxf@gengmei123.local",[[1,5658,"\n"]],[5656,5656],[5657,5657]]],[1520581043639,["gengmei_pxf@gengmei123.local",[[1,5659,"\n"]],[5657,5657],[5658,5658]]],[1520581052579,["gengmei_pxf@gengmei123.local",[[1,5658,"**广播怎么不跨进程**   无论是使用扩展变量作用域、基于接口的回调还是Handler-post/Handler-Message等方式，都可以直接处理此类问题，若适用广播机制，显然有些“杀鸡牛刀”的感觉，会显太“重”；"]],[5658,5658],[5768,5768]]],[1520581056630,["gengmei_pxf@gengmei123.local",[[1,5670,"\n"]],[5670,5670],[5671,5671]]],[1520581058791,["gengmei_pxf@gengmei123.local",[[-1,5671,"   "],[1,5674,"\n"]],[5671,5674],[5672,5672]]],[1520581062465,["gengmei_pxf@gengmei123.local",[[1,5658,"#### "]],[5658,5658],[5663,5663]]],[1520581100726,["gengmei_pxf@gengmei123.local",[[1,3950,"\n"]],[3948,3948],[3949,3949]]],[1520581100885,["gengmei_pxf@gengmei123.local",[[1,3951,"\n"]],[3949,3949],[3950,3950]]],[1520581101233,["gengmei_pxf@gengmei123.local",[[1,3950,"ContentProvider（内容提供者）是Android的四大组件之一，管理android以结构化方式存放的数据，以相对安全的方式封装数据（表）并且提供简易的处理机制和统一的访问接口供**其他程序**调用。　\n\n　　Android的数据存储方式总共有五种，分别是：Shared Preferences、网络存储、文件存储、外储存储、SQLite。但一般这些存储都只是在单独的一个应用程序之中达到一个数据的共享，有时候我们需要操作其他应用程序的一些数据，就会用到ContentProvider。而且Android为常见的一些数据提供了默认的ContentProvider（包括音频、视频、图片和通讯录等）。\n\n　　但注意ContentProvider它也只是一个中间人，真正操作的数据源可能是数据库，也可以是文件、xml或网络等其他存储方式。"]],[3950,3950],[4322,4322]]],[1520581464617,["gengmei_pxf@gengmei123.local",[[1,6295,"\n"]],[6293,6293],[6294,6294]]],[1520581464897,["gengmei_pxf@gengmei123.local",[[1,6296,"\n"]],[6294,6294],[6295,6295]]],[1520581467435,["gengmei_pxf@gengmei123.local",[[1,6295,"模块化"]],[6295,6295],[6298,6298]]],[1520581471227,["gengmei_pxf@gengmei123.local",[[1,6295,"### "]],[6295,6295],[6299,6299]]],[1520581472712,["gengmei_pxf@gengmei123.local",[[1,6304,"\n"]],[6302,6302],[6303,6303]]],[1520581483387,["gengmei_pxf@gengmei123.local",[[1,6303,"按照功能划分成相互"]],[6303,6303],[6312,6312]]],[1520581507906,["gengmei_pxf@gengmei123.local",[[1,6312,"独立的模块，使其只包含模块"]],[6312,6312],[6325,6325]]],[1520581522279,["gengmei_pxf@gengmei123.local",[[-1,6323,"模块"]],[6323,6328],[6323,6323]]],[1520581530064,["gengmei_pxf@gengmei123.local",[[1,6323,"与其先关"]],[6323,6323],[6327,6327]]],[1520581531046,["gengmei_pxf@gengmei123.local",[[-1,6325,"先关"]],[6327,6327],[6325,6325]]],[1520581536385,["gengmei_pxf@gengmei123.local",[[1,6325,"相关的功能"]],[6325,6325],[6330,6330]]],[1520581559161,["gengmei_pxf@gengmei123.local",[[1,6330,"。登录，搜索，交易，社区等"]],[6330,6330],[6343,6343]]],[1520581559805,["gengmei_pxf@gengmei123.local",[[1,6345,"\n"]],[6343,6343],[6344,6344]]],[1520581567951,["gengmei_pxf@gengmei123.local",[[1,6344,"### 组件化"]],[6344,6344],[6351,6351]]],[1520581568637,["gengmei_pxf@gengmei123.local",[[1,6353,"\n"]],[6351,6351],[6352,6352]]],[1520581599527,["gengmei_pxf@gengmei123.local",[[1,6352,"基于"]],[6352,6352],[6354,6354]]],[1520581638862,["gengmei_pxf@gengmei123.local",[[1,6354,"可重用的目的，将工程拆分成"]],[6354,6354],[6367,6367]]],[1520581663022,["gengmei_pxf@gengmei123.local",[[-1,6362,"工程"],[1,6364,"y"]],[6362,6364],[6362,6363]]],[1520581663157,["gengmei_pxf@gengmei123.local",[[1,6363,"i"]],[6362,6363],[6362,6364]]],[1520581663410,["gengmei_pxf@gengmei123.local",[[1,6364,"'g"]],[6362,6364],[6362,6366]]],[1520581663547,["gengmei_pxf@gengmei123.local",[[1,6366,"e"]],[6362,6366],[6362,6367]]],[1520581663941,["gengmei_pxf@gengmei123.local",[[-1,6362,"yi'ge"],[1,6367,"一个"]],[6362,6367],[6364,6364]]],[1520581666740,["gengmei_pxf@gengmei123.local",[[1,6364,"系统"]],[6364,6364],[6366,6366]]],[1520581669866,["gengmei_pxf@gengmei123.local",[[-1,6364,"系统"]],[6366,6366],[6364,6364]]],[1520581688196,["gengmei_pxf@gengmei123.local",[[1,6364,"系统按照拆分关注点的形式，"]],[6364,6364],[6377,6377]]],[1520581709116,["gengmei_pxf@gengmei123.local",[[1,6380,"一个的组件，实现业务解耦"]],[6380,6380],[6392,6392]]],[1520581724214,["gengmei_pxf@gengmei123.local",[[-1,6386,"实现业务"]],[6386,6390],[6386,6386]]],[1520581726915,["gengmei_pxf@gengmei123.local",[[1,6386,"减少"]],[6386,6386],[6388,6388]]],[1520581729071,["gengmei_pxf@gengmei123.local",[[1,6392,"\n"]],[6390,6390],[6391,6391]]],[1520581729423,["gengmei_pxf@gengmei123.local",[[1,6393,"\n"]],[6391,6391],[6392,6392]]],[1520581773298,["gengmei_pxf@gengmei123.local",[[1,6392,"# 模块化vs组件化[](https://pxfile.github.io/2018/03/02/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/#%E6%A8%A1%E5%9D%97%E5%8C%96vs%E7%BB%84%E4%BB%B6%E5%8C%96)\n\n模块化和组件化本质思想是一样的,都是”大化小”,两者的目的都是为了重用和解耦,只是叫法不一样.如果非要说区别,那么可以认为模块化粒度更小,更侧重于重用,而组件化粒度稍大于模块,更侧重于业务解耦。"]],[6392,6392],[6680,6680]]],[1520581775961,["gengmei_pxf@gengmei123.local",[[1,6393,"##"]],[6393,6393],[6395,6395]]],[1520581782150,["gengmei_pxf@gengmei123.local",[[-1,6404,"[](https://pxfile.github.io/2018/03/02/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/#%E6%A8%A1%E5%9D%97%E5%8C%96vs%E7%BB%84%E4%BB%B6%E5%8C%96)"]],[6406,6583],[6404,6404]]],[1520581785797,["gengmei_pxf@gengmei123.local",[[1,6505,"\n"]],[6503,6503],[6504,6504]]],[1520581786133,["gengmei_pxf@gengmei123.local",[[1,6506,"\n"]],[6504,6504],[6505,6505]]],[1520581816441,["gengmei_pxf@gengmei123.local",[[1,6505,"### ## 优点[](https://pxfile.github.io/2018/03/02/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/#%E4%BC%98%E7%82%B9)\n\n*   **1.模块间解耦，复用，避免重复造轮子，节省开发维护成本** 对业务进行模块化拆分后，为了使各业务模块间解耦，因此各个都是独立的模块，它们之间是没有依赖关系。每个模块负责的功能不同，业务逻辑不同，模块间业务解耦。模块功能比较单一，可在多个项目中使用\n\n*   **2.可单独编译某个模块，降低项目复杂性，提升开发效率** 每个模块实际上也是一个完整的项目，可以进行单独编译，调试\n\n*   **3.可以多团队并行开发，测试 多个团队公用同一个组件，在一定层度上确保了技术方案的统一性** 每个团队负责不同的模块，提升开发，测试效率"]],[6505,6505],[6927,6927]]],[1520581820415,["gengmei_pxf@gengmei123.local",[[-1,6509,"## "],[-1,6692," "],[1,6693," "],[-1,6822," "],[1,6823," "],[-1,6905," "],[1,6906," "]],[6509,6512],[6509,6509]]],[1520581823364,["gengmei_pxf@gengmei123.local",[[-1,6511,"[](https://pxfile.github.io/2018/03/02/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/#%E4%BC%98%E7%82%B9)"]],[6511,6652],[6511,6511]]],[1520586367207,["gengmei_pxf@gengmei123.local",[[1,6892,"\n"]],[6890,6890],[6891,6891]]],[1520586367575,["gengmei_pxf@gengmei123.local",[[1,6893,"\n"]],[6891,6891],[6892,6892]]],[1520586368132,["gengmei_pxf@gengmei123.local",[[1,6892,"### MVC \nView  xml\nController Activity\nModel 建立的数据机构和相关的类\n\n1.View传达指令到Controller\n2.Controller完成业务逻辑后，要求Model改变状态\n3.Model将新的数据发送给View，更新视图，用户得到反馈 \n\nMVC可分为2种 \n\n1.通过View接受指令\n2.通过Controller接受指令\n\n缺点\n\n在Android开发中，Activity并不是一个标准的MVC模式中的Controller，它的首要职责是加载应用的布局和初始化用户界面 ，并接受并处理来自用户的操作请求，进而作出响应。随着界面及其逻辑的复杂度不断提升， Activity类的职责不断增加，以致变得庞大臃肿。\n\n### MVP\n在App开发过程中，经常出现的问题就是某部分的代码过 ，虽然做模块划分和接隔离，但也很难完全避免。从实践中看到，这多的出现在UI部分，也就是Activity 。想象下， 个2000+ 以上基本 带注释的Activity，我的第 反应就是想吐。Activity内容过多的原因其实很好解释，因为Activity本身需要担负 与用户之间的操作交互，界面的展示， 是单纯的Controller或View。 且现在部分的Activity还对整个App 起到类似iOS中的【ViewController】的作 ，这又带入的逻辑代码，造成Activity的臃肿。为 解决这个问题，让我们引MVP框架。\n\n将Controller改成了Presenter，同时改变了通信方向\n1.Presenter和View是可以双向通信的\n2.Presenter和Model也是可以双向通信的\n3.View和Model之间不能通信，都是通过Presenter传递的\n4.View和薄，没有任何业务逻辑，而Presenter很厚，所有的业务逻辑都在这处理\n\n\n\n### MVVM\n将Presenter改成了Viewmodel，通信方式基本和MVP差不多，最大的区别是MVVM有双向绑定，View的变动反映在ViewModel上，ViewModel的修改也会更新View"]],[6892,6892],[7801,7801]]],[1520591009804,["gengmei_pxf@gengmei123.local",[[1,7863,"\n"]],[7861,7861],[7862,7862]]],[1520591010219,["gengmei_pxf@gengmei123.local",[[1,7864,"\n"]],[7862,7862],[7863,7863]]],[1520591010701,["gengmei_pxf@gengmei123.local",[[1,7863,"![onTouchEvent](https://upload-images.jianshu.io/upload_images/944365-aea821bbb613c195.png)"]],[7863,7863],[7954,7954]]],[1520591863067,["gengmei_pxf@gengmei123.local",[[1,8089,"\n"]],[8087,8087],[8088,8088]]],[1520591863868,["gengmei_pxf@gengmei123.local",[[1,8090,"\n"]],[8088,8088],[8089,8089]]],[1520591864335,["gengmei_pxf@gengmei123.local",[[1,8089,"![](http://upload-images.jianshu.io/upload_images/1824194-a947dcc5b22f69fb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n上面一共出现了几种类，ActivityThread，Handler，MessageQueue，Looper，msg（Message）,对这些类作简要介绍：\n\nActivityThread：程序的启动入口，为什么要介绍这个类，是因为该类就是我们说的主线程，它对Looper进行操作的。\n\nHandler：字面意思是操控者，该类有比较重要的地方，就是通过handler来发送消息（sendMessage）到MessageQueue和 操作控件的更新（handleMessage）。handler下面持有这MessageQueue和Looper的对象。\n\nMessageQueue：字面意思是消息队列，就是封装Message类。对Message进行插入和取出操作。\n\nMessage：这个类是封装消息体并被发送到MessageQueue中的，给类是通过链表实现的，其好处方便MessageQueue的插入和取出操作。还有一些字段是（int what，Object obj，int arg1，int arg2）。what是用户定义的消息和代码，以便接收者（handler）知道这个是关于什么的。obj是用来传输任意对象的，arg1和arg2是用来传递一些简单的整数类型的。\n\n下面，我们按照启动顺序来进行源码分析：\n\n![](http://upload-images.jianshu.io/upload_images/1824194-298ebb16ce4a3b70.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)"]],[8089,8089],[8906,8906]]],[1520592691903,["gengmei_pxf@gengmei123.local",[[-1,8221,"上面一共出现了几种类，"],[1,8232,"*   1.在创建Activity之前，当系统启动的时候，先加载"],[-1,8246,"，Handler，MessageQueue，"],[1,8268,"这个类，在这个类中的main函数，调用了Looper.prepareMainLooper()方法进行初始化"],[-1,8274,"，msg（Message）,对这些类作简要介绍："],[1,8298,"对象；\n\n*   2.然后创建了主线程的handler对象（Tips：加载ActivityThread的时候，其内部的Handler对象[静态的]还未创建）；"],[1,8300,"*   3.随后才创建了"],[-1,8314,"：程序的启动入口，为什么要介绍这个类，是因为该类就是我们说的主线程，它"],[1,8350,"象；\n\n*   4.最后调用了"],[1,8356,".loop();方法，不断的"],[-1,8358,"操作的"],[1,8361,"轮询消息队列的消息"],[1,8364,"*   也就是说，在ActivityThread和Activity创建之前（同样也是"],[-1,8371,"：字面意思是操控者，该类有比较重要的地方，就是通过"],[1,8396,"创建之前，当然"],[-1,8403,"来发送消息（sendMessage）到"],[1,8422,"由于这两者初始化），就已经开启了Looper的loop()方法，不断的进行轮询消息。需要注意的是，这个轮询的方法是阻塞式的，没有消息就一直等待（实际是等着"],[-1,8434,"和 操作控件的更新（handleMessage）。h"],[1,8460,"的next()方法返回消息）。在应用一执行的时候，就已经开启了Looper，并初始化了H"],[-1,8466,"下面持有这MessageQueue和"],[1,8484,"对象。此时，系统的某些组件或者其他的一些活动等发送了系统级别的消息，这个时候主线程中的"],[-1,8490,"的对象。\n\nMessageQueue：字面意思是消息队列，就是封装Message类。对Message进行插入和取出操作。\n\nMessage：这个类是封装消息体并被发送到"],[1,8574,"就可以进行轮询消息，并调用msg.target.dispatch"],[-1,8581,"Queue中的，给类是通过链表实现的，其好处方便MessageQueue的插入和取出操作。还有一些字段是（int what，Object obj，int arg1，int arg2）。what是用户定义的消息和代码，以便接收者（"],[1,8695,"(msg)（msg.target即为handler）进行分发消息，并通过"],[-1,8702,"）知道这个是关于什么的。obj是用来传输任意对象的，arg1和arg2是用来传递一些简单的整数类型的"],[1,8752,"的handleMessage方法进行处理；所以会优于我们自己创建的handler中的消息而处理系统消息"]],[8221,8753],[8868,8868]]],[1520592703382,["gengmei_pxf@gengmei123.local",[[1,8588,"\n"]],[8588,8588],[8589,8589]]],[1520592703926,["gengmei_pxf@gengmei123.local",[[1,8589,"\n"]],[8589,8589],[8590,8590]]],[1520592705977,["gengmei_pxf@gengmei123.local",[[1,8590,"* "]],[8590,8590],[8592,8592]]],[1520592713254,["gengmei_pxf@gengmei123.local",[[1,8654,"\n"]],[8654,8654],[8655,8655]]],[1520592713702,["gengmei_pxf@gengmei123.local",[[1,8655,"\n"]],[8655,8655],[8656,8656]]],[1520592714792,["gengmei_pxf@gengmei123.local",[[1,8656,"* "]],[8656,8656],[8658,8658]]],[1520594066882,["gengmei_pxf@gengmei123.local",[[1,9107,"\n"]],[9105,9105],[9106,9106]]],[1520594067170,["gengmei_pxf@gengmei123.local",[[1,9108,"\n"]],[9106,9106],[9107,9107]]],[1520594067638,["gengmei_pxf@gengmei123.local",[[1,9107,"#### **魅族3和魅族4**\n\n场景：魅族手机ListView的Item中的EditText无法编辑，点击EditText弹出软键盘后，软键盘会立即自动隐藏 \n机型：[魅族3，魅族4] \n解决方案： \n方法一：将ListView换成RecyclerView\n\n方法二：[https://github.com/Aspsine/EditTextInListView](https://github.com/Aspsine/EditTextInListView)\n\n#### **HTC M8**\n\n场景：HTC M8 从一个Activity 使用QQSDK 登陆, 登陆成功后, 返回Activity结果Activity 被销毁了 \n机型：HTC M8 等某些带有 虚拟 Menu 键盘的手机 \n解决方案：后来调查发现是这个Activity是全屏,屏蔽了Menu键盘的黑条. 但是跳转到QQ却把那个Menu的黑条显示了出来, 这导致发生了 screenSize 的变化 从而导致我的Activity销毁了. \n知道了这个原因, 在manifest中的 configChanges 添加screenSize 解决了这个问题."]],[9107,9107],[9618,9618]]],[1520594071906,["gengmei_pxf@gengmei123.local",[[-1,9110,"#"],[-1,9187," "],[1,9188," "],[-1,9201," "],[1,9202," "],[-1,9208," "],[1,9209," "],[-1,9422," "],[1,9423," "],[-1,9453," "],[1,9454," "],[-1,9560," "],[1,9561," "]],[9110,9110],[9109,9109]]],[1520594079534,["gengmei_pxf@gengmei123.local",[[-1,9107,"###"],[1,9110,"*"]],[9107,9110],[9108,9108]]],[1520594083859,["gengmei_pxf@gengmei123.local",[[-1,9336,"#### "],[1,9341,"* "]],[9336,9341],[9338,9338]]],[1520594087975,["gengmei_pxf@gengmei123.local",[[1,9614,"\n"]],[9612,9612],[9613,9613]]],[1520594088296,["gengmei_pxf@gengmei123.local",[[1,9615,"\n"]],[9613,9613],[9614,9614]]],[1520594574525,["gengmei_pxf@gengmei123.local",[[1,9614,"#### **所有手机**\n\nPopupWindow中嵌套EditText，会出现EditText长按无法触发“粘贴”选项，可以改成Dialog嵌套EditText，包括DialogFragment。"]],[9614,9614],[9714,9714]]],[1520594579492,["gengmei_pxf@gengmei123.local",[[-1,9614,"####"],[1,9618,"*"]],[9614,9618],[9615,9615]]],[1520594955581,["gengmei_pxf@gengmei123.local",[[1,9713,"\n"]],[9711,9711],[9712,9712]]],[1520594955908,["gengmei_pxf@gengmei123.local",[[1,9714,"\n"]],[9712,9712],[9713,9713]]],[1520594956336,["gengmei_pxf@gengmei123.local",[[1,9713,"#### **所有手机**\n\n场景：输入法中的emoji适配，Android4.1之前的系统不支持emoji显示\n\n解决方案：所以对于Android4.1之前的系统，我采用了bitmap来显示emoji。"]],[9713,9713],[9815,9815]]],[1520594960279,["gengmei_pxf@gengmei123.local",[[-1,9713,"####"],[1,9717,"*"]],[9713,9717],[9714,9714]]],[1520595371686,["gengmei_pxf@gengmei123.local",[[1,9814,"\n"]],[9813,9813],[9814,9814]]],[1520595371895,["gengmei_pxf@gengmei123.local",[[1,9815,"\n"]],[9814,9814],[9815,9815]]],[1520595372769,["gengmei_pxf@gengmei123.local",[[1,9814,"#### **OPPO 手机**\n\n场景：OPPO 手机启动 Service 报 SecurityException \n解决方案：try catch 该异常"]],[9814,9814],[9892,9892]]],[1520595376433,["gengmei_pxf@gengmei123.local",[[-1,9814,"####"],[1,9818,"*"],[-1,9872," "],[1,9873," "]],[9814,9818],[9815,9815]]],[1520642120025,["gengmei_pxf@gengmei123.local",[[1,10179,"\n"]],[10177,10177],[10178,10178]]],[1520642120406,["gengmei_pxf@gengmei123.local",[[1,10180,"\n"]],[10178,10178],[10179,10179]]],[1520642121856,["gengmei_pxf@gengmei123.local",[[1,10179,"#### 什么是 HTTPS?\n\nHTTPS (基于安全套接字层的超文本传输协议 或者是 HTTP over SSL) 是一个 Netscape 开发的 Web 协议。\n\n你也可以说：HTTPS = HTTP + SSL\n\nHTTPS 在 HTTP 应用层的基础上使用安全套接字层作为子层。\n\n#### 为什么需要 HTTPS ？\n\n超文本传输协议 (HTTP) 是一个用来通过互联网传输和接收信息的协议。HTTP 使用请求/响应的过程，因此信息可在服务器间快速、轻松而且精确的进行传输。当你访问 Web 页面的时候你就是在使用 HTTP 协议，但 HTTP 是不安全的，可以轻松对窃听你跟 Web 服务器之间的数据传输。在很多情况下，客户和服务器之间传输的是敏感歇息，需要防止未经授权的访问。为了满足这个要求，网景公司(Netscape)推出了[HTTPS](http://www.nowamagic.net/librarys/veda/tag/https)，也就是基于安全套接字层的 HTTP 协议。\n\n#### HTTP 和 HTTPS 的相同点\n\n大多数情况下，HTTP 和 HTTPS 是相同的，因为都是采用同一个基础的协议，作为 HTTP 或 HTTPS 客户端——浏览器，设立一个连接到 Web 服务器指定的端口。当服务器接收到请求，它会返回一个状态码以及消息，这个回应可能是请求信息、或者指示某个错误发送的错误信息。系统使用统一资源定位器 URI 模式，因此资源可以被唯一指定。而 HTTPS 和 HTTP 唯一不同的只是一个协议头(https)的说明，其他都是一样的。\n\n#### HTTP 和 HTTPS 的不同之处\n\n1.  HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头\n2.  HTTP 是不安全的，而 HTTPS 是安全的\n3.  HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443\n4.  在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层\n5.  HTTP 无需加密，而 HTTPS 对传输的数据进行加密\n6.  HTTP 无需证书，而 HTTPS 需要认证证书\n\n#### HTTPS 如何工作?\n\n使用 HTTPS 连接时，服务器要求有公钥和签名的证书。\n\n当使用 https 连接，服务器响应初始连接，并提供它所支持的加密方法。作为回应，客户端选择一个连接方法，并且客户端和服务器端交换证书验证彼此身份。完成之后，在确保使用相同密钥的情况下传输加密信息，然后关闭连接。为了提供 https 连接支持，服务器必须有一个公钥证书，该证书包含经过证书机构认证的密钥信息，大部分证书都是通过第三方机构授权的，以保证证书是安全的。\n\n换句话说，HTTPS 跟 HTTP 一样，只不过增加了 [SSL](http://www.nowamagic.net/librarys/veda/tag/SSL)。\n\nHTTP 包含如下动作：\n\n1.  浏览器打开一个 TCP 连接\n2.  浏览器发送 HTTP 请求到服务器端\n3.  服务器发送 HTTP 回应信息到浏览器\n4.  TCP 连接关闭\n\nSSL 包含如下动作：\n\n1.  验证服务器端\n2.  允许客户端和服务器端选择加密算法和密码，确保双方都支持\n3.  验证客户端(可选)\n4.  使用公钥加密技术来生成共享加密数据\n5.  创建一个加密的 SSL 连接\n6.  基于该 SSL 连接传递 HTTP 请求\n\n#### 什么时候该使用 HTTPS?\n\n银行网站、支付网关、购物网站、登录页、电子邮件以及一些企业部门的网站应该使用 HTTPS，例如：\n\n*   PayPal: https://www.paypal.com\n*   Google AdSense: https://www.google.com/adsense/\n\n如果某个网站要求你填写信用卡信息，首先你要检查该网页是否使用 https 加密连接，如果没有，那么请不要输入任何敏感信息如信用卡号。"]],[10179,10179],[11899,11899]]],[1520642137445,["gengmei_pxf@gengmei123.local",[[1,10170,"\n"],[-1,11386," "],[1,11387," "]],[10168,10168],[10169,10169]]],[1520642138507,["gengmei_pxf@gengmei123.local",[[1,10171,"\n"]],[10169,10169],[10170,10170]]],[1520642138943,["gengmei_pxf@gengmei123.local",[[1,10170,"[HTTPS和HTTP的区别](http://blog.csdn.net/whatday/article/details/38147103)"]],[10170,10170],[10240,10240]]],[1520642143295,["gengmei_pxf@gengmei123.local",[[1,10170,"## "]],[10170,10170],[10173,10173]]],[1520642151671,["gengmei_pxf@gengmei123.local",[[-1,10245,"## 混合开发"]],[10245,10252],[10245,10245]]],[1520642152005,["gengmei_pxf@gengmei123.local",[[-1,10246,"\n"]],[10245,10245],[10244,10244]]],[1520642153364,["gengmei_pxf@gengmei123.local",[[-1,10245,"\n"]],[10244,10244],[10243,10243]]],[1520642155548,["gengmei_pxf@gengmei123.local",[[1,10170,"\n"]],[10168,10168],[10169,10169]]],[1520642155748,["gengmei_pxf@gengmei123.local",[[1,10171,"\n"]],[10169,10169],[10170,10170]]],[1520642156157,["gengmei_pxf@gengmei123.local",[[1,10170,"## 混合开发"]],[10170,10170],[10177,10177]]]]],["7e704190-a0f0-46e2-8efc-d000b64b8e38",1520642303573,"简历中的questions\n==\n*   **基础知识 – 四大组件（生命周期，使用场景，如何启动）**\n*   **java基础 – 数据结构，线程，mvc框架**\n*   **通信 – 网络连接（HttpClient，HttpUrlConnetion），Socket**\n*   **数据持久化 – SQLite，SharedPreferences，ContentProvider**\n*   **性能优化 – 布局优化，内存优化，电量优化**\n*   **安全 – 数据加密，代码混淆，WebView/Js调用，https**\n*   **UI– 动画**\n*   **其他 – JNI，AIDL，Handler，Intent等**\n*   **开源框架 – Volley，Gilde，RxJava等（简历上写你会的，用过的）**\n*   **拓展 – Android6.0/7.0/8.0特性，kotlin语言，I/O大会**\n\n## Android中的设计模式\n\n [Android中的设计模式](https://pxfile.github.io/2018/03/08/Android%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/)\n\n1.单例 全局性 减少对象创建，降低系统内存的消耗，减少gc次数和卡顿时间 初始化资源的工具类\n2.创建者模式 创建对象的参数很多且不定，参数个数和类型不确定， AlertDialog glide okhttp\n3.适配器模式 baseAdapter\n4.装饰模式 context\n5.外观模式 contextImple\n6.策略模式 属性动画 插值器\n7.组合模式 view和viewGroup\n8.模板方法 Activity fragment\n9.观察者模式 RxJava\n10.责任链模式 try catch，事件分发机制\n\n##  Android各组件和机制\n\n### [Activity](https://pxfile.github.io/2018/03/08/%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3Activity/)\n\nActivity\n\n#### 1.四大组件中Activity是用的最多也是最基础的，Activity提供窗口来与用户进行交互\n\n#### 2.Android默认会为每一个App应用提供一个task的栈老存放和管理该App所有的Activity task默认的name是该App的包名 也可以在mainfest清单文件中设置Activity的taskAffinity属性来自定义task，但是不建议这样使用，如果别App也设置一样的task，它就可能启动你的Activity，带来各种安全隐患\n\n#### 3.Activity的生命周期 onCreate -> onStart -> onResume -> onPause -> onStop -> onDestroy\n\n正常情况下生命周期的调用\n（1）A页面打开B页面或者切回到桌面 A Activity：onPause -》 onStop，如果B Activity采用了透明主题 则不会调用 onStop\n\n（2）先调用A的onPause再调用B的onResume方法\n\n（3）再回到A页面时，onRestart -》 onStart -》onResume\n\n（4）按返回键时，onPause -》 onStop -》onDestroy\n\n异常情况下在生命周期的调用\n\n（1）资源相关的系统配置发生改变时，Activity被杀死 例如Activity竖屏，突然旋转屏幕，Activity默认会销毁并重新创建\n\nonSaveInstanceState -》 onDestroy   重新创建  onCreate 。。。-》 onDestroy\n\n（2）系统资源不足导致优先级低的Activity被回收\n\nonSaveInstanceState -》 onDestroy   重新创建  onCreate 。。。-》 onDestroy\n\n#### 4.Activity信息保存和恢复\n\n系统会调用onSaveInstanceState来保存当前Activity的状态，这个方法调用的时机是在onStop之前，他和onPause没有既定的时序关系，他即可能在onPause之前调用，也有可能在之后调用，需要强调的是，这个方法只出现在Activity被异常终止的情况下，正常情况下是不会走这个方法的，当我们onSaveInstanceState保存到Bundler对象作为参数传递给onRestoreInstanceState和onCreate方法，因此我们可以通过onRestoreInstanceState和onCreate方法来判断Activity是否被重建。如果被重建了，我们就取出之前的数据恢复，从时序上来说，onRestoreInstanceState的调用时机应该在onStart之后\n\n#### 5.启动模式\n\n（1）定义启动模式的方法\n\nmanifest中声明 \n\n<activity\n            ．．．．．．\n            android:launchMode=\"standard\"\n             >\n           ．．．．．．．\n        </activity>\n\n 使用Intent标志\n\nIntent i = new Intent(this,ＮewActivity.class);\n\t\ti.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\t\tstartActivity(i);\n\n（2）模式类型\n\n**standard** 默认模式\n**singleTop** 当目标Activity位于task栈的栈顶时，直接复用，不会创建新的Activity，否则泽创建新的Activity并添加到task栈中\n**singleTask** 如果目标Activity位于Task栈顶中，则复用，如果没有位于栈顶就将目标Activity之前的Activity移除栈，然后调用，否则就创建新的Activity并添加到栈中\n**singleInstance** 如果目标Activity不存在，创建一个新的task栈添加目标Activity并调用，如果Activity已存在就将Activity所在的task移到前台并调用\n\n###  [Service](https://pxfile.github.io/2018/03/08/Service%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93/)\n\nService 应用程序组件 能够在后台执行耗时较长的操作，并且不提供界面\n\n#### Service分类\n\n##### 按运行分类\n\n* 前台Service \n\nstartForeground 开启前台服务 \n\nstopForeground  移除前台服务\n\n* 后台Service\n\n##### 按使用分类\n\n* 本地服务\n\n运用于应用程序内部实现一些耗时操作，并不占用Activity的线程，而是新开一个线程在后台执行 \n\nContext.startService 启动\n\nContext.stopService 结束\n\n在内部可以调用Service.stopSelf() 或 Service.stopSelfResult()来自己停止。\n\n* 远程服务 \n\n用于应用程序之间，可被其他应用程序复用 例如天气预报，其他应用程序不需要在写这样的服务，调用即可\n\n通过暴露接口供其他应用程序调用\n\n#### Contex.bindService 连接\n\n#### Context.unbinService 断开连接\n\n#### Service生命周期\n\n* onCreate -》 onStartCommand -》 onDestroy\n\n* onCreate -》 onBind =》onUnBind -》onDestroy\n\n#### onStartCommand()方法必须返回一个整数。\n\n* START_NOT_STICKY 杀死了服务，则不会重建服务\n\n* START_STICKY  杀死了服务，则将重建服务并调用onStartCommand()，但不会再次送入上一个intent  这适用于媒体播放器（或类似服务），它们不执行命令，但需要一直运行并随时待命\n\n* START_REDELIVER_INTENT 杀死了服务，则将重建服务并用上一个已送过的intent调用onStartCommand() 适用于那些需要立即恢复工作的活跃服务，比如下载文件\n\n#### start服务\n\n#### bind服务\n\n#### 在mainfest中声明服务\n\n``` \n<manifest ... >\n\t... \n\t<application ... >\n\t <service android:name=\".ExampleService\" /> \n\t... \n\t</application> \n</manifest>\n```\n\n###  [ContentProvider](https://pxfile.github.io/2018/03/08/ContentProvider%E5%AE%9E%E4%BE%8B%E8%AF%A6%E8%A7%A3/)\n\nContentProvider（内容提供者）是Android的四大组件之一，管理android以结构化方式存放的数据，以相对安全的方式封装数据（表）并且提供简易的处理机制和统一的访问接口供**其他程序**调用。　\n\n　　Android的数据存储方式总共有五种，分别是：Shared Preferences、网络存储、文件存储、外储存储、SQLite。但一般这些存储都只是在单独的一个应用程序之中达到一个数据的共享，有时候我们需要操作其他应用程序的一些数据，就会用到ContentProvider。而且Android为常见的一些数据提供了默认的ContentProvider（包括音频、视频、图片和通讯录等）。\n\n　　但注意ContentProvider它也只是一个中间人，真正操作的数据源可能是数据库，也可以是文件、xml或网络等其他存储方式。\n\n###  [BroadcastReceiver](https://pxfile.github.io/2018/03/08/BroadcastReceiver%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/)\n\n广播是一种广泛运用的在应用程序之间传输信息的机制，主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。\n\n　　在实现开机启动服务和网络状态改变、电量变化、短信和来电时通过接收系统的广播让应用程序作出相应的处理。\n\n　　BroadcastReceiver 自身并不实现图形用户界面，但是当它收到某个通知后， BroadcastReceiver 可以通过启动 Service 、启动 Activity 或是 NotificationMananger 提醒用户。\n\n静态注册\n\n在AndroidManifest.xml的application里面定义receiver并设置要接收的action。\n\n``` \n< receiver android:name = \".MyBroadcastReceiver\" > \n < intent-filter android:priority = \"777\" > <action android:name = \"android.provider.Telephony.SMS_RECEIVED\" /> </ intent-filter >  </ receiver > \n```\n动态注册\n在Activity中声明BroadcastReceiver的扩展对象，在onResume中注册，onPause中卸载.\n\n#### 静态注册和动态注册的区别\n \n  　　1、静态注册的广播接收者一经安装就常驻在系统之中，不需要重新启动唤醒接收者；\n　　动态注册的广播接收者随着应用的生命周期，由registerReceiver开始监听，由unregisterReceiver撤销监听，如果应用退出后，没有撤销已经注册的接收者应用应用将会报错。\n\n　　2、当广播接收者通过intent启动一个activity或者service时，如果intent中无法匹配到相应的组件。　\n　　动态注册的广播接收者将会导致应用报错\n　　而静态注册的广播接收者将不会有任何报错，因为自从应用安装完成后，广播接收者跟应用已经脱离了关系。\n\n#### 总结\n\n- 静态广播接收的处理器是由PackageManagerService负责，当手机启动或者新安装了应用的时候，PackageManagerService会扫描手机中所有已安装的APP应用，将AndroidManifest.xml中有关注册广播的信息解析出来，存储至一个全局静态变量当中。\n\n - 动态广播接收的处理器是由ActivityManagerService负责，当APP的服务或者进程起来之后，执行了注册广播接收的代码逻辑，即进行加载，最后会存储在一个另外的全局静态变量中。需要注意的是：\n\n　　 1、 这个并非是一成不变的，当程序被杀死之后，已注册的动态广播接收器也会被移出全局变量，直到下次程序启动，再进行动态广播的注册，当然这里面的顺序也已经变更了一次。\n\n　　 2、这里也并没完整的进行广播的排序，只记录的注册的先后顺序，并未有结合优先级的处理。\n\n - 广播发出的时候，广播接收者接收的顺序如下：\n\n　　１．当广播为**普通广播**时，有如下的接收顺序：\n\n　　无视优先级\n　　动态优先于静态\n　　同优先级的动态广播接收器，**先注册的大于后注册的** 　　同优先级的静态广播接收器，**先扫描的大于后扫描的**　\n\n　　２．如果广播为**有序广播**，那么会将动态广播处理器和静态广播处理器合并在一起处理广播的消息，最终确定广播接收的顺序：　\n\n　　优先级高的先接收　\n　　同优先级的动静态广播接收器，**动态优先于静态** 　　同优先级的动态广播接收器，**先注册的大于后注册的** 　　同优先级的静态广播接收器，**先扫描的大于后扫描的**\n\n#### **广播怎么不跨进程**\n\n无论是使用扩展变量作用域、基于接口的回调还是Handler-post/Handler-Message等方式，都可以直接处理此类问题，若适用广播机制，显然有些“杀鸡牛刀”的感觉，会显太“重”；\n\n##  模块化和组件化开发\n[模块化和组件化开发](https://pxfile.github.io/2018/03/02/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/)\n\n### 模块化\n按照功能划分成相互独立的模块，使其只包含与其相关的功能。登录，搜索，交易，社区等\n### 组件化\n基于可重用的目的，将一个系统按照拆分关注点的形式，拆分成一个的组件，减少解耦\n\n### 模块化vs组件化\n\n模块化和组件化本质思想是一样的,都是”大化小”,两者的目的都是为了重用和解耦,只是叫法不一样.如果非要说区别,那么可以认为模块化粒度更小,更侧重于重用,而组件化粒度稍大于模块,更侧重于业务解耦。\n\n### 优点\n\n*   **1.模块间解耦，复用，避免重复造轮子，节省开发维护成本** 对业务进行模块化拆分后，为了使各业务模块间解耦，因此各个都是独立的模块，它们之间是没有依赖关系。每个模块负责的功能不同，业务逻辑不同，模块间业务解耦。模块功能比较单一，可在多个项目中使用\n\n*   **2.可单独编译某个模块，降低项目复杂性，提升开发效率** 每个模块实际上也是一个完整的项目，可以进行单独编译，调试\n\n*   **3.可以多团队并行开发，测试 多个团队公用同一个组件，在一定层度上确保了技术方案的统一性** 每个团队负责不同的模块，提升开发，测试效率\n\n##  Android开发模式(MVC，MVVM，MVP)\n[浅谈MVC、MVP、MVVM架构模式的区别和联系](http://www.cnblogs.com/guwei4037/p/5591183.html)\n\n### MVC \nView  xml\nController Activity\nModel 建立的数据机构和相关的类\n\n1.View传达指令到Controller\n2.Controller完成业务逻辑后，要求Model改变状态\n3.Model将新的数据发送给View，更新视图，用户得到反馈 \n\nMVC可分为2种 \n\n1.通过View接受指令\n2.通过Controller接受指令\n\n缺点\n\n在Android开发中，Activity并不是一个标准的MVC模式中的Controller，它的首要职责是加载应用的布局和初始化用户界面 ，并接受并处理来自用户的操作请求，进而作出响应。随着界面及其逻辑的复杂度不断提升， Activity类的职责不断增加，以致变得庞大臃肿。\n\n### MVP\n在App开发过程中，经常出现的问题就是某部分的代码过 ，虽然做模块划分和接隔离，但也很难完全避免。从实践中看到，这多的出现在UI部分，也就是Activity 。想象下， 个2000+ 以上基本 带注释的Activity，我的第 反应就是想吐。Activity内容过多的原因其实很好解释，因为Activity本身需要担负 与用户之间的操作交互，界面的展示， 是单纯的Controller或View。 且现在部分的Activity还对整个App 起到类似iOS中的【ViewController】的作 ，这又带入的逻辑代码，造成Activity的臃肿。为 解决这个问题，让我们引MVP框架。\n\n将Controller改成了Presenter，同时改变了通信方向\n1.Presenter和View是可以双向通信的\n2.Presenter和Model也是可以双向通信的\n3.View和Model之间不能通信，都是通过Presenter传递的\n4.View和薄，没有任何业务逻辑，而Presenter很厚，所有的业务逻辑都在这处理\n\n\n\n### MVVM\n将Presenter改成了Viewmodel，通信方式基本和MVP差不多，最大的区别是MVVM有双向绑定，View的变动反映在ViewModel上，ViewModel的修改也会更新View\n\n## 事件分发机制\n[事件分发机制](https://www.jianshu.com/p/38015afcdb58)\n\n![onTouchEvent](https://upload-images.jianshu.io/upload_images/944365-aea821bbb613c195.png)\n\n## Handler机制\n[Handler机制](https://pxfile.github.io/2018/03/08/%E7%B2%BE%E9%80%9AAndroid%E4%B8%8B%E7%9A%84Handler%E6%9C%BA%E5%88%B6/)\n\n![](http://upload-images.jianshu.io/upload_images/1824194-a947dcc5b22f69fb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n*   1.在创建Activity之前，当系统启动的时候，先加载ActivityThread这个类，在这个类中的main函数，调用了Looper.prepareMainLooper()方法进行初始化Looper对象；\n\n*   2.然后创建了主线程的handler对象（Tips：加载ActivityThread的时候，其内部的Handler对象[静态的]还未创建）；\n\n*   3.随后才创建了ActivityThread对象；\n\n*   4.最后调用了Looper.loop();方法，不断的进行轮询消息队列的消息。\n\n*   也就是说，在ActivityThread和Activity创建之前（同样也是Handler创建之前，当然handler由于这两者初始化），就已经开启了Looper的loop()方法，不断的进行轮询消息。\n\n* 需要注意的是，这个轮询的方法是阻塞式的，没有消息就一直等待（实际是等着MessageQueue的next()方法返回消息）。\n\n* 在应用一执行的时候，就已经开启了Looper，并初始化了Handler对象。此时，系统的某些组件或者其他的一些活动等发送了系统级别的消息，这个时候主线程中的Looper就可以进行轮询消息，并调用msg.target.dispatchMessage(msg)（msg.target即为handler）进行分发消息，并通过handler的handleMessage方法进行处理；所以会优于我们自己创建的handler中的消息而处理系统消息。\n\n下面，我们按照启动顺序来进行源码分析：\n\n![](http://upload-images.jianshu.io/upload_images/1824194-298ebb16ce4a3b70.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 机型适配\n[机型适配](http://blog.csdn.net/mwq384807683/article/details/72594027)\n\n* **魅族3和魅族4**\n\n场景：魅族手机ListView的Item中的EditText无法编辑，点击EditText弹出软键盘后，软键盘会立即自动隐藏 \n机型：[魅族3，魅族4] \n解决方案： \n方法一：将ListView换成RecyclerView\n\n方法二：[https://github.com/Aspsine/EditTextInListView](https://github.com/Aspsine/EditTextInListView)\n\n* **HTC M8**\n\n场景：HTC M8 从一个Activity 使用QQSDK 登陆, 登陆成功后, 返回Activity结果Activity 被销毁了 \n机型：HTC M8 等某些带有 虚拟 Menu 键盘的手机 \n解决方案：后来调查发现是这个Activity是全屏,屏蔽了Menu键盘的黑条. 但是跳转到QQ却把那个Menu的黑条显示了出来, 这导致发生了 screenSize 的变化 从而导致我的Activity销毁了. \n知道了这个原因, 在manifest中的 configChanges 添加screenSize 解决了这个问题.\n\n* **所有手机**\n\nPopupWindow中嵌套EditText，会出现EditText长按无法触发“粘贴”选项，可以改成Dialog嵌套EditText，包括DialogFragment。\n\n* **所有手机**\n\n场景：输入法中的emoji适配，Android4.1之前的系统不支持emoji显示\n\n解决方案：所以对于Android4.1之前的系统，我采用了bitmap来显示emoji。\n\n* **OPPO 手机**\n\n场景：OPPO 手机启动 Service 报 SecurityException \n解决方案：try catch 该异常\n\n## 性能优化\n [性能优化](https://pxfile.github.io/2018/03/08/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/)\n\n## 内存泄漏\n [内存泄漏](https://pxfile.github.io/2018/02/14/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/)\n\n## Binder机制\n [Binder机制](https://pxfile.github.io/2018/03/07/Binder%E6%9C%BA%E5%88%B6/)\n\n## 混合开发\n\n## [HTTPS和HTTP的区别](http://blog.csdn.net/whatday/article/details/38147103)\n\n#### 什么是 HTTPS?\n\nHTTPS (基于安全套接字层的超文本传输协议 或者是 HTTP over SSL) 是一个 Netscape 开发的 Web 协议。\n\n你也可以说：HTTPS = HTTP + SSL\n\nHTTPS 在 HTTP 应用层的基础上使用安全套接字层作为子层。\n\n#### 为什么需要 HTTPS ？\n\n超文本传输协议 (HTTP) 是一个用来通过互联网传输和接收信息的协议。HTTP 使用请求/响应的过程，因此信息可在服务器间快速、轻松而且精确的进行传输。当你访问 Web 页面的时候你就是在使用 HTTP 协议，但 HTTP 是不安全的，可以轻松对窃听你跟 Web 服务器之间的数据传输。在很多情况下，客户和服务器之间传输的是敏感歇息，需要防止未经授权的访问。为了满足这个要求，网景公司(Netscape)推出了[HTTPS](http://www.nowamagic.net/librarys/veda/tag/https)，也就是基于安全套接字层的 HTTP 协议。\n\n#### HTTP 和 HTTPS 的相同点\n\n大多数情况下，HTTP 和 HTTPS 是相同的，因为都是采用同一个基础的协议，作为 HTTP 或 HTTPS 客户端——浏览器，设立一个连接到 Web 服务器指定的端口。当服务器接收到请求，它会返回一个状态码以及消息，这个回应可能是请求信息、或者指示某个错误发送的错误信息。系统使用统一资源定位器 URI 模式，因此资源可以被唯一指定。而 HTTPS 和 HTTP 唯一不同的只是一个协议头(https)的说明，其他都是一样的。\n\n#### HTTP 和 HTTPS 的不同之处\n\n1.  HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头\n2.  HTTP 是不安全的，而 HTTPS 是安全的\n3.  HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443\n4.  在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层\n5.  HTTP 无需加密，而 HTTPS 对传输的数据进行加密\n6.  HTTP 无需证书，而 HTTPS 需要认证证书\n\n#### HTTPS 如何工作?\n\n使用 HTTPS 连接时，服务器要求有公钥和签名的证书。\n\n当使用 https 连接，服务器响应初始连接，并提供它所支持的加密方法。作为回应，客户端选择一个连接方法，并且客户端和服务器端交换证书验证彼此身份。完成之后，在确保使用相同密钥的情况下传输加密信息，然后关闭连接。为了提供 https 连接支持，服务器必须有一个公钥证书，该证书包含经过证书机构认证的密钥信息，大部分证书都是通过第三方机构授权的，以保证证书是安全的。\n\n换句话说，HTTPS 跟 HTTP 一样，只不过增加了 [SSL](http://www.nowamagic.net/librarys/veda/tag/SSL)。\n\nHTTP 包含如下动作：\n\n1.  浏览器打开一个 TCP 连接\n2.  浏览器发送 HTTP 请求到服务器端\n3.  服务器发送 HTTP 回应信息到浏览器\n4.  TCP 连接关闭\n\nSSL 包含如下动作：\n\n1.  验证服务器端\n2.  允许客户端和服务器端选择加密算法和密码，确保双方都支持\n3.  验证客户端(可选)\n4.  使用公钥加密技术来生成共享加密数据\n5.  创建一个加密的 SSL 连接\n6.  基于该 SSL 连接传递 HTTP 请求\n\n#### 什么时候该使用 HTTPS?\n\n银行网站、支付网关、购物网站、登录页、电子邮件以及一些企业部门的网站应该使用 HTTPS，例如：\n\n*   PayPal: https://www.paypal.com\n*   Google AdSense: https://www.google.com/adsense/\n\n如果某个网站要求你填写信用卡信息，首先你要检查该网页是否使用 https 加密连接，如果没有，那么请不要输入任何敏感信息如信用卡号。\n\n## Android面试题\n[Android面试题](http://blog.csdn.net/angel_w/article/details/79103141)",[[1520642298847,["gengmei_pxf@localhost",[[-1,10257,"#"]],[10258,10258],[10257,10257]]],[1520642301312,["gengmei_pxf@localhost",[[-1,10403,"#"]],[10404,10404],[10403,10403]]],[1520642306415,["gengmei_pxf@localhost",[[-1,10709,"#"]],[10710,10710],[10709,10709]]],[1520642312167,["gengmei_pxf@localhost",[[-1,10949,"#"]],[10950,10950],[10949,10949]]],[1520642392158,["gengmei_pxf@localhost",[[-1,11201,"#"]],[11202,11202],[11201,11201]]],[1520642401371,["gengmei_pxf@localhost",[[-1,11747,"#"]],[11748,11748],[11747,11747]]],[1520646851358,["gengmei_pxf@localhost",[[1,11970,"\n"]],[11968,11968],[11969,11969]]],[1520646851548,["gengmei_pxf@localhost",[[1,11971,"\n"]],[11969,11969],[11970,11970]]],[1520646852120,["gengmei_pxf@localhost",[[1,11970,"## 如何有效的减少重复的代码\n\n**一、使用include标签引用重复布局**\n\n**二、使用style定义样式**\n\n**三、使用ViewStub减少整体布局的重复**\n\n**四、多使用应用资源**\n\n**五、代码的抽象与继承**"]],[11970,11970],[12087,12087]]]]],["7c2d6456-8d46-4a17-b582-74f837d0a266",1520648938584,"简历中的questions\n==\n*   **基础知识 – 四大组件（生命周期，使用场景，如何启动）**\n*   **java基础 – 数据结构，线程，mvc框架**\n*   **通信 – 网络连接（HttpClient，HttpUrlConnetion），Socket**\n*   **数据持久化 – SQLite，SharedPreferences，ContentProvider**\n*   **性能优化 – 布局优化，内存优化，电量优化**\n*   **安全 – 数据加密，代码混淆，WebView/Js调用，https**\n*   **UI– 动画**\n*   **其他 – JNI，AIDL，Handler，Intent等**\n*   **开源框架 – Volley，Gilde，RxJava等（简历上写你会的，用过的）**\n*   **拓展 – Android6.0/7.0/8.0特性，kotlin语言，I/O大会**\n\n## Android中的设计模式\n\n [Android中的设计模式](https://pxfile.github.io/2018/03/08/Android%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/)\n\n1.单例 全局性 减少对象创建，降低系统内存的消耗，减少gc次数和卡顿时间 初始化资源的工具类\n2.创建者模式 创建对象的参数很多且不定，参数个数和类型不确定， AlertDialog glide okhttp\n3.适配器模式 baseAdapter\n4.装饰模式 context\n5.外观模式 contextImple\n6.策略模式 属性动画 插值器\n7.组合模式 view和viewGroup\n8.模板方法 Activity fragment\n9.观察者模式 RxJava\n10.责任链模式 try catch，事件分发机制\n\n##  Android各组件和机制\n\n### [Activity](https://pxfile.github.io/2018/03/08/%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3Activity/)\n\nActivity\n\n#### 1.四大组件中Activity是用的最多也是最基础的，Activity提供窗口来与用户进行交互\n\n#### 2.Android默认会为每一个App应用提供一个task的栈老存放和管理该App所有的Activity task默认的name是该App的包名 也可以在mainfest清单文件中设置Activity的taskAffinity属性来自定义task，但是不建议这样使用，如果别App也设置一样的task，它就可能启动你的Activity，带来各种安全隐患\n\n#### 3.Activity的生命周期 onCreate -> onStart -> onResume -> onPause -> onStop -> onDestroy\n\n正常情况下生命周期的调用\n（1）A页面打开B页面或者切回到桌面 A Activity：onPause -》 onStop，如果B Activity采用了透明主题 则不会调用 onStop\n\n（2）先调用A的onPause再调用B的onResume方法\n\n（3）再回到A页面时，onRestart -》 onStart -》onResume\n\n（4）按返回键时，onPause -》 onStop -》onDestroy\n\n异常情况下在生命周期的调用\n\n（1）资源相关的系统配置发生改变时，Activity被杀死 例如Activity竖屏，突然旋转屏幕，Activity默认会销毁并重新创建\n\nonSaveInstanceState -》 onDestroy   重新创建  onCreate 。。。-》 onDestroy\n\n（2）系统资源不足导致优先级低的Activity被回收\n\nonSaveInstanceState -》 onDestroy   重新创建  onCreate 。。。-》 onDestroy\n\n#### 4.Activity信息保存和恢复\n\n系统会调用onSaveInstanceState来保存当前Activity的状态，这个方法调用的时机是在onStop之前，他和onPause没有既定的时序关系，他即可能在onPause之前调用，也有可能在之后调用，需要强调的是，这个方法只出现在Activity被异常终止的情况下，正常情况下是不会走这个方法的，当我们onSaveInstanceState保存到Bundler对象作为参数传递给onRestoreInstanceState和onCreate方法，因此我们可以通过onRestoreInstanceState和onCreate方法来判断Activity是否被重建。如果被重建了，我们就取出之前的数据恢复，从时序上来说，onRestoreInstanceState的调用时机应该在onStart之后\n\n#### 5.启动模式\n\n（1）定义启动模式的方法\n\nmanifest中声明 \n\n<activity\n            ．．．．．．\n            android:launchMode=\"standard\"\n             >\n           ．．．．．．．\n        </activity>\n\n 使用Intent标志\n\nIntent i = new Intent(this,ＮewActivity.class);\n\t\ti.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\t\tstartActivity(i);\n\n（2）模式类型\n\n**standard** 默认模式\n**singleTop** 当目标Activity位于task栈的栈顶时，直接复用，不会创建新的Activity，否则泽创建新的Activity并添加到task栈中\n**singleTask** 如果目标Activity位于Task栈顶中，则复用，如果没有位于栈顶就将目标Activity之前的Activity移除栈，然后调用，否则就创建新的Activity并添加到栈中\n**singleInstance** 如果目标Activity不存在，创建一个新的task栈添加目标Activity并调用，如果Activity已存在就将Activity所在的task移到前台并调用\n\n###  [Service](https://pxfile.github.io/2018/03/08/Service%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93/)\n\nService 应用程序组件 能够在后台执行耗时较长的操作，并且不提供界面\n\n#### Service分类\n\n##### 按运行分类\n\n* 前台Service \n\nstartForeground 开启前台服务 \n\nstopForeground  移除前台服务\n\n* 后台Service\n\n##### 按使用分类\n\n* 本地服务\n\n运用于应用程序内部实现一些耗时操作，并不占用Activity的线程，而是新开一个线程在后台执行 \n\nContext.startService 启动\n\nContext.stopService 结束\n\n在内部可以调用Service.stopSelf() 或 Service.stopSelfResult()来自己停止。\n\n* 远程服务 \n\n用于应用程序之间，可被其他应用程序复用 例如天气预报，其他应用程序不需要在写这样的服务，调用即可\n\n通过暴露接口供其他应用程序调用\n\n#### Contex.bindService 连接\n\n#### Context.unbinService 断开连接\n\n#### Service生命周期\n\n* onCreate -》 onStartCommand -》 onDestroy\n\n* onCreate -》 onBind =》onUnBind -》onDestroy\n\n#### onStartCommand()方法必须返回一个整数。\n\n* START_NOT_STICKY 杀死了服务，则不会重建服务\n\n* START_STICKY  杀死了服务，则将重建服务并调用onStartCommand()，但不会再次送入上一个intent  这适用于媒体播放器（或类似服务），它们不执行命令，但需要一直运行并随时待命\n\n* START_REDELIVER_INTENT 杀死了服务，则将重建服务并用上一个已送过的intent调用onStartCommand() 适用于那些需要立即恢复工作的活跃服务，比如下载文件\n\n#### start服务\n\n#### bind服务\n\n#### 在mainfest中声明服务\n\n``` \n<manifest ... >\n\t... \n\t<application ... >\n\t <service android:name=\".ExampleService\" /> \n\t... \n\t</application> \n</manifest>\n```\n\n###  [ContentProvider](https://pxfile.github.io/2018/03/08/ContentProvider%E5%AE%9E%E4%BE%8B%E8%AF%A6%E8%A7%A3/)\n\nContentProvider（内容提供者）是Android的四大组件之一，管理android以结构化方式存放的数据，以相对安全的方式封装数据（表）并且提供简易的处理机制和统一的访问接口供**其他程序**调用。　\n\n　　Android的数据存储方式总共有五种，分别是：Shared Preferences、网络存储、文件存储、外储存储、SQLite。但一般这些存储都只是在单独的一个应用程序之中达到一个数据的共享，有时候我们需要操作其他应用程序的一些数据，就会用到ContentProvider。而且Android为常见的一些数据提供了默认的ContentProvider（包括音频、视频、图片和通讯录等）。\n\n　　但注意ContentProvider它也只是一个中间人，真正操作的数据源可能是数据库，也可以是文件、xml或网络等其他存储方式。\n\n###  [BroadcastReceiver](https://pxfile.github.io/2018/03/08/BroadcastReceiver%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/)\n\n广播是一种广泛运用的在应用程序之间传输信息的机制，主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。\n\n　　在实现开机启动服务和网络状态改变、电量变化、短信和来电时通过接收系统的广播让应用程序作出相应的处理。\n\n　　BroadcastReceiver 自身并不实现图形用户界面，但是当它收到某个通知后， BroadcastReceiver 可以通过启动 Service 、启动 Activity 或是 NotificationMananger 提醒用户。\n\n静态注册\n\n在AndroidManifest.xml的application里面定义receiver并设置要接收的action。\n\n``` \n< receiver android:name = \".MyBroadcastReceiver\" > \n < intent-filter android:priority = \"777\" > <action android:name = \"android.provider.Telephony.SMS_RECEIVED\" /> </ intent-filter >  </ receiver > \n```\n动态注册\n在Activity中声明BroadcastReceiver的扩展对象，在onResume中注册，onPause中卸载.\n\n#### 静态注册和动态注册的区别\n \n  　　1、静态注册的广播接收者一经安装就常驻在系统之中，不需要重新启动唤醒接收者；\n　　动态注册的广播接收者随着应用的生命周期，由registerReceiver开始监听，由unregisterReceiver撤销监听，如果应用退出后，没有撤销已经注册的接收者应用应用将会报错。\n\n　　2、当广播接收者通过intent启动一个activity或者service时，如果intent中无法匹配到相应的组件。　\n　　动态注册的广播接收者将会导致应用报错\n　　而静态注册的广播接收者将不会有任何报错，因为自从应用安装完成后，广播接收者跟应用已经脱离了关系。\n\n#### 总结\n\n- 静态广播接收的处理器是由PackageManagerService负责，当手机启动或者新安装了应用的时候，PackageManagerService会扫描手机中所有已安装的APP应用，将AndroidManifest.xml中有关注册广播的信息解析出来，存储至一个全局静态变量当中。\n\n - 动态广播接收的处理器是由ActivityManagerService负责，当APP的服务或者进程起来之后，执行了注册广播接收的代码逻辑，即进行加载，最后会存储在一个另外的全局静态变量中。需要注意的是：\n\n　　 1、 这个并非是一成不变的，当程序被杀死之后，已注册的动态广播接收器也会被移出全局变量，直到下次程序启动，再进行动态广播的注册，当然这里面的顺序也已经变更了一次。\n\n　　 2、这里也并没完整的进行广播的排序，只记录的注册的先后顺序，并未有结合优先级的处理。\n\n - 广播发出的时候，广播接收者接收的顺序如下：\n\n　　１．当广播为**普通广播**时，有如下的接收顺序：\n\n　　无视优先级\n　　动态优先于静态\n　　同优先级的动态广播接收器，**先注册的大于后注册的** 　　同优先级的静态广播接收器，**先扫描的大于后扫描的**　\n\n　　２．如果广播为**有序广播**，那么会将动态广播处理器和静态广播处理器合并在一起处理广播的消息，最终确定广播接收的顺序：　\n\n　　优先级高的先接收　\n　　同优先级的动静态广播接收器，**动态优先于静态** 　　同优先级的动态广播接收器，**先注册的大于后注册的** 　　同优先级的静态广播接收器，**先扫描的大于后扫描的**\n\n#### **广播怎么不跨进程**\n\n无论是使用扩展变量作用域、基于接口的回调还是Handler-post/Handler-Message等方式，都可以直接处理此类问题，若适用广播机制，显然有些“杀鸡牛刀”的感觉，会显太“重”；\n\n##  模块化和组件化开发\n[模块化和组件化开发](https://pxfile.github.io/2018/03/02/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/)\n\n### 模块化\n按照功能划分成相互独立的模块，使其只包含与其相关的功能。登录，搜索，交易，社区等\n### 组件化\n基于可重用的目的，将一个系统按照拆分关注点的形式，拆分成一个的组件，减少解耦\n\n### 模块化vs组件化\n\n模块化和组件化本质思想是一样的,都是”大化小”,两者的目的都是为了重用和解耦,只是叫法不一样.如果非要说区别,那么可以认为模块化粒度更小,更侧重于重用,而组件化粒度稍大于模块,更侧重于业务解耦。\n\n### 优点\n\n*   **1.模块间解耦，复用，避免重复造轮子，节省开发维护成本** 对业务进行模块化拆分后，为了使各业务模块间解耦，因此各个都是独立的模块，它们之间是没有依赖关系。每个模块负责的功能不同，业务逻辑不同，模块间业务解耦。模块功能比较单一，可在多个项目中使用\n\n*   **2.可单独编译某个模块，降低项目复杂性，提升开发效率** 每个模块实际上也是一个完整的项目，可以进行单独编译，调试\n\n*   **3.可以多团队并行开发，测试 多个团队公用同一个组件，在一定层度上确保了技术方案的统一性** 每个团队负责不同的模块，提升开发，测试效率\n\n##  Android开发模式(MVC，MVVM，MVP)\n[浅谈MVC、MVP、MVVM架构模式的区别和联系](http://www.cnblogs.com/guwei4037/p/5591183.html)\n\n### MVC \nView  xml\nController Activity\nModel 建立的数据机构和相关的类\n\n1.View传达指令到Controller\n2.Controller完成业务逻辑后，要求Model改变状态\n3.Model将新的数据发送给View，更新视图，用户得到反馈 \n\nMVC可分为2种 \n\n1.通过View接受指令\n2.通过Controller接受指令\n\n缺点\n\n在Android开发中，Activity并不是一个标准的MVC模式中的Controller，它的首要职责是加载应用的布局和初始化用户界面 ，并接受并处理来自用户的操作请求，进而作出响应。随着界面及其逻辑的复杂度不断提升， Activity类的职责不断增加，以致变得庞大臃肿。\n\n### MVP\n在App开发过程中，经常出现的问题就是某部分的代码过 ，虽然做模块划分和接隔离，但也很难完全避免。从实践中看到，这多的出现在UI部分，也就是Activity 。想象下， 个2000+ 以上基本 带注释的Activity，我的第 反应就是想吐。Activity内容过多的原因其实很好解释，因为Activity本身需要担负 与用户之间的操作交互，界面的展示， 是单纯的Controller或View。 且现在部分的Activity还对整个App 起到类似iOS中的【ViewController】的作 ，这又带入的逻辑代码，造成Activity的臃肿。为 解决这个问题，让我们引MVP框架。\n\n将Controller改成了Presenter，同时改变了通信方向\n1.Presenter和View是可以双向通信的\n2.Presenter和Model也是可以双向通信的\n3.View和Model之间不能通信，都是通过Presenter传递的\n4.View和薄，没有任何业务逻辑，而Presenter很厚，所有的业务逻辑都在这处理\n\n\n\n### MVVM\n将Presenter改成了Viewmodel，通信方式基本和MVP差不多，最大的区别是MVVM有双向绑定，View的变动反映在ViewModel上，ViewModel的修改也会更新View\n\n## 事件分发机制\n[事件分发机制](https://www.jianshu.com/p/38015afcdb58)\n\n![onTouchEvent](https://upload-images.jianshu.io/upload_images/944365-aea821bbb613c195.png)\n\n## Handler机制\n[Handler机制](https://pxfile.github.io/2018/03/08/%E7%B2%BE%E9%80%9AAndroid%E4%B8%8B%E7%9A%84Handler%E6%9C%BA%E5%88%B6/)\n\n![](http://upload-images.jianshu.io/upload_images/1824194-a947dcc5b22f69fb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n*   1.在创建Activity之前，当系统启动的时候，先加载ActivityThread这个类，在这个类中的main函数，调用了Looper.prepareMainLooper()方法进行初始化Looper对象；\n\n*   2.然后创建了主线程的handler对象（Tips：加载ActivityThread的时候，其内部的Handler对象[静态的]还未创建）；\n\n*   3.随后才创建了ActivityThread对象；\n\n*   4.最后调用了Looper.loop();方法，不断的进行轮询消息队列的消息。\n\n*   也就是说，在ActivityThread和Activity创建之前（同样也是Handler创建之前，当然handler由于这两者初始化），就已经开启了Looper的loop()方法，不断的进行轮询消息。\n\n* 需要注意的是，这个轮询的方法是阻塞式的，没有消息就一直等待（实际是等着MessageQueue的next()方法返回消息）。\n\n* 在应用一执行的时候，就已经开启了Looper，并初始化了Handler对象。此时，系统的某些组件或者其他的一些活动等发送了系统级别的消息，这个时候主线程中的Looper就可以进行轮询消息，并调用msg.target.dispatchMessage(msg)（msg.target即为handler）进行分发消息，并通过handler的handleMessage方法进行处理；所以会优于我们自己创建的handler中的消息而处理系统消息。\n\n下面，我们按照启动顺序来进行源码分析：\n\n![](http://upload-images.jianshu.io/upload_images/1824194-298ebb16ce4a3b70.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 机型适配\n[机型适配](http://blog.csdn.net/mwq384807683/article/details/72594027)\n\n* **魅族3和魅族4**\n\n场景：魅族手机ListView的Item中的EditText无法编辑，点击EditText弹出软键盘后，软键盘会立即自动隐藏 \n机型：[魅族3，魅族4] \n解决方案： \n方法一：将ListView换成RecyclerView\n\n方法二：[https://github.com/Aspsine/EditTextInListView](https://github.com/Aspsine/EditTextInListView)\n\n* **HTC M8**\n\n场景：HTC M8 从一个Activity 使用QQSDK 登陆, 登陆成功后, 返回Activity结果Activity 被销毁了 \n机型：HTC M8 等某些带有 虚拟 Menu 键盘的手机 \n解决方案：后来调查发现是这个Activity是全屏,屏蔽了Menu键盘的黑条. 但是跳转到QQ却把那个Menu的黑条显示了出来, 这导致发生了 screenSize 的变化 从而导致我的Activity销毁了. \n知道了这个原因, 在manifest中的 configChanges 添加screenSize 解决了这个问题.\n\n* **所有手机**\n\nPopupWindow中嵌套EditText，会出现EditText长按无法触发“粘贴”选项，可以改成Dialog嵌套EditText，包括DialogFragment。\n\n* **所有手机**\n\n场景：输入法中的emoji适配，Android4.1之前的系统不支持emoji显示\n\n解决方案：所以对于Android4.1之前的系统，我采用了bitmap来显示emoji。\n\n* **OPPO 手机**\n\n场景：OPPO 手机启动 Service 报 SecurityException \n解决方案：try catch 该异常\n\n## 性能优化\n [性能优化](https://pxfile.github.io/2018/03/08/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/)\n\n## 内存泄漏\n [内存泄漏](https://pxfile.github.io/2018/02/14/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/)\n\n## Binder机制\n [Binder机制](https://pxfile.github.io/2018/03/07/Binder%E6%9C%BA%E5%88%B6/)\n\n## 混合开发\n\n## [HTTPS和HTTP的区别](http://blog.csdn.net/whatday/article/details/38147103)\n\n### 什么是 HTTPS?\n\nHTTPS (基于安全套接字层的超文本传输协议 或者是 HTTP over SSL) 是一个 Netscape 开发的 Web 协议。\n\n你也可以说：HTTPS = HTTP + SSL\n\nHTTPS 在 HTTP 应用层的基础上使用安全套接字层作为子层。\n\n### 为什么需要 HTTPS ？\n\n超文本传输协议 (HTTP) 是一个用来通过互联网传输和接收信息的协议。HTTP 使用请求/响应的过程，因此信息可在服务器间快速、轻松而且精确的进行传输。当你访问 Web 页面的时候你就是在使用 HTTP 协议，但 HTTP 是不安全的，可以轻松对窃听你跟 Web 服务器之间的数据传输。在很多情况下，客户和服务器之间传输的是敏感歇息，需要防止未经授权的访问。为了满足这个要求，网景公司(Netscape)推出了[HTTPS](http://www.nowamagic.net/librarys/veda/tag/https)，也就是基于安全套接字层的 HTTP 协议。\n\n### HTTP 和 HTTPS 的相同点\n\n大多数情况下，HTTP 和 HTTPS 是相同的，因为都是采用同一个基础的协议，作为 HTTP 或 HTTPS 客户端——浏览器，设立一个连接到 Web 服务器指定的端口。当服务器接收到请求，它会返回一个状态码以及消息，这个回应可能是请求信息、或者指示某个错误发送的错误信息。系统使用统一资源定位器 URI 模式，因此资源可以被唯一指定。而 HTTPS 和 HTTP 唯一不同的只是一个协议头(https)的说明，其他都是一样的。\n\n### HTTP 和 HTTPS 的不同之处\n\n1.  HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头\n2.  HTTP 是不安全的，而 HTTPS 是安全的\n3.  HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443\n4.  在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层\n5.  HTTP 无需加密，而 HTTPS 对传输的数据进行加密\n6.  HTTP 无需证书，而 HTTPS 需要认证证书\n\n### HTTPS 如何工作?\n\n使用 HTTPS 连接时，服务器要求有公钥和签名的证书。\n\n当使用 https 连接，服务器响应初始连接，并提供它所支持的加密方法。作为回应，客户端选择一个连接方法，并且客户端和服务器端交换证书验证彼此身份。完成之后，在确保使用相同密钥的情况下传输加密信息，然后关闭连接。为了提供 https 连接支持，服务器必须有一个公钥证书，该证书包含经过证书机构认证的密钥信息，大部分证书都是通过第三方机构授权的，以保证证书是安全的。\n\n换句话说，HTTPS 跟 HTTP 一样，只不过增加了 [SSL](http://www.nowamagic.net/librarys/veda/tag/SSL)。\n\nHTTP 包含如下动作：\n\n1.  浏览器打开一个 TCP 连接\n2.  浏览器发送 HTTP 请求到服务器端\n3.  服务器发送 HTTP 回应信息到浏览器\n4.  TCP 连接关闭\n\nSSL 包含如下动作：\n\n1.  验证服务器端\n2.  允许客户端和服务器端选择加密算法和密码，确保双方都支持\n3.  验证客户端(可选)\n4.  使用公钥加密技术来生成共享加密数据\n5.  创建一个加密的 SSL 连接\n6.  基于该 SSL 连接传递 HTTP 请求\n\n### 什么时候该使用 HTTPS?\n\n银行网站、支付网关、购物网站、登录页、电子邮件以及一些企业部门的网站应该使用 HTTPS，例如：\n\n*   PayPal: https://www.paypal.com\n*   Google AdSense: https://www.google.com/adsense/\n\n如果某个网站要求你填写信用卡信息，首先你要检查该网页是否使用 https 加密连接，如果没有，那么请不要输入任何敏感信息如信用卡号。\n\n## 如何有效的减少重复的代码\n\n**一、使用include标签引用重复布局**\n\n**二、使用style定义样式**\n\n**三、使用ViewStub减少整体布局的重复**\n\n**四、多使用应用资源**\n\n**五、代码的抽象与继承**\n\n## Android面试题\n[Android面试题](http://blog.csdn.net/angel_w/article/details/79103141)",[[1520648911383,["gengmei_pxf@localhost",[[1,10179,"\n"]],[10177,10177],[10178,10178]]],[1520648913928,["gengmei_pxf@localhost",[[1,10178,"https://bxbxbai.github.io/2015/08/16/talk-about-bybird-app/"]],[10178,10178],[10237,10237]]],[1520648916504,["gengmei_pxf@localhost",[[-1,10178,"https://bxbxbai.github.io/2015/08/16/talk-about-bybird-app/"]],[10237,10237],[10178,10178]]],[1520648918176,["gengmei_pxf@localhost",[[1,10178,"【】"]],[10178,10178],[10180,10180]]],[1520648919037,["gengmei_pxf@localhost",[[-1,10178,"【】"]],[10180,10180],[10178,10178]]],[1520648919960,["gengmei_pxf@localhost",[[1,10178,"[]"]],[10178,10178],[10180,10180]]],[1520648922190,["gengmei_pxf@localhost",[[1,10179,"hun"]],[10179,10179],[10182,10182]]],[1520648922999,["gengmei_pxf@localhost",[[-1,10179,"hun"]],[10182,10182],[10179,10179]]],[1520648930327,["gengmei_pxf@localhost",[[1,10179,"混合开发"]],[10179,10179],[10183,10183]]],[1520648932324,["gengmei_pxf@localhost",[[1,10184,"（）"]],[10184,10184],[10186,10186]]],[1520648933724,["gengmei_pxf@localhost",[[-1,10184,"（）"]],[10186,10186],[10184,10184]]],[1520648934771,["gengmei_pxf@localhost",[[1,10184,"()"]],[10184,10184],[10186,10186]]],[1520648935758,["gengmei_pxf@localhost",[[1,10185,"https://bxbxbai.github.io/2015/08/16/talk-about-bybird-app/"]],[10185,10185],[10244,10244]]],[1520823106593,["gengmei_pxf@localhost",[[1,12157,"\n"]],[12156,12156],[12157,12157]]],[1520823106755,["gengmei_pxf@localhost",[[1,12158,"\n"]],[12157,12157],[12158,12158]]],[1520823122638,["gengmei_pxf@localhost",[[1,12157,"## Android进程报货"]],[12157,12157],[12171,12171]]],[1520823123211,["gengmei_pxf@localhost",[[-1,12169,"报货"]],[12171,12171],[12169,12169]]],[1520823134109,["gengmei_pxf@localhost",[[1,12169,"保活"]],[12169,12169],[12171,12171]]],[1520823135000,["gengmei_pxf@localhost",[[1,12173,"\n"]],[12171,12171],[12172,12172]]],[1520823137184,["gengmei_pxf@localhost",[[1,12174,"\n"]],[12172,12172],[12173,12173]]],[1520823150084,["gengmei_pxf@localhost",[[1,12173,"### 黑色"]],[12173,12173],[12179,12179]]],[1520823150870,["gengmei_pxf@localhost",[[1,12181,"\n"]],[12179,12179],[12180,12180]]],[1520823161714,["gengmei_pxf@localhost",[[1,12180,"利用"]],[12180,12180],[12182,12182]]],[1520823190009,["gengmei_pxf@localhost",[[1,12179,"抱活"]],[12179,12179],[12181,12181]]],[1520823217228,["gengmei_pxf@localhost",[[1,12184,"不同App进程相互广播来相互唤醒"]],[12184,12184],[12200,12200]]],[1520823218073,["gengmei_pxf@localhost",[[1,12202,"\n"]],[12200,12200],[12201,12201]]],[1520823218257,["gengmei_pxf@localhost",[[1,12203,"\n"]],[12201,12201],[12202,12202]]],[1520823244539,["gengmei_pxf@localhost",[[1,12202,"### 白色保活"]],[12202,12202],[12210,12210]]],[1520823248855,["gengmei_pxf@localhost",[[-1,12179,"抱"]],[12180,12180],[12179,12179]]],[1520823250203,["gengmei_pxf@localhost",[[1,12179,"保"]],[12179,12179],[12180,12180]]],[1520823252415,["gengmei_pxf@localhost",[[1,12212,"\n"]],[12210,12210],[12211,12211]]],[1520823290186,["gengmei_pxf@localhost",[[1,12211,"调用系统api启动一个前台的Service进程，这样会在系统的通知栏生成一个Notification，用来让用户知道有这样一个app在运行着，哪怕当前的app退到了后台。"]],[12211,12211],[12296,12296]]],[1520823305613,["gengmei_pxf@localhost",[[1,12298,"\n"]],[12296,12296],[12297,12297]]],[1520823306093,["gengmei_pxf@localhost",[[1,12299,"\n"]],[12297,12297],[12298,12298]]],[1520823311744,["gengmei_pxf@localhost",[[1,12298,"### 灰色保活"]],[12298,12298],[12306,12306]]],[1520823312109,["gengmei_pxf@localhost",[[1,12308,"\n"]],[12306,12306],[12307,12307]]],[1520823362248,["gengmei_pxf@localhost",[[1,12307,"灰色保活，这种保活手段是应用范围最广泛。它是利用系统的漏洞来启动一个前台的Service进程，与普通的启动方式区别在于，它不会在系统通知栏处出现一个Notification，看起来就如同运行着一个后台Service进程一样。这样做带来的好处就是，用户无法察觉到你运行着一个前台进程（因为看不到Notification）,但你的进程优先级又是高于普通后台进程的。\n\n作者：D_clock爱吃葱花\n链接：https://www.jianshu.com/p/63aafe3c12af\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[12307,12307],[12586,12586]]],[1520823367220,["gengmei_pxf@localhost",[[-1,12489,"作者：D_clock爱吃葱花\n链接：https://www.jianshu.com/p/63aafe3c12af\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[12489,12586],[12489,12489]]],[1520823368892,["gengmei_pxf@localhost",[[-1,12490,"\n"]],[12489,12489],[12488,12488]]],[1520823438313,["gengmei_pxf@localhost",[[1,12202,"\n"]],[12200,12200],[12201,12201]]],[1520823438497,["gengmei_pxf@localhost",[[1,12203,"\n"]],[12201,12201],[12202,12202]]],[1520823438853,["gengmei_pxf@localhost",[[1,12202,"**场景1**：开机，网络切换、拍照、拍视频时候，利用系统产生的广播唤醒app\n\n**场景2**：接入第三方SDK也会唤醒相应的app进程，如微信sdk会唤醒微信，支付宝sdk会唤醒支付宝。由此发散开去，就会直接触发了下面的 **场景3**\n\n**场景3**：假如你手机里装了支付宝、淘宝、天猫、UC等阿里系的app，那么你打开任意一个阿里系的app后，有可能就顺便把其他阿里系的app给唤醒了。（只是拿阿里打个比方，其实BAT系都差不多）\n\n作者：D_clock爱吃葱花\n链接：https://www.jianshu.com/p/63aafe3c12af\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[12202,12202],[12521,12521]]],[1520823511425,["gengmei_pxf@localhost",[[1,12424,"针对**场景1**，估计Google已经开始意识到这些问题，所以在最新的Android N取消了 ACTION_NEW_PICTURE（拍照），ACTION_NEW_VIDEO（拍视频），CONNECTIVITY_ACTION（网络切换）等三种广播，无疑给了很多app沉重的打击。我猜他们的心情是下面这样的\n\n![](//upload-images.jianshu.io/upload_images/912181-2904dab833d2f189.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/260)\n\n而开机广播的话，记得有一些定制ROM的厂商早已经将其去掉。\n\n针对**场景2**和**场景3**，因为调用SDK唤醒app进程属于正常行为，此处不讨论。但是在借助LBE分析app之间的唤醒路径的时候，发现了两个问题：\n\n1.  很多推送SDK也存在唤醒app的功能\n2.  app之间的唤醒路径真是多，且错综复杂\n\n"]],[12424,12521],[12959,12959]]],[1520823517486,["gengmei_pxf@localhost",[[-1,12862,"作者：D_clock爱吃葱花\n链接：https://www.jianshu.com/p/63aafe3c12af\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[12862,12959],[12862,12862]]],[1520823517934,["gengmei_pxf@localhost",[[-1,12863,"\n"]],[12862,12862],[12861,12861]]],[1520823518406,["gengmei_pxf@localhost",[[-1,12862,"\n"]],[12861,12861],[12860,12860]]],[1520823549044,["gengmei_pxf@localhost",[[-1,12564,"我猜他们的心情是下面这样的\n\n![](//upload-images.jianshu.io/upload_images/912181-2904dab833d2f189.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/260)"]],[12564,12702],[12564,12564]]],[1520823763539,["gengmei_pxf@localhost",[[1,12818,"QQ音乐"]],[12818,12818],[12822,12822]]],[1520823768708,["gengmei_pxf@localhost",[[1,12822,"就是这样。"]],[12822,12822],[12827,12827]]],[1520823844966,["gengmei_pxf@localhost",[[1,13021,"\n"]],[13019,13019],[13020,13020]]],[1520823845483,["gengmei_pxf@localhost",[[1,13020,"那么如何利用系统的漏洞呢，大致的实现思路和代码如下：\n\n*   思路一：API < 18，启动前台Service时直接传入new Notification()；\n*   思路二：API >= 18，同时启动两个id相同的前台Service，然后再将后启动的Service做stop处理；\n\n```\n\npublic class GrayService extends Service {\n\n    private final static int GRAY_SERVICE_ID = 1001;\n\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        if (Build.VERSION.SDK_INT < 18) {\n            startForeground(GRAY_SERVICE_ID, new Notification());//API < 18 ，此方法能有效隐藏Notification上的图标\n        } else {\n            Intent innerIntent = new Intent(this, GrayInnerService.class);\n            startService(innerIntent);\n            startForeground(GRAY_SERVICE_ID, new Notification());\n        }\n\n        return super.onStartCommand(intent, flags, startId);\n    }\n\n    ...\n    ...\n\n    /**\n     * 给 API >= 18 的平台上用的灰色保活手段\n     */\n    public static class GrayInnerService extends Service {\n\n        @Override\n        public int onStartCommand(Intent intent, int flags, int startId) {\n            startForeground(GRAY_SERVICE_ID, new Notification());\n            stopForeground(true);\n            stopSelf();\n            return super.onStartCommand(intent, flags, startId);\n        }\n\n    }\n}\n```\n\n作者：D_clock爱吃葱花\n链接：https://www.jianshu.com/p/63aafe3c12af\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[13020,13020],[14301,14301]]],[1520823890565,["gengmei_pxf@localhost",[[-1,14204,"作者：D_clock爱吃葱花\n链接：https://www.jianshu.com/p/63aafe3c12af\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[14204,14301],[14204,14204]]],[1520823891037,["gengmei_pxf@localhost",[[-1,14205,"\n"]],[14204,14204],[14203,14203]]],[1520824431683,["gengmei_pxf@localhost",[[1,14205,"\n"]],[14203,14203],[14204,14204]]],[1520824432215,["gengmei_pxf@localhost",[[1,14204,"# Dalvik虚拟机与java虚拟机的区别"]],[14204,14204],[14226,14226]]],[1520824437733,["gengmei_pxf@localhost",[[1,14205,"#"]],[14205,14205],[14206,14206]]],[1520824439378,["gengmei_pxf@localhost",[[1,14229,"\n"]],[14227,14227],[14228,14228]]],[1520824439578,["gengmei_pxf@localhost",[[1,14230,"\n"]],[14228,14228],[14229,14229]]],[1520824448269,["gengmei_pxf@localhost",[[1,14229,"1.java虚拟机运行的是Java字节码，Dalvik虚拟机运行的是Dalvik字节码；传统的Java程序经过编译，生成Java字节码保存在class文件中，java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Dalvik字节码，所有的Dalvik字节码由Java字节码转换而来，并被打包到一个DEX(Dalvik Executable)可执行文件中Dalvik虚拟机通过解释Dex文件来执行这些字节码。\n\n2.Dalvik可执行文件体积更小。SDK中有一个叫dx的工具负责将java字节码转换为Dalvik字节码。\n\n3.java虚拟机与Dalvik虚拟机架构不同。java虚拟机基于栈架构。程序在运行时虚拟机需要频繁的从栈上读取或写入数据。这过程需要更多的指令分派与内存访问次数，会耗费不少CPU时间，对于像手机设备资源有限的设备来说，这是相当大的一笔开销。Dalvik虚拟机基于寄存器架构，数据的访问通过寄存器间直接传递，这样的访问方式比基于栈方式快的多.\n\n作者：CJ死到锅里来\n链接：https://www.jianshu.com/p/923aebd31b65\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[14229,14229],[14771,14771]]],[1520824452755,["gengmei_pxf@localhost",[[-1,14678,"作者：CJ死到锅里来\n链接：https://www.jianshu.com/p/923aebd31b65\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[14678,14771],[14678,14678]]],[1520824453138,["gengmei_pxf@localhost",[[-1,14679,"\n"]],[14678,14678],[14677,14677]]],[1520824453609,["gengmei_pxf@localhost",[[-1,14678,"\n"]],[14677,14677],[14676,14676]]],[1520824457653,["gengmei_pxf@localhost",[[1,14229,"### "]],[14229,14229],[14233,14233]]],[1520824460180,["gengmei_pxf@localhost",[[1,14453,"### "]],[14453,14453],[14457,14457]]],[1520824462387,["gengmei_pxf@localhost",[[1,14513,"### "]],[14513,14513],[14517,14517]]],[1520824472427,["gengmei_pxf@localhost",[[-1,14513,"### "]],[14517,14517],[14513,14513]]],[1520824473962,["gengmei_pxf@localhost",[[1,14513,"* "]],[14513,14513],[14515,14515]]],[1520824476868,["gengmei_pxf@localhost",[[-1,14453,"###"],[1,14456,"*"]],[14453,14456],[14454,14454]]],[1520824480084,["gengmei_pxf@localhost",[[-1,14229,"###"],[1,14232,"*"]],[14229,14232],[14230,14230]]],[1520824766519,["gengmei_pxf@localhost",[[1,14202,"[]"]],[14202,14202],[14204,14204]]],[1520824768100,["gengmei_pxf@localhost",[[-1,14202,"[]"]],[14204,14204],[14202,14202]]],[1520824768740,["gengmei_pxf@localhost",[[1,14204,"\n"]],[14202,14202],[14203,14203]]],[1520824770581,["gengmei_pxf@localhost",[[1,14203,"[]()"]],[14203,14203],[14207,14207]]],[1520824772415,["gengmei_pxf@localhost",[[1,14204,"# [Android 进程保活招式大全](https://segmentfault.com/a/1190000006251859)"]],[14204,14204],[14269,14269]]],[1520824774086,["gengmei_pxf@localhost",[[-1,14204,"# [Android 进程保活招式大全](https://segmentfault.com/a/1190000006251859)"]],[14269,14269],[14204,14204]]],[1520824776896,["gengmei_pxf@localhost",[[1,14203,"# "],[1,14204,"Android 进程保活招式大全"],[1,14206,"https://segmentfault.com/a/1190000006251859"]],[14203,14207],[14268,14268]]],[1520824778453,["gengmei_pxf@localhost",[[-1,14203,"# "]],[14205,14205],[14203,14203]]],[1520824879839,["gengmei_pxf@localhost",[[1,14748,"\n"]],[14746,14746],[14747,14747]]],[1520824880182,["gengmei_pxf@localhost",[[1,14749,"\n"]],[14747,14747],[14748,14748]]],[1520824882368,["gengmei_pxf@localhost",[[1,14748,"## **HttpClient与HttpUrlConnection的区别**"]],[14748,14748],[14786,14786]]],[1520824885022,["gengmei_pxf@localhost",[[-1,14751,"**"]],[14753,14753],[14751,14751]]],[1520824887254,["gengmei_pxf@localhost",[[-1,14782,"**"]],[14784,14784],[14782,14782]]],[1520824888078,["gengmei_pxf@localhost",[[1,14784,"\n"]],[14782,14782],[14783,14783]]],[1520824889143,["gengmei_pxf@localhost",[[1,14785,"\n"]],[14783,14783],[14784,14784]]],[1520824952607,["gengmei_pxf@localhost",[[1,14784,"Volley框架的源码，发现它在HTTP请求的使用上比较有意思，在Android 2.3及以上版本，使用的是HttpURLConnection，而在Android 2.2及以下版本，使用的是HttpClient。"]],[14784,14784],[14890,14890]]],[1520824960494,["gengmei_pxf@localhost",[[-1,14796,"发现它在HTTP请求的使用上比较有意思，"]],[14796,14816],[14796,14796]]],[1520824964109,["gengmei_pxf@localhost",[[1,14872,"\n"]],[14870,14870],[14871,14871]]],[1520824964628,["gengmei_pxf@localhost",[[1,14873,"\n"]],[14871,14871],[14872,14872]]],[1520825002096,["gengmei_pxf@localhost",[[1,14872,"# 哪一种才是最好的？\n\n在Android 2.2版本之前，HttpClient拥有较少的bug，因此使用它是最好的选择。\n\n而在Android 2.3版本及以后，HttpURLConnection则是最佳的选择。它的API简单，体积较小，因而非常适用于Android项目。压缩和缓存机制可以有效地减少网络访问的流量，在提升速度和省电方面也起到了较大的作用。对于新的应用程序应该更加偏向于使用HttpURLConnection，"]],[14872,14872],[15086,15086]]],[1520825006335,["gengmei_pxf@localhost",[[1,14873,"##"]],[14873,14873],[14875,14875]]],[1520825013172,["gengmei_pxf@localhost",[[-1,15087,"，"]],[15088,15088],[15087,15087]]],[1520825014271,["gengmei_pxf@localhost",[[1,15087,"."]],[15087,15087],[15088,15088]]],[1520825014635,["gengmei_pxf@localhost",[[1,15090,"\n"]],[15088,15088],[15089,15089]]],[1520825015843,["gengmei_pxf@localhost",[[1,15091,"\n"]],[15089,15089],[15090,15090]]],[1520825025053,["gengmei_pxf@localhost",[[1,15090,"[Android访问网络，使用HttpURLConnection还是HttpClient？](http://blog.csdn.net/sinyu890807/article/details/12452307)"]],[15090,15090],[15195,15195]]],[1520826140897,["gengmei_pxf@localhost",[[1,15197,"\n"]],[15195,15195],[15196,15196]]],[1520826141087,["gengmei_pxf@localhost",[[1,15198,"\n"]],[15196,15196],[15197,15197]]],[1520826141765,["gengmei_pxf@localhost",[[1,15197,"**三级缓存（各大图片框架都可以扯到这上面来）** \n（1）内存缓存，（2）本地缓存，（3）网络 \n内存：[http://blog.csdn.net/guolin_blog/article/details/9526203](http://blog.csdn.net/guolin_blog/article/details/9526203) \n本地：[http://blog.csdn.net/guolin_blog/article/details/28863651](http://blog.csdn.net/guolin_blog/article/details/28863651)"]],[15197,15197],[15489,15489]]],[1520826145401,["gengmei_pxf@localhost",[[-1,15198,"*"],[-1,15222," "],[1,15223," "],[-1,15245," "],[1,15246," "],[-1,15366," "],[1,15367," "]],[15199,15199],[15198,15198]]],[1520826145928,["gengmei_pxf@localhost",[[-1,15197,"*"]],[15198,15198],[15197,15197]]],[1520826147559,["gengmei_pxf@localhost",[[1,15197,"## "]],[15197,15197],[15200,15200]]],[1520826150151,["gengmei_pxf@localhost",[[-1,15220,"）**"]],[15223,15223],[15220,15220]]],[1520826151177,["gengmei_pxf@localhost",[[1,15220,"）**"]],[15220,15220],[15223,15223]]],[1520826152098,["gengmei_pxf@localhost",[[-1,15221,"**"]],[15223,15223],[15221,15221]]],[1520826160455,["gengmei_pxf@localhost",[[1,15249,"\n"]],[15249,15249],[15250,15250]]],[1520826162695,["gengmei_pxf@localhost",[[1,15366,"\n"]],[15366,15366],[15367,15367]]],[1520826164137,["gengmei_pxf@localhost",[[1,15367,"shi"]],[15367,15367],[15370,15370]]],[1520826165039,["gengmei_pxf@localhost",[[-1,15367,"shi"]],[15370,15370],[15367,15367]]],[1520826222961,["gengmei_pxf@localhost",[[1,15367,"内存缓存使用的是LruCache"]],[15367,15367],[15383,15383]]],[1520826228346,["gengmei_pxf@localhost",[[1,15375,"**"]],[15375,15375],[15377,15377]]],[1520826230801,["gengmei_pxf@localhost",[[1,15385,"&"]],[15385,15385],[15386,15386]]],[1520826231486,["gengmei_pxf@localhost",[[-1,15385,"&"]],[15386,15386],[15385,15385]]],[1520826232033,["gengmei_pxf@localhost",[[1,15385,"**"]],[15385,15385],[15387,15387]]],[1520826237453,["gengmei_pxf@localhost",[[1,15387,"\n"]],[15387,15387],[15388,15388]]],[1520826241504,["gengmei_pxf@localhost",[[1,15246,"* "]],[15246,15246],[15248,15248]]],[1520826243863,["gengmei_pxf@localhost",[[1,15392,"* "]],[15392,15392],[15394,15394]]],[1520827031922,["gengmei_pxf@localhost",[[1,15517,"\n"]],[15515,15515],[15516,15516]]],[1520827040020,["gengmei_pxf@localhost",[[1,15516,"本地缓存使用的是****"]],[15516,15516],[15528,15528]]],[1520827041277,["gengmei_pxf@localhost",[[1,15526," \n\n# [Android DiskLruCache](http://blog.csdn.net/sinyu890807/article/details/28863651)"]],[15526,15526],[15612,15612]]],[1520827047073,["gengmei_pxf@localhost",[[-1,15526," "],[1,15527," "],[-1,15529,"# ["]],[15529,15532],[15529,15529]]],[1520827050665,["gengmei_pxf@localhost",[[-1,15549,"](http://blog.csdn.net/sinyu890807/article/details/28863651)"]],[15549,15609],[15549,15549]]],[1520827052745,["gengmei_pxf@localhost",[[-1,15528,"\n"]],[15529,15529],[15528,15528]]],[1520827053297,["gengmei_pxf@localhost",[[-1,15527,"\n"]],[15528,15528],[15527,15527]]],[1520827055329,["gengmei_pxf@localhost",[[-1,15527,"A"]],[15528,15528],[15527,15527]]],[1520827056184,["gengmei_pxf@localhost",[[1,15527,"A"]],[15527,15527],[15528,15528]]],[1520827057048,["gengmei_pxf@localhost",[[-1,15526," "]],[15527,15527],[15526,15526]]],[1520835135582,["gengmei_pxf@localhost",[[1,15550,"\n"]],[15549,15549],[15550,15550]]],[1520835135846,["gengmei_pxf@localhost",[[1,15551,"\n"]],[15550,15550],[15551,15551]]],[1520835138648,["gengmei_pxf@localhost",[[1,15550,"## RecyclerView"]],[15550,15550],[15565,15565]]],[1520835139316,["gengmei_pxf@localhost",[[1,15567,"\n"]],[15565,15565],[15566,15566]]],[1520835161342,["gengmei_pxf@localhost",[[1,15566,"有了ListView、GridView为什么还需要RecyclerView这样的控件呢？整体上看RecyclerView架构，提供了一种插拔式的体验，高度的解耦，异常的灵活，通过设置它提供的不同LayoutManager，ItemDecoration , ItemAnimator实现令人瞠目的效果。\n\n*   你想要控制其显示的方式，请通过布局管理器LayoutManager\n*   你想要控制Item间的间隔（可绘制），请通过ItemDecoration\n*   你想要控制Item增删的动画，请通过ItemAnimator\n*   你想要控制点击、长按事件，请自己写（擦，这点尼玛。）"]],[15566,15566],[15862,15862]]],[1520836704481,["gengmei_pxf@localhost",[[1,15864,"\n"]],[15862,15862],[15863,15863]]],[1520836704943,["gengmei_pxf@localhost",[[1,15865,"\n"]],[15863,15863],[15864,15864]]],[1520836706917,["gengmei_pxf@localhost",[[1,15864,"## # 多个进程同时调用一个ContentProvider的query获取数据，ContentPrvoider是如何反应的呢？"]],[15864,15864],[15928,15928]]],[1520836709057,["gengmei_pxf@localhost",[[-1,15867,"# "]],[15869,15869],[15867,15867]]],[1520836711089,["gengmei_pxf@localhost",[[1,15928,"\n"]],[15926,15926],[15927,15927]]],[1520836722044,["gengmei_pxf@localhost",[[1,15927,"一个content provider可以接受来自另外一个进程的数据请求。尽管ContentResolver与ContentProvider类隐藏了实现细节，但是ContentProvider所提供的query()，insert()，delete()，update()都是在ContentProvider进程的线程池中被调用执行的，而不是进程的主线程中。这个线程池是有Binder创建和维护的，其实使用的就是每个应用进程中的Binder线程池。\n\n作者：咖喱配胡椒\n链接：https://www.jianshu.com/p/813dad80002a\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[15927,15927],[16241,16241]]],[1520836726382,["gengmei_pxf@localhost",[[-1,16150,"作者：咖喱配胡椒\n链接：https://www.jianshu.com/p/813dad80002a\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n"]],[16150,16242],[16150,16150]]],[1520836777911,["gengmei_pxf@localhost",[[1,16151,"\n"]],[16148,16148],[16149,16149]]],[1520836778753,["gengmei_pxf@localhost",[[1,16152,"\n"]],[16149,16149],[16150,16150]]],[1520836848394,["gengmei_pxf@localhost",[[1,16150,"# Android设计ContentProvider的目的是什么？\n\n*   1.  隐藏数据的实现方式，对外提供统一的数据访问接口；\n*   1.  更好的数据访问权限管理。ContentProvider可以对开发的数据进行权限设置，不同的URI可以对应不同的权限，只有符合权限要求的组件才能访问到ContentProvider的具体操作。\n*   1.  ContentProvider封装了跨进程共享的逻辑，我们只需要Uri即可访问数据。由系统来管理ContentProvider的创建、生命周期及访问的线程分配，简化我们在应用间共享数据（进程间通信）的方式。我们只管通过ContentResolver访问ContentProvider所提示的数据接口，而不需要担心它所在进程是启动还是未启动\n\n作者：咖喱配胡椒\n链接：https://www.jianshu.com/p/813dad80002a\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[16150,16150],[16592,16592]]],[1520836851033,["gengmei_pxf@localhost",[[1,16151,"#"]],[16150,16150],[16151,16151]]],[1520836983465,["gengmei_pxf@localhost",[[1,16502,"# 运行在主线程的ContentProvider为什么不会影响主线程的UI操作?\n\n*   1.  ContentProvider的onCreate()是运行在UI线程的，而query()，insert()，delete()，update()是运行在线程池中的工作线程的，所以调用这向个方法并不会阻塞ContentProvider所在进程的主线程，但可能会阻塞调用者所在的进程的UI线程！\n*   1.  所以，调用ContentProvider的操作仍然要放在子线程中去做。虽然直接的CRUD的操作是在工作线程的，但系统会让你的调用线程等待这个异步的操作完成，你才可以继续线程之前的工作。\n\n"],[-1,16593,"\n"]],[16502,16594],[16890,16890]]],[1520836987011,["gengmei_pxf@localhost",[[-1,16799,"作者：咖喱配胡椒\n链接：https://www.jianshu.com/p/813dad80002a\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[16799,16890],[16799,16799]]],[1520836987483,["gengmei_pxf@localhost",[[-1,16800,"\n"]],[16799,16799],[16798,16798]]],[1520836987867,["gengmei_pxf@localhost",[[-1,16799,"\n"]],[16798,16798],[16797,16797]]],[1520836994318,["gengmei_pxf@localhost",[[1,16503,"#"]],[16502,16502],[16503,16503]]],[1520837054399,["gengmei_pxf@localhost",[[1,16800,"\n"]],[16798,16798],[16799,16799]]],[1520837054919,["gengmei_pxf@localhost",[[1,16801,"\n"]],[16799,16799],[16800,16800]]],[1520837055556,["gengmei_pxf@localhost",[[1,16800,"# synchronized函数和synchronized代码块的区别\n\n*   1.  首先synchronized函数和synchronized代码快的作用范围有区别，synchronized函数一般锁定的是当前类对象，synchronized代码块锁定作用域可以选择是本对象，也可以是字符串等等.\n*   1.  当前类对象锁没有释放的时候，本类的所有synchronized(this)同步代码块都阻塞。如果有并发请求synchronized函数，同一时间只能有一个请求执行 .\n*   1.  但是当前类对象锁没有释放的时候，其他请求可以访问本类中不带synchronized(this)的代码块，也可以访问非同一把锁的代码块例如synchronized(Str)等.\n*   1.  由于作用范围有区别，一般作用范围越小执行效率越高，平时开发中一般选择作用范围较小的synchronized.\n\n作者：咖喱配胡椒\n链接：https://www.jianshu.com/p/813dad80002a\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[16800,16800],[17295,17295]]],[1520837057931,["gengmei_pxf@localhost",[[1,16801,"#"]],[16801,16801],[16802,16802]]],[1520837062488,["gengmei_pxf@localhost",[[-1,17205,"作者：咖喱配胡椒\n链接：https://www.jianshu.com/p/813dad80002a\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[17205,17296],[17205,17205]]],[1520839155626,["gengmei_pxf@localhost",[[1,17205,"## Android中Service是否是区别于Activity的进程还是在你应用中的进程?"]],[17205,17205],[17251,17251]]],[1520839157446,["gengmei_pxf@localhost",[[1,17253,"\n"]],[17251,17251],[17252,17252]]],[1520839158543,["gengmei_pxf@localhost",[[1,17254,"\n"]],[17252,17252],[17253,17253]]],[1520839164066,["gengmei_pxf@localhost",[[1,17253,"本地进程"]],[17253,17253],[17257,17257]]],[1520839166527,["gengmei_pxf@localhost",[[-1,17255,"进程"]],[17257,17257],[17255,17255]]],[1520839169353,["gengmei_pxf@localhost",[[1,17255,"Service"]],[17255,17255],[17262,17262]]],[1520839189577,["gengmei_pxf@localhost",[[1,17255,"服务(Local "],[1,17262,")"]],[17253,17262],[17272,17272]]],[1520839219557,["gengmei_pxf@localhost",[[1,17274,"\n"]],[17272,17272],[17273,17273]]],[1520839220588,["gengmei_pxf@localhost",[[1,17275,"\n"]],[17273,17273],[17274,17274]]],[1520839221059,["gengmei_pxf@localhost",[[1,17274,"| 类别 | 区别 | 优点 | 缺点 | 应用 |\n| --- | --- | --- | --- | --- |\n| 本地服务(Local Service) | 该服务依附在主进程上 | 服务依附在主进程上而不是独立的进程，这样在一定程度上节约了资源，另外Local服务因为是在同一进程因此不需要IPC，也不需要AIDL。相应`bindService会`方便很多。 | 主进程被Kill后，服务便会终止。 | 如：音乐播放器播放等不需要常驻的服务。 |\n| 远程服务(Remote Service) | 该服务是独立的进程 | 服务为独立的进程，对应进程名格式为所在包名加上你指定的`android:process`字符串。由于是独立的进程，因此在Activity所在进程被Kill的时候，该服务依然在运行，不受其他进程影响，有利于为多个进程提供服务具有较高的灵活性。 | 该服务是独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。 | 一些提供系统服务的Service，这种Service是常驻的。 |\n\n作者：紫豪\n链接：https://www.jianshu.com/p/1e49e93c3ec8\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[17274,17274],[17827,17827]]],[1520839238354,["gengmei_pxf@localhost",[[1,17274,"\n"]],[17272,17272],[17273,17273]]],[1520839238844,["gengmei_pxf@localhost",[[1,17275,"\n"]],[17273,17273],[17274,17274]]],[1520839252604,["gengmei_pxf@localhost",[[1,17275,"| A0 | B0 | C0 | D0 | E0 |\n|---|---|---|---|---|\n| A1 | B1 | C1 | D1 | E1 |\n\n\n"]],[17274,17274],[17352,17352]]],[1520839260603,["gengmei_pxf@localhost",[[-1,17275,"| A0 | B0 | C0 | D0 | E0 |\n|---|---|---|---|---|\n| A1 | B1 | C1 | D1 | E1 |\n\n\n"]],[17352,17352],[17274,17274]]],[1520839266890,["gengmei_pxf@localhost",[[1,17275,"| A0 | B0 | C0 | D0 | E0 |\n|---|---|---|---|---|\n| A1 | B1 | C1 | D1 | E1 |\n| A2 | B2 | C2 | D2 | E2 |\n\n\n"]],[17274,17274],[17379,17379]]],[1520839269732,["gengmei_pxf@localhost",[[-1,17380,"\n"]],[17379,17379],[17378,17378]]],[1520839274876,["gengmei_pxf@localhost",[[-1,17277,"A0"],[1,17279,"类别"]],[17277,17279],[17279,17279]]],[1520839277309,["gengmei_pxf@localhost",[[-1,17282,"B0"],[1,17284,"qu"]],[17282,17284],[17284,17284]]],[1520839277963,["gengmei_pxf@localhost",[[-1,17282,"qu"]],[17284,17284],[17282,17282]]],[1520839279109,["gengmei_pxf@localhost",[[1,17282,"quv"]],[17282,17282],[17285,17285]]],[1520839280123,["gengmei_pxf@localhost",[[-1,17282,"quv"]],[17285,17285],[17282,17282]]],[1520839284182,["gengmei_pxf@localhost",[[1,17282,"区别"]],[17282,17282],[17284,17284]]],[1520839287827,["gengmei_pxf@localhost",[[-1,17287,"C0"],[1,17289,"y"]],[17287,17289],[17287,17288]]],[1520839288089,["gengmei_pxf@localhost",[[1,17288,"o"]],[17287,17288],[17287,17289]]],[1520839288157,["gengmei_pxf@localhost",[[1,17289,"u"]],[17287,17289],[17287,17290]]],[1520839288309,["gengmei_pxf@localhost",[[1,17290,"'d"]],[17287,17290],[17287,17292]]],[1520839288424,["gengmei_pxf@localhost",[[1,17292,"i"]],[17287,17292],[17287,17293]]],[1520839288492,["gengmei_pxf@localhost",[[1,17293,"a"]],[17287,17293],[17287,17294]]],[1520839288701,["gengmei_pxf@localhost",[[1,17294,"n"]],[17287,17294],[17287,17295]]],[1520839289000,["gengmei_pxf@localhost",[[-1,17287,"you'dian"],[1,17295,"有点"]],[17287,17295],[17289,17289]]],[1520839289579,["gengmei_pxf@localhost",[[-1,17287,"有点"]],[17289,17289],[17287,17287]]],[1520839291917,["gengmei_pxf@localhost",[[1,17287,"优点"]],[17287,17287],[17289,17289]]],[1520839294362,["gengmei_pxf@localhost",[[-1,17292,"D0"],[1,17294,"q"]],[17292,17294],[17292,17293]]],[1520839294543,["gengmei_pxf@localhost",[[1,17293,"u"]],[17292,17293],[17292,17294]]],[1520839294656,["gengmei_pxf@localhost",[[1,17294,"e"]],[17292,17294],[17292,17295]]],[1520839294922,["gengmei_pxf@localhost",[[1,17295,"'d"]],[17292,17295],[17292,17297]]],[1520839295058,["gengmei_pxf@localhost",[[1,17297,"i"]],[17292,17297],[17292,17298]]],[1520839295175,["gengmei_pxf@localhost",[[1,17298,"a"]],[17292,17298],[17292,17299]]],[1520839295323,["gengmei_pxf@localhost",[[1,17299,"n"]],[17292,17299],[17292,17300]]],[1520839295526,["gengmei_pxf@localhost",[[-1,17292,"que'dian"],[1,17300,"缺点"]],[17292,17300],[17294,17294]]],[1520839297692,["gengmei_pxf@localhost",[[-1,17297,"E0"],[1,17299,"y"]],[17297,17299],[17297,17298]]],[1520839297889,["gengmei_pxf@localhost",[[1,17298,"i"]],[17297,17298],[17297,17299]]],[1520839297993,["gengmei_pxf@localhost",[[1,17299,"n"]],[17297,17299],[17297,17300]]],[1520839298069,["gengmei_pxf@localhost",[[1,17300,"g"]],[17297,17300],[17297,17301]]],[1520839298310,["gengmei_pxf@localhost",[[1,17301,"'y"]],[17297,17301],[17297,17303]]],[1520839298427,["gengmei_pxf@localhost",[[1,17303,"o"]],[17297,17303],[17297,17304]]],[1520839298543,["gengmei_pxf@localhost",[[1,17304,"n"]],[17297,17304],[17297,17305]]],[1520839298659,["gengmei_pxf@localhost",[[1,17305,"g"]],[17297,17305],[17297,17306]]],[1520839298963,["gengmei_pxf@localhost",[[-1,17297,"ying'yong"],[1,17306,"应用"]],[17297,17306],[17299,17299]]],[1520839303903,["gengmei_pxf@localhost",[[-1,17326,"A1"],[1,17328,"b"]],[17326,17328],[17326,17327]]],[1520839304062,["gengmei_pxf@localhost",[[1,17327,"e"]],[17326,17327],[17326,17328]]],[1520839304160,["gengmei_pxf@localhost",[[1,17328,"n"]],[17326,17328],[17326,17329]]],[1520839304295,["gengmei_pxf@localhost",[[1,17329,"'d"]],[17326,17329],[17326,17331]]],[1520839304428,["gengmei_pxf@localhost",[[1,17331,"i"]],[17326,17331],[17326,17332]]],[1520839304663,["gengmei_pxf@localhost",[[1,17332,"'f"]],[17326,17332],[17326,17334]]],[1520839304812,["gengmei_pxf@localhost",[[1,17334,"u"]],[17326,17334],[17326,17335]]],[1520839305006,["gengmei_pxf@localhost",[[1,17335,"'w"]],[17326,17335],[17326,17337]]],[1520839305178,["gengmei_pxf@localhost",[[1,17337,"u"]],[17326,17337],[17326,17338]]],[1520839305355,["gengmei_pxf@localhost",[[-1,17326,"ben'di'fu'wu"],[1,17338,"本地服务"]],[17326,17338],[17330,17330]]],[1520839311250,["gengmei_pxf@localhost",[[-1,17355,"A2"],[1,17357,"y"]],[17355,17357],[17355,17356]]],[1520839311349,["gengmei_pxf@localhost",[[1,17356,"u"]],[17355,17356],[17355,17357]]],[1520839311487,["gengmei_pxf@localhost",[[1,17357,"a"]],[17355,17357],[17355,17358]]],[1520839311619,["gengmei_pxf@localhost",[[1,17358,"n"]],[17355,17358],[17355,17359]]],[1520839311962,["gengmei_pxf@localhost",[[1,17359,"'c"]],[17355,17359],[17355,17361]]],[1520839313477,["gengmei_pxf@localhost",[[-1,17355,"yuan'c"],[1,17361,"远程服务"]],[17355,17361],[17359,17359]]],[1520839330356,["gengmei_pxf@localhost",[[-1,17333,"B1"],[1,17335,"该服务依附在主进程上"]],[17333,17335],[17343,17343]]],[1520839336411,["gengmei_pxf@localhost",[[-1,17370,"B2"],[1,17372,"该服务是独立的进程"]],[17370,17372],[17379,17379]]],[1520839343195,["gengmei_pxf@localhost",[[-1,17346,"C1"],[1,17348,"服务依附在主进程上而不是独立的进程，这样在一定程度上节约了资源，另外Local服务因为是在同一进程因此不需要IPC，也不需要AIDL。相应`bindService会`方便很多。"]],[17346,17348],[17434,17434]]],[1520839354163,["gengmei_pxf@localhost",[[-1,17437,"D1"],[1,17439,"主进程被Kill后，服务便会终止。 | 如：音乐播放器播放等不需要常驻的服务。"]],[17437,17439],[17476,17476]]],[1520839367690,["gengmei_pxf@localhost",[[-1,17479,"E1"],[1,17481,"如：音乐播放器播放等不需要常驻的服务。"]],[17479,17481],[17498,17498]]],[1520839397473,["gengmei_pxf@localhost",[[-1,17522,"C2"],[1,17524,"服务为独立的进程，对应进程名格式为所在包名加上你指定的`android:process`字符串。由于是独立的进程，因此在Activity所在进程被Kill的时候，该服务依然在运行，不受其他进程影响，有利于为多个进程提供服务具有较高的灵活性。"]],[17522,17524],[17642,17642]]],[1520839405274,["gengmei_pxf@localhost",[[-1,17645,"D2"],[1,17647,"该服务是独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。"]],[17645,17647],[17683,17683]]],[1520839410922,["gengmei_pxf@localhost",[[-1,17686,"E2"],[1,17688," 一些提供系统服务的Service，这种Service是常驻的。"]],[17686,17688],[17718,17718]]],[1520839426470,["gengmei_pxf@localhost",[[-1,17723,"| 类别 | 区别 | 优点 | 缺点 | 应用 |\n| --- | --- | --- | --- | --- |\n| 本地服务(Local Service) | 该服务依附在主进程上 | 服务依附在主进程上而不是独立的进程，这样在一定程度上节约了资源，另外Local服务因为是在同一进程因此不需要IPC，也不需要AIDL。相应`bindService会`方便很多。 | 主进程被Kill后，服务便会终止。 | 如：音乐播放器播放等不需要常驻的服务。 |\n| 远程服务(Remote Service) | 该服务是独立的进程 | 服务为独立的进程，对应进程名格式为所在包名加上你指定的`android:process`字符串。由于是独立的进程，因此在Activity所在进程被Kill的时候，该服务依然在运行，不受其他进程影响，有利于为多个进程提供服务具有较高的灵活性。 | 该服务是独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。 | 一些提供系统服务的Service，这种Service是常驻的。 |\n\n作者：紫豪\n链接：https://www.jianshu.com/p/1e49e93c3ec8\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[17723,18276],[17723,17723]]],[1520839427060,["gengmei_pxf@localhost",[[-1,17724,"\n"]],[17723,17723],[17722,17722]]],[1520839427405,["gengmei_pxf@localhost",[[-1,17723,"\n"]],[17722,17722],[17721,17721]]],[1520839470796,["gengmei_pxf@localhost",[[-1,17253,"本地服务(Local Service)\n"]],[17253,17273],[17253,17253]]],[1520839471148,["gengmei_pxf@localhost",[[-1,17254,"\n"]],[17253,17253],[17252,17252]]],[1520839471844,["gengmei_pxf@localhost",[[-1,17253,"\n"]],[17252,17252],[17251,17251]]],[1520844013661,["gengmei_pxf@localhost",[[1,17701,"\n"]],[17700,17700],[17701,17701]]],[1520844016873,["gengmei_pxf@localhost",[[1,17700,"## Android你对AMS和WMS理解"]],[17700,17700],[17721,17721]]],[1520844020663,["gengmei_pxf@localhost",[[-1,17710,"你对"],[1,17712,"d"]],[17710,17712],[17710,17711]]],[1520844021177,["gengmei_pxf@localhost",[[-1,17710,"d"],[1,17711,"的"]],[17710,17711],[17711,17711]]],[1520844025119,["gengmei_pxf@localhost",[[1,17722,"\n"]],[17720,17720],[17721,17721]]],[1520848092311,["gengmei_pxf@localhost",[[1,17723,"\n"]],[17720,17720],[17721,17721]]],[1520849672232,["gengmei_pxf@localhost",[[1,17722,"## Android逆向\n\n*   Android中如果函数内的方法需要被更改，你是如何做的呢？ \n    在和面试官大哥交谈（此大哥真的很好，如果不是面试官该多好，风趣幽默）。发现自己确实在最基本的还是基础不是太扎实。我并没有很好的答出来，面试大哥给我解惑了，直接进行使用汇编在此处进行使用跳转语句修改后，再跳回来。当然我听到这个是懵逼的，好好运行的程序怎么可能让你直接用汇编操作，后来面试大哥告诉我有一个框架已经实现了（当然面试大哥也是有能力开发出次框架）后来很开心可以加到面试大哥微信。这里推荐大家看下大哥给我推荐的两篇文章。 \n    [Android中的so注入(inject)和挂钩(hook) - For both x86 and arm](http://blog.csdn.net/jinzhuojun/article/details/9900105) \n    [看雪论坛上 inline hook的实现原理](https://bbs.pediy.com/thread-180918.htm) \n    [看雪牛人放出的：libinject](https://bbs.pediy.com/thread-141355.htm)\n\n*   可以给我说一下 大端和小端（Big endian and Little endian）嘛？ \n    [详细资料：来自网上](https://www.cnblogs.com/luxiaoxun/archive/2012/09/05/2671697.html)"]],[17722,17722],[18378,18378]]],[1520849685182,["gengmei_pxf@localhost",[[-1,17770," "],[1,17771," "],[-1,17776,"在和面试官大哥交谈（此大哥真的很好，如果不是面试官该多好，风趣幽默）。发现自己确实在最基本的还是基础不是太扎实。我并没有很好的答出来，面试大哥给我解惑了，"],[-1,17988," "],[1,17989," "],[-1,18106," "],[1,18107," "],[-1,18177," "],[1,18178," "],[-1,18294," "],[1,18295," "]],[17776,17853],[17776,17776]]],[1520849687021,["gengmei_pxf@localhost",[[-1,17772,"    "]],[17776,17776],[17772,17772]]],[1520849688420,["gengmei_pxf@localhost",[[1,17772,"\n"]],[17772,17772],[17773,17773]]],[1520849702316,["gengmei_pxf@localhost",[[-1,17801,"当然我听到这个是懵逼的，好好运行的程序怎么可能让你直接用汇编操作，后来面试大哥告诉我"]],[17801,17843],[17801,17801]]],[1520849703963,["gengmei_pxf@localhost",[[1,17801,"当然我听到这个是懵逼的，好好运行的程序怎么可能让你直接用汇编操作，后来面试大哥告诉我"]],[17801,17801],[17801,17843]]],[1520849709022,["gengmei_pxf@localhost",[[-1,17801,"当然我听到这个是懵逼的，"]],[17801,17813],[17801,17801]]],[1520849717644,["gengmei_pxf@localhost",[[-1,17822,"后来面试大哥告诉我"]],[17822,17831],[17822,17822]]],[1520849725083,["gengmei_pxf@localhost",[[-1,17832,"（当然面试大哥也是有能力开发出次框架）后来很开心可以加到面试大哥微信。这里推荐大家看下大哥给我推荐的两篇文章。"]],[17832,17887],[17832,17832]]],[1520849726152,["gengmei_pxf@localhost",[[1,17832,"。"]],[17832,17832],[17833,17833]]],[1520849738669,["gengmei_pxf@localhost",[[-1,18144," [详细资料：来自网上]"]],[18145,18156],[18144,18144]]],[1520849750558,["gengmei_pxf@localhost",[[1,18144,"# [大端和小端（Big endian and Little endian）]"],[-1,18149,"s"]],[18144,18211],[18249,18249]]],[1520849753819,["gengmei_pxf@localhost",[[-1,18141,"   #"]],[18145,18145],[18141,18141]]],[1520849754947,["gengmei_pxf@localhost",[[-1,18140,"\n"]],[18141,18141],[18140,18140]]],[1520849756890,["gengmei_pxf@localhost",[[1,18141,"\n"]],[18141,18141],[18142,18142]]],[1520849768116,["gengmei_pxf@localhost",[[-1,17835,"   "]],[17838,17838],[17835,17835]]],[1520849769492,["gengmei_pxf@localhost",[[1,17835,"1."]],[17835,17835],[17837,17837]]],[1520849771561,["gengmei_pxf@localhost",[[-1,17835,"1."]],[17837,17837],[17835,17835]]],[1520849775590,["gengmei_pxf@localhost",[[1,17836,"   *"]],[17835,17835],[17839,17839]]],[1520849783100,["gengmei_pxf@localhost",[[1,17838,"   "]],[17838,17838],[17841,17841]]],[1520849784809,["gengmei_pxf@localhost",[[-1,17838,"   "]],[17841,17841],[17838,17838]]],[1520849788370,["gengmei_pxf@localhost",[[-1,17835,"   * "]],[17839,17839],[17835,17835]]],[1520849791625,["gengmei_pxf@localhost",[[-1,17949,"    "]],[17949,17953],[17949,17949]]],[1520849794553,["gengmei_pxf@localhost",[[-1,18016,"    "]],[18016,18020],[18016,18016]]],[1520849866329,["gengmei_pxf@localhost",[[1,18235,"\n"]],[18233,18233],[18234,18234]]],[1520849866681,["gengmei_pxf@localhost",[[1,18236,"\n"]],[18234,18234],[18235,18235]]],[1520849867358,["gengmei_pxf@localhost",[[1,18235,"## Android JNI开发\n\n*   如何捕获在线上服务中SO出现的异常，你是怎么获取奔溃的堆栈信息呢。 \n    这个问题我真的没想过，都是用Application 实现`Thread.UncaughtExceptionHandler`接口做未捕获异常上报。这下在JNI层的so出现异常该怎么做呢，我也是懵逼。 \n    [JNI异常处理](http://blog.csdn.net/xyang81/article/details/45770551)\n\n    **题外话：**\n\n    1.  [JNI/NDK的开发指南的专栏](http://blog.csdn.net/column/details/blogjnindk.html)\n    2.  [NDK-Stack定位crash](http://blog.csdn.net/a568478312/article/details/78182422)\n*   ENV是几级指针 \n    这里要区分 C还是C++了，C是二级指针，而C++中是一级指针\n\n*   adb你会使用吗？说说你经常用的命令？ \n    [ADB的相关命令](https://developer.android.com/studio/command-line/adb.html?hl=zh-cn)\n\n*   你会linux嘛？罗列进程是那个指令？（大家从这个问题，就可以看出我是多么被贬低了吧，心酸 这个我还是能答出来的）\n\n*   Android中如果你声明了一个Activity的class类，但没有在清单文件中声明他，是否可以将其吊起？ 如果不能 有什么方法可以吊起嘛? (相当深啊，我的天 我被问懵逼了，考察的很多呢) \n    面试我的时候，因为考虑当时对方公司性质，真的没往hook上面想，但是我深知这样是可以的，但是没有阅读源码，所以也说不出那个方法可以实现，下来百度了下。 \n    [Android免清单注册吊起Activity](http://blog.csdn.net/qfanmingyiq/article/details/78216446)\n\n## IOS逆向\n\n*   ASO体系并不是这么简单，你确定你开发的是有效的？ \n    我只能说，在我开发出来时候，做了（改机，清keychain，AppStore排名优化，自动启动AppStore,账号登录登出，适配10系统，评论功能，模拟触碰，动态IP池，自动下载和成功后的取消下载）。我只能说我当时做出来是有效的，Apple的策略改变没有，在公司倒闭后 我就没再更深的了解了。这个东西并不是那么容易玩的转的。\n\n*   你除了对arm汇编 了解完 你懂x86汇编嘛？（哎 我一个玩arm平台的 突然问我x86我还是依然懵逼） \n    [X86汇编指令](http://www.cnblogs.com/YukiJohnson/archive/2012/10/27/2741836.html)"]],[18235,18235],[19489,19489]]],[1520849883154,["gengmei_pxf@localhost",[[-1,18290," "],[1,18291," "],[-1,18387,"，我也是懵逼。 "],[1,18395,"。 "],[-1,18656," "],[1,18657," "],[-1,18718," "],[1,18719," "],[-1,18968," "],[1,18969," "],[-1,19049," "],[1,19050," "],[-1,19179," "],[1,19180," "],[-1,19406," "],[1,19407," "]],[18387,18393],[18387,18387]]],[1520849894912,["gengmei_pxf@localhost",[[-1,18822,"（大家从这个问题，就可以看出我是多么被贬低了吧，心酸 这个我还是能答出来的）"]],[18822,18860],[18822,18822]]],[1520849895705,["gengmei_pxf@localhost",[[1,18824,"\n"]],[18822,18822],[18823,18823]]],[1520850208499,["gengmei_pxf@localhost",[[1,18823,"*   ps命令查找与进程相关的PID号"]],[18823,18823],[18843,18843]]],[1520850212270,["gengmei_pxf@localhost",[[1,18845,"\n"]],[18843,18843],[18844,18844]]],[1520850215791,["gengmei_pxf@localhost",[[-1,18823,"*  "]],[18826,18826],[18823,18823]]],[1520850217086,["gengmei_pxf@localhost",[[1,18823,"\n"]],[18823,18823],[18824,18824]]],[1520850225848,["gengmei_pxf@localhost",[[1,18825,"  - "]],[18825,18825],[18829,18829]]],[1520850228622,["gengmei_pxf@localhost",[[-1,18825,"  - "]],[18829,18829],[18825,18825]]],[1520850233257,["gengmei_pxf@localhost",[[1,18825,"   "]],[18825,18825],[18828,18828]]],[1520850237773,["gengmei_pxf@localhost",[[1,18847,"\n"]],[18844,18844],[18845,18845]]],[1520850239247,["gengmei_pxf@localhost",[[1,18845,"\t\t"]],[18845,18845],[18847,18847]]],[1520850240141,["gengmei_pxf@localhost",[[-1,18846,"\t"]],[18847,18847],[18846,18846]]],[1520850256494,["gengmei_pxf@localhost",[[1,18846,"*   杀进程\n\n*   使用kill命令结束进程：kill xxx \n    常用：kill －9 324\n\n*   Linux下还提供了一个killall命令，可以直接使用进程的名字而不是进程标识号 \n    例如：# killall -9 NAME"]],[18846,18846],[18973,18973]]],[1520850268140,["gengmei_pxf@localhost",[[-1,18846,"*   杀进程\n\n*   "],[-1,18880," "],[1,18881," "],[-1,18947," "],[1,18948," "]],[18846,18859],[18846,18846]]],[1520850274572,["gengmei_pxf@localhost",[[-1,18887,"\n\n*   "]],[18887,18893],[18887,18887]]],[1520850276197,["gengmei_pxf@localhost",[[1,18887,"\n"]],[18887,18887],[18888,18888]]],[1520850280594,["gengmei_pxf@localhost",[[1,18888,"\t\t"]],[18888,18888],[18890,18890]]],[1520850281555,["gengmei_pxf@localhost",[[-1,18889,"\t"]],[18890,18890],[18889,18889]]],[1520850286929,["gengmei_pxf@localhost",[[1,18923,"\t     "]],[18923,18923],[18929,18929]]],[1520850312358,["gengmei_pxf@localhost",[[-1,17736,"*"]],[17737,17737],[17736,17736]]],[1520850314069,["gengmei_pxf@localhost",[[1,17736,"### "]],[17736,17736],[17740,17740]]],[1520850316998,["gengmei_pxf@localhost",[[-1,17742," "]],[17740,17740],[17739,17739]]],[1520850319044,["gengmei_pxf@localhost",[[-1,18080,"* "]],[18082,18082],[18080,18080]]],[1520850321440,["gengmei_pxf@localhost",[[1,18080,"###"]],[18080,18080],[18083,18083]]],[1520850327757,["gengmei_pxf@localhost",[[-1,18256,"*"]],[18257,18257],[18256,18256]]],[1520850328836,["gengmei_pxf@localhost",[[1,18256,"###"]],[18256,18256],[18259,18259]]],[1520850335206,["gengmei_pxf@localhost",[[-1,18643,"*"]],[18644,18644],[18643,18643]]],[1520850337072,["gengmei_pxf@localhost",[[1,18643,"###"]],[18643,18643],[18646,18646]]],[1520850339485,["gengmei_pxf@localhost",[[-1,18696,"*"]],[18697,18697],[18696,18696]]],[1520850340529,["gengmei_pxf@localhost",[[1,18696,"###"]],[18696,18696],[18699,18699]]],[1520850342678,["gengmei_pxf@localhost",[[-1,18808,"*"]],[18809,18809],[18808,18808]]],[1520850343553,["gengmei_pxf@localhost",[[1,18808,"###"]],[18808,18808],[18811,18811]]],[1520850347132,["gengmei_pxf@localhost",[[-1,18976,"* "]],[18978,18978],[18976,18976]]],[1520850347548,["gengmei_pxf@localhost",[[-1,18975,"\n"]],[18976,18976],[18975,18975]]],[1520850349359,["gengmei_pxf@localhost",[[1,18975,"###"]],[18975,18975],[18978,18978]]],[1520850353947,["gengmei_pxf@localhost",[[-1,18974,"\n"]],[18974,18974],[18973,18973]]],[1520850358140,["gengmei_pxf@localhost",[[-1,18804,"n)"]],[18806,18806],[18804,18804]]],[1520850360018,["gengmei_pxf@localhost",[[1,18804,"n)"]],[18804,18804],[18806,18806]]],[1520850361556,["gengmei_pxf@localhost",[[-1,18807,"\n"]],[18807,18807],[18806,18806]]],[1520850385563,["gengmei_pxf@localhost",[[-1,19160," "]],[19161,19161],[19160,19160]]],[1520850391506,["gengmei_pxf@localhost",[[-1,19076,"    "]],[19080,19080],[19076,19076]]],[1520850396731,["gengmei_pxf@localhost",[[-1,19153,"   "]],[19156,19156],[19153,19153]]],[1520850406777,["gengmei_pxf@localhost",[[-1,19076,"面试我的时候，因为考虑当时对方公司性质，真的没往hook上面想，但是我深知这样是可以的，但是没有阅读源码，所以也说不出那个方法可以实现，下来百度了下。"]],[19076,19151],[19076,19076]]],[1520850407449,["gengmei_pxf@localhost",[[-1,19075,"\n"]],[19076,19076],[19075,19075]]],[1520850410977,["gengmei_pxf@localhost",[[-1,19049," (相当深啊，我的天 我被问懵逼了，考察的很多呢)  "]],[19049,19076],[19049,19049]]],[1520850417863,["gengmei_pxf@localhost",[[-1,19145,"*"],[1,19146,"###"]],[19145,19146],[19148,19148]]],[1520850421265,["gengmei_pxf@localhost",[[-1,19347,"* "]],[19348,19349],[19347,19347]]],[1520850422276,["gengmei_pxf@localhost",[[1,19347,"###"]],[19347,19347],[19350,19350]]],[1520850424769,["gengmei_pxf@localhost",[[-1,19150," "]],[19151,19151],[19150,19150]]],[1520853773032,["gengmei_pxf@localhost",[[1,19488,"\n"]],[19487,19487],[19488,19488]]],[1520853773199,["gengmei_pxf@localhost",[[1,19489,"\n"]],[19488,19488],[19489,19489]]],[1520853774110,["gengmei_pxf@localhost",[[1,19488,"# final, finally, finalize的区别\n\n*   final 用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承.\n\n*   finally 是异常处理语句结构的一部分，表示总是执行.\n\n*   finalize 是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用."]],[19488,19488],[19700,19700]]],[1520853776266,["gengmei_pxf@localhost",[[1,19489,"#"]],[19489,19489],[19490,19490]]],[1520856389833,["gengmei_pxf@localhost",[[1,9031,"\n"]],[9029,9029],[9030,9030]]],[1520856390961,["gengmei_pxf@localhost",[[1,9032,"\n"]],[9030,9030],[9031,9031]]],[1520856393916,["gengmei_pxf@localhost",[[1,9031,"# 让主线程给子线程发送消息"]],[9031,9031],[9045,9045]]],[1520856396124,["gengmei_pxf@localhost",[[1,9032,"#"]],[9032,9032],[9033,9033]]],[1520856401280,["gengmei_pxf@localhost",[[1,9048,"\n"]],[9046,9046],[9047,9047]]],[1520856401744,["gengmei_pxf@localhost",[[1,9049,"\n"]],[9047,9047],[9048,9048]]],[1520856429528,["gengmei_pxf@localhost",[[1,9048,"## 1、首先我们在Activity中的onCreate方法中开启一个子线程，然后在子线程中进行Looper和Handler的创建等\n\n```\n@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                /**\n                 *  1、创建了Looper对象，然后Looper对象中创建了MessageQueue\n                 *  2、并将当前的Looper对象跟当前的线程（子线程）绑定ThreadLocal\n                 */\n                Looper.prepare();\n\n                /**\n                 * 1、创建Handler对象，然后从当前线程中获取Looper对象，然后获取到MessageQueue对象\n                 */\n                subHandler = new Handler(){\n                    @Override\n                    public void handleMessage(Message msg) {\n                        super.handleMessage(msg);\n                        Toast.makeText(MainActivity.this,msg.obj.toString(),Toast.LENGTH_LONG).show();\n                    }\n                };\n\n                /**\n                 * 1、从当前线程中找到之前创建的Looper对象，然后找到MessageQueue\n                 * 2、开启死循环，遍历消息池中的消息\n                 * 3、当获取到msg的时候，调用这个msg的handler的dispatchMsg方法，让msg执行起来\n                 */\n                Looper.loop();\n                Log.e(\"zxj\",\"loop()方法执行完了\");\n            }\n        }).start();\n    }\n\n```\n\n## 2、然后在点击事件中发送消息\n\n```\npublic void onSendClick(View v){\n    //从消息池中获取一个旧的msg，如果没有，重新创建消息\n    Message message = subHandler.obtainMessage(1, \"我是主线程发送来是消息\");\n    message.sendToTarget();\n}\n\n```\n\n## 3、问题\n\n以上的写法还是存在一些问题的，其实你在运行起来后，点击按钮发送消息后，当你退出当前Activity后，发现上面定义的log日志，没有执行，这就说明，那个子线程一直未执行完，为啥呢？其实就是因为loop()这个方法，因为这个方法就一个死循环的，所以这个方法一直在循环中，从而导致子线程一直没有执行完，最终会导致内存泄露\n\n## 4、解决方法\n\n在子线程中拿到创建的Looper对象(Looper.myLooper()),然后在onDestroy中中止loop方法\n\n```\n@Override\nprotected void onDestroy() {\n    super.onDestroy();\n    if(myLooper != null)\n        myLooper.quit();\n}\n\n```\n\n## 5、最终代码\n\n```\npublic class MainActivity extends AppCompatActivity {\n    private Handler subHandler;//是在子线程中创建的Handler对象\n    private Looper myLooper;//子线程中的Looper对象\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                /**\n                 *  1、创建了Looper对象，然后Looper对象中创建了MessageQueue\n                 *  2、并将当前的Looper对象跟当前的线程（子线程）绑定ThreadLocal\n                 */\n                Looper.prepare();\n\n                /**\n                 * 1、创建Handler对象，然后从当前线程中获取Looper对象，然后获取到MessageQueue对象\n                 */\n                subHandler = new Handler(){\n                    @Override\n                    public void handleMessage(Message msg) {\n                        super.handleMessage(msg);\n                        Toast.makeText(MainActivity.this,msg.obj.toString(),Toast.LENGTH_LONG).show();\n                    }\n                };\n\n                //获取当前线程中的Looper对象\n                myLooper = Looper.myLooper();\n\n                /**\n                 * 1、从当前线程中找到之前创建的Looper对象，然后找到MessageQueue\n                 * 2、开启死循环，遍历消息池中的消息\n                 * 3、当获取到msg的时候，调用这个msg的handler的dispatchMsg方法，让msg执行起来\n                 */\n                Looper.loop();\n                Log.e(\"zxj\",\"loop()方法执行完了\");\n            }\n        }).start();\n    }\n\n    public void onSendClick(View v){\n        //从消息池中获取一个旧的msg，如果没有，重新创建消息\n        Message message = subHandler.obtainMessage(1, \"我是主线程发送来是消息\");\n        message.sendToTarget();\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        if(myLooper != null)\n            myLooper.quit();\n    }\n}\n```\n\n作者：itzuo\n链接：https://www.jianshu.com/p/78e7734e9e04\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[9048,9048],[12777,12777]]],[1520856432707,["gengmei_pxf@localhost",[[1,9050,"#"]],[9050,9050],[9051,9051]]],[1520856437170,["gengmei_pxf@localhost",[[1,10340,"#"]],[10340,10340],[10341,10341]]],[1520856440802,["gengmei_pxf@localhost",[[1,10532,"#"]],[10532,10532],[10533,10533]]],[1520856442922,["gengmei_pxf@localhost",[[1,10702,"#"]],[10702,10702],[10703,10703]]],[1520856446098,["gengmei_pxf@localhost",[[1,10899,"#"]],[10899,10899],[10900,10900]]],[1520856451879,["gengmei_pxf@localhost",[[-1,12691,"作者：itzuo\n链接：https://www.jianshu.com/p/78e7734e9e04\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n"]],[12689,12782],[12689,12689]]],[1520856467550,["gengmei_pxf@localhost",[[-1,10896,"\n"]],[10896,10896],[10895,10895]]],[1520857144342,["gengmei_pxf@localhost",[[1,23362,"\n"]],[23360,23360],[23361,23361]]],[1520857144925,["gengmei_pxf@localhost",[[1,23363,"\n"]],[23361,23361],[23362,23362]]],[1520857145513,["gengmei_pxf@localhost",[[1,23362,"# Android 多线程编程的总结"]],[23362,23362],[23380,23380]]],[1520857148977,["gengmei_pxf@localhost",[[1,23363,"#"]],[23363,23363],[23364,23364]]],[1520857153081,["gengmei_pxf@localhost",[[1,23365,"【"]],[23365,23365],[23366,23366]]],[1520857154168,["gengmei_pxf@localhost",[[-1,23365,"【"]],[23366,23366],[23365,23365]]],[1520857155240,["gengmei_pxf@localhost",[[1,23365,"["]],[23365,23365],[23366,23366]]],[1520857158848,["gengmei_pxf@localhost",[[1,23382,"]()"]],[23382,23382],[23385,23385]]],[1520857166248,["gengmei_pxf@localhost",[[1,23384,"https://www.diycode.cc/topics/213"]],[23384,23384],[23417,23417]]],[1520857170052,["gengmei_pxf@localhost",[[1,23420,"\n"]],[23418,23418],[23419,23419]]],[1520857170335,["gengmei_pxf@localhost",[[1,23421,"\n"]],[23419,23419],[23420,23420]]]]],["67b85c3f-ef61-41bf-99d8-4d341a0e7cc7",1520908647456,"简历中的questions\n==\n*   **基础知识 – 四大组件（生命周期，使用场景，如何启动）**\n*   **java基础 – 数据结构，线程，mvc框架**\n*   **通信 – 网络连接（HttpClient，HttpUrlConnetion），Socket**\n*   **数据持久化 – SQLite，SharedPreferences，ContentProvider**\n*   **性能优化 – 布局优化，内存优化，电量优化**\n*   **安全 – 数据加密，代码混淆，WebView/Js调用，https**\n*   **UI– 动画**\n*   **其他 – JNI，AIDL，Handler，Intent等**\n*   **开源框架 – Volley，Gilde，RxJava等（简历上写你会的，用过的）**\n*   **拓展 – Android6.0/7.0/8.0特性，kotlin语言，I/O大会**\n\n## Android中的设计模式\n\n [Android中的设计模式](https://pxfile.github.io/2018/03/08/Android%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/)\n\n1.单例 全局性 减少对象创建，降低系统内存的消耗，减少gc次数和卡顿时间 初始化资源的工具类\n2.创建者模式 创建对象的参数很多且不定，参数个数和类型不确定， AlertDialog glide okhttp\n3.适配器模式 baseAdapter\n4.装饰模式 context\n5.外观模式 contextImple\n6.策略模式 属性动画 插值器\n7.组合模式 view和viewGroup\n8.模板方法 Activity fragment\n9.观察者模式 RxJava\n10.责任链模式 try catch，事件分发机制\n\n##  Android各组件和机制\n\n### [Activity](https://pxfile.github.io/2018/03/08/%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3Activity/)\n\nActivity\n\n#### 1.四大组件中Activity是用的最多也是最基础的，Activity提供窗口来与用户进行交互\n\n#### 2.Android默认会为每一个App应用提供一个task的栈老存放和管理该App所有的Activity task默认的name是该App的包名 也可以在mainfest清单文件中设置Activity的taskAffinity属性来自定义task，但是不建议这样使用，如果别App也设置一样的task，它就可能启动你的Activity，带来各种安全隐患\n\n#### 3.Activity的生命周期 onCreate -> onStart -> onResume -> onPause -> onStop -> onDestroy\n\n正常情况下生命周期的调用\n（1）A页面打开B页面或者切回到桌面 A Activity：onPause -》 onStop，如果B Activity采用了透明主题 则不会调用 onStop\n\n（2）先调用A的onPause再调用B的onResume方法\n\n（3）再回到A页面时，onRestart -》 onStart -》onResume\n\n（4）按返回键时，onPause -》 onStop -》onDestroy\n\n异常情况下在生命周期的调用\n\n（1）资源相关的系统配置发生改变时，Activity被杀死 例如Activity竖屏，突然旋转屏幕，Activity默认会销毁并重新创建\n\nonSaveInstanceState -》 onDestroy   重新创建  onCreate 。。。-》 onDestroy\n\n（2）系统资源不足导致优先级低的Activity被回收\n\nonSaveInstanceState -》 onDestroy   重新创建  onCreate 。。。-》 onDestroy\n\n#### 4.Activity信息保存和恢复\n\n系统会调用onSaveInstanceState来保存当前Activity的状态，这个方法调用的时机是在onStop之前，他和onPause没有既定的时序关系，他即可能在onPause之前调用，也有可能在之后调用，需要强调的是，这个方法只出现在Activity被异常终止的情况下，正常情况下是不会走这个方法的，当我们onSaveInstanceState保存到Bundler对象作为参数传递给onRestoreInstanceState和onCreate方法，因此我们可以通过onRestoreInstanceState和onCreate方法来判断Activity是否被重建。如果被重建了，我们就取出之前的数据恢复，从时序上来说，onRestoreInstanceState的调用时机应该在onStart之后\n\n#### 5.启动模式\n\n（1）定义启动模式的方法\n\nmanifest中声明 \n\n<activity\n            ．．．．．．\n            android:launchMode=\"standard\"\n             >\n           ．．．．．．．\n        </activity>\n\n 使用Intent标志\n\nIntent i = new Intent(this,ＮewActivity.class);\n\t\ti.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\t\tstartActivity(i);\n\n（2）模式类型\n\n**standard** 默认模式\n**singleTop** 当目标Activity位于task栈的栈顶时，直接复用，不会创建新的Activity，否则泽创建新的Activity并添加到task栈中\n**singleTask** 如果目标Activity位于Task栈顶中，则复用，如果没有位于栈顶就将目标Activity之前的Activity移除栈，然后调用，否则就创建新的Activity并添加到栈中\n**singleInstance** 如果目标Activity不存在，创建一个新的task栈添加目标Activity并调用，如果Activity已存在就将Activity所在的task移到前台并调用\n\n###  [Service](https://pxfile.github.io/2018/03/08/Service%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93/)\n\nService 应用程序组件 能够在后台执行耗时较长的操作，并且不提供界面\n\n#### Service分类\n\n##### 按运行分类\n\n* 前台Service \n\nstartForeground 开启前台服务 \n\nstopForeground  移除前台服务\n\n* 后台Service\n\n##### 按使用分类\n\n* 本地服务\n\n运用于应用程序内部实现一些耗时操作，并不占用Activity的线程，而是新开一个线程在后台执行 \n\nContext.startService 启动\n\nContext.stopService 结束\n\n在内部可以调用Service.stopSelf() 或 Service.stopSelfResult()来自己停止。\n\n* 远程服务 \n\n用于应用程序之间，可被其他应用程序复用 例如天气预报，其他应用程序不需要在写这样的服务，调用即可\n\n通过暴露接口供其他应用程序调用\n\n#### Contex.bindService 连接\n\n#### Context.unbinService 断开连接\n\n#### Service生命周期\n\n* onCreate -》 onStartCommand -》 onDestroy\n\n* onCreate -》 onBind =》onUnBind -》onDestroy\n\n#### onStartCommand()方法必须返回一个整数。\n\n* START_NOT_STICKY 杀死了服务，则不会重建服务\n\n* START_STICKY  杀死了服务，则将重建服务并调用onStartCommand()，但不会再次送入上一个intent  这适用于媒体播放器（或类似服务），它们不执行命令，但需要一直运行并随时待命\n\n* START_REDELIVER_INTENT 杀死了服务，则将重建服务并用上一个已送过的intent调用onStartCommand() 适用于那些需要立即恢复工作的活跃服务，比如下载文件\n\n#### start服务\n\n#### bind服务\n\n#### 在mainfest中声明服务\n\n``` \n<manifest ... >\n\t... \n\t<application ... >\n\t <service android:name=\".ExampleService\" /> \n\t... \n\t</application> \n</manifest>\n```\n\n###  [ContentProvider](https://pxfile.github.io/2018/03/08/ContentProvider%E5%AE%9E%E4%BE%8B%E8%AF%A6%E8%A7%A3/)\n\nContentProvider（内容提供者）是Android的四大组件之一，管理android以结构化方式存放的数据，以相对安全的方式封装数据（表）并且提供简易的处理机制和统一的访问接口供**其他程序**调用。　\n\n　　Android的数据存储方式总共有五种，分别是：Shared Preferences、网络存储、文件存储、外储存储、SQLite。但一般这些存储都只是在单独的一个应用程序之中达到一个数据的共享，有时候我们需要操作其他应用程序的一些数据，就会用到ContentProvider。而且Android为常见的一些数据提供了默认的ContentProvider（包括音频、视频、图片和通讯录等）。\n\n　　但注意ContentProvider它也只是一个中间人，真正操作的数据源可能是数据库，也可以是文件、xml或网络等其他存储方式。\n\n###  [BroadcastReceiver](https://pxfile.github.io/2018/03/08/BroadcastReceiver%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/)\n\n广播是一种广泛运用的在应用程序之间传输信息的机制，主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。\n\n　　在实现开机启动服务和网络状态改变、电量变化、短信和来电时通过接收系统的广播让应用程序作出相应的处理。\n\n　　BroadcastReceiver 自身并不实现图形用户界面，但是当它收到某个通知后， BroadcastReceiver 可以通过启动 Service 、启动 Activity 或是 NotificationMananger 提醒用户。\n\n静态注册\n\n在AndroidManifest.xml的application里面定义receiver并设置要接收的action。\n\n``` \n< receiver android:name = \".MyBroadcastReceiver\" > \n < intent-filter android:priority = \"777\" > <action android:name = \"android.provider.Telephony.SMS_RECEIVED\" /> </ intent-filter >  </ receiver > \n```\n动态注册\n在Activity中声明BroadcastReceiver的扩展对象，在onResume中注册，onPause中卸载.\n\n#### 静态注册和动态注册的区别\n \n  　　1、静态注册的广播接收者一经安装就常驻在系统之中，不需要重新启动唤醒接收者；\n　　动态注册的广播接收者随着应用的生命周期，由registerReceiver开始监听，由unregisterReceiver撤销监听，如果应用退出后，没有撤销已经注册的接收者应用应用将会报错。\n\n　　2、当广播接收者通过intent启动一个activity或者service时，如果intent中无法匹配到相应的组件。　\n　　动态注册的广播接收者将会导致应用报错\n　　而静态注册的广播接收者将不会有任何报错，因为自从应用安装完成后，广播接收者跟应用已经脱离了关系。\n\n#### 总结\n\n- 静态广播接收的处理器是由PackageManagerService负责，当手机启动或者新安装了应用的时候，PackageManagerService会扫描手机中所有已安装的APP应用，将AndroidManifest.xml中有关注册广播的信息解析出来，存储至一个全局静态变量当中。\n\n - 动态广播接收的处理器是由ActivityManagerService负责，当APP的服务或者进程起来之后，执行了注册广播接收的代码逻辑，即进行加载，最后会存储在一个另外的全局静态变量中。需要注意的是：\n\n　　 1、 这个并非是一成不变的，当程序被杀死之后，已注册的动态广播接收器也会被移出全局变量，直到下次程序启动，再进行动态广播的注册，当然这里面的顺序也已经变更了一次。\n\n　　 2、这里也并没完整的进行广播的排序，只记录的注册的先后顺序，并未有结合优先级的处理。\n\n - 广播发出的时候，广播接收者接收的顺序如下：\n\n　　１．当广播为**普通广播**时，有如下的接收顺序：\n\n　　无视优先级\n　　动态优先于静态\n　　同优先级的动态广播接收器，**先注册的大于后注册的** 　　同优先级的静态广播接收器，**先扫描的大于后扫描的**　\n\n　　２．如果广播为**有序广播**，那么会将动态广播处理器和静态广播处理器合并在一起处理广播的消息，最终确定广播接收的顺序：　\n\n　　优先级高的先接收　\n　　同优先级的动静态广播接收器，**动态优先于静态** 　　同优先级的动态广播接收器，**先注册的大于后注册的** 　　同优先级的静态广播接收器，**先扫描的大于后扫描的**\n\n#### **广播怎么不跨进程**\n\n无论是使用扩展变量作用域、基于接口的回调还是Handler-post/Handler-Message等方式，都可以直接处理此类问题，若适用广播机制，显然有些“杀鸡牛刀”的感觉，会显太“重”；\n\n##  模块化和组件化开发\n[模块化和组件化开发](https://pxfile.github.io/2018/03/02/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/)\n\n### 模块化\n按照功能划分成相互独立的模块，使其只包含与其相关的功能。登录，搜索，交易，社区等\n### 组件化\n基于可重用的目的，将一个系统按照拆分关注点的形式，拆分成一个的组件，减少解耦\n\n### 模块化vs组件化\n\n模块化和组件化本质思想是一样的,都是”大化小”,两者的目的都是为了重用和解耦,只是叫法不一样.如果非要说区别,那么可以认为模块化粒度更小,更侧重于重用,而组件化粒度稍大于模块,更侧重于业务解耦。\n\n### 优点\n\n*   **1.模块间解耦，复用，避免重复造轮子，节省开发维护成本** 对业务进行模块化拆分后，为了使各业务模块间解耦，因此各个都是独立的模块，它们之间是没有依赖关系。每个模块负责的功能不同，业务逻辑不同，模块间业务解耦。模块功能比较单一，可在多个项目中使用\n\n*   **2.可单独编译某个模块，降低项目复杂性，提升开发效率** 每个模块实际上也是一个完整的项目，可以进行单独编译，调试\n\n*   **3.可以多团队并行开发，测试 多个团队公用同一个组件，在一定层度上确保了技术方案的统一性** 每个团队负责不同的模块，提升开发，测试效率\n\n##  Android开发模式(MVC，MVVM，MVP)\n[浅谈MVC、MVP、MVVM架构模式的区别和联系](http://www.cnblogs.com/guwei4037/p/5591183.html)\n\n### MVC \nView  xml\nController Activity\nModel 建立的数据机构和相关的类\n\n1.View传达指令到Controller\n2.Controller完成业务逻辑后，要求Model改变状态\n3.Model将新的数据发送给View，更新视图，用户得到反馈 \n\nMVC可分为2种 \n\n1.通过View接受指令\n2.通过Controller接受指令\n\n缺点\n\n在Android开发中，Activity并不是一个标准的MVC模式中的Controller，它的首要职责是加载应用的布局和初始化用户界面 ，并接受并处理来自用户的操作请求，进而作出响应。随着界面及其逻辑的复杂度不断提升， Activity类的职责不断增加，以致变得庞大臃肿。\n\n### MVP\n在App开发过程中，经常出现的问题就是某部分的代码过 ，虽然做模块划分和接隔离，但也很难完全避免。从实践中看到，这多的出现在UI部分，也就是Activity 。想象下， 个2000+ 以上基本 带注释的Activity，我的第 反应就是想吐。Activity内容过多的原因其实很好解释，因为Activity本身需要担负 与用户之间的操作交互，界面的展示， 是单纯的Controller或View。 且现在部分的Activity还对整个App 起到类似iOS中的【ViewController】的作 ，这又带入的逻辑代码，造成Activity的臃肿。为 解决这个问题，让我们引MVP框架。\n\n将Controller改成了Presenter，同时改变了通信方向\n1.Presenter和View是可以双向通信的\n2.Presenter和Model也是可以双向通信的\n3.View和Model之间不能通信，都是通过Presenter传递的\n4.View和薄，没有任何业务逻辑，而Presenter很厚，所有的业务逻辑都在这处理\n\n\n\n### MVVM\n将Presenter改成了Viewmodel，通信方式基本和MVP差不多，最大的区别是MVVM有双向绑定，View的变动反映在ViewModel上，ViewModel的修改也会更新View\n\n## 事件分发机制\n[事件分发机制](https://www.jianshu.com/p/38015afcdb58)\n\n![onTouchEvent](https://upload-images.jianshu.io/upload_images/944365-aea821bbb613c195.png)\n\n## Handler机制\n[Handler机制](https://pxfile.github.io/2018/03/08/%E7%B2%BE%E9%80%9AAndroid%E4%B8%8B%E7%9A%84Handler%E6%9C%BA%E5%88%B6/)\n\n![](http://upload-images.jianshu.io/upload_images/1824194-a947dcc5b22f69fb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n*   1.在创建Activity之前，当系统启动的时候，先加载ActivityThread这个类，在这个类中的main函数，调用了Looper.prepareMainLooper()方法进行初始化Looper对象；\n\n*   2.然后创建了主线程的handler对象（Tips：加载ActivityThread的时候，其内部的Handler对象[静态的]还未创建）；\n\n*   3.随后才创建了ActivityThread对象；\n\n*   4.最后调用了Looper.loop();方法，不断的进行轮询消息队列的消息。\n\n*   也就是说，在ActivityThread和Activity创建之前（同样也是Handler创建之前，当然handler由于这两者初始化），就已经开启了Looper的loop()方法，不断的进行轮询消息。\n\n* 需要注意的是，这个轮询的方法是阻塞式的，没有消息就一直等待（实际是等着MessageQueue的next()方法返回消息）。\n\n* 在应用一执行的时候，就已经开启了Looper，并初始化了Handler对象。此时，系统的某些组件或者其他的一些活动等发送了系统级别的消息，这个时候主线程中的Looper就可以进行轮询消息，并调用msg.target.dispatchMessage(msg)（msg.target即为handler）进行分发消息，并通过handler的handleMessage方法进行处理；所以会优于我们自己创建的handler中的消息而处理系统消息。\n\n下面，我们按照启动顺序来进行源码分析：\n\n![](http://upload-images.jianshu.io/upload_images/1824194-298ebb16ce4a3b70.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 让主线程给子线程发送消息\n\n### 1、首先我们在Activity中的onCreate方法中开启一个子线程，然后在子线程中进行Looper和Handler的创建等\n\n```\n@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                /**\n                 *  1、创建了Looper对象，然后Looper对象中创建了MessageQueue\n                 *  2、并将当前的Looper对象跟当前的线程（子线程）绑定ThreadLocal\n                 */\n                Looper.prepare();\n\n                /**\n                 * 1、创建Handler对象，然后从当前线程中获取Looper对象，然后获取到MessageQueue对象\n                 */\n                subHandler = new Handler(){\n                    @Override\n                    public void handleMessage(Message msg) {\n                        super.handleMessage(msg);\n                        Toast.makeText(MainActivity.this,msg.obj.toString(),Toast.LENGTH_LONG).show();\n                    }\n                };\n\n                /**\n                 * 1、从当前线程中找到之前创建的Looper对象，然后找到MessageQueue\n                 * 2、开启死循环，遍历消息池中的消息\n                 * 3、当获取到msg的时候，调用这个msg的handler的dispatchMsg方法，让msg执行起来\n                 */\n                Looper.loop();\n                Log.e(\"zxj\",\"loop()方法执行完了\");\n            }\n        }).start();\n    }\n\n```\n\n### 2、然后在点击事件中发送消息\n\n```\npublic void onSendClick(View v){\n    //从消息池中获取一个旧的msg，如果没有，重新创建消息\n    Message message = subHandler.obtainMessage(1, \"我是主线程发送来是消息\");\n    message.sendToTarget();\n}\n\n```\n\n### 3、问题\n\n以上的写法还是存在一些问题的，其实你在运行起来后，点击按钮发送消息后，当你退出当前Activity后，发现上面定义的log日志，没有执行，这就说明，那个子线程一直未执行完，为啥呢？其实就是因为loop()这个方法，因为这个方法就一个死循环的，所以这个方法一直在循环中，从而导致子线程一直没有执行完，最终会导致内存泄露\n\n### 4、解决方法\n\n在子线程中拿到创建的Looper对象(Looper.myLooper()),然后在onDestroy中中止loop方法\n\n```\n@Override\nprotected void onDestroy() {\n    super.onDestroy();\n    if(myLooper != null)\n        myLooper.quit();\n}\n\n```\n### 5、最终代码\n\n```\npublic class MainActivity extends AppCompatActivity {\n    private Handler subHandler;//是在子线程中创建的Handler对象\n    private Looper myLooper;//子线程中的Looper对象\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                /**\n                 *  1、创建了Looper对象，然后Looper对象中创建了MessageQueue\n                 *  2、并将当前的Looper对象跟当前的线程（子线程）绑定ThreadLocal\n                 */\n                Looper.prepare();\n\n                /**\n                 * 1、创建Handler对象，然后从当前线程中获取Looper对象，然后获取到MessageQueue对象\n                 */\n                subHandler = new Handler(){\n                    @Override\n                    public void handleMessage(Message msg) {\n                        super.handleMessage(msg);\n                        Toast.makeText(MainActivity.this,msg.obj.toString(),Toast.LENGTH_LONG).show();\n                    }\n                };\n\n                //获取当前线程中的Looper对象\n                myLooper = Looper.myLooper();\n\n                /**\n                 * 1、从当前线程中找到之前创建的Looper对象，然后找到MessageQueue\n                 * 2、开启死循环，遍历消息池中的消息\n                 * 3、当获取到msg的时候，调用这个msg的handler的dispatchMsg方法，让msg执行起来\n                 */\n                Looper.loop();\n                Log.e(\"zxj\",\"loop()方法执行完了\");\n            }\n        }).start();\n    }\n\n    public void onSendClick(View v){\n        //从消息池中获取一个旧的msg，如果没有，重新创建消息\n        Message message = subHandler.obtainMessage(1, \"我是主线程发送来是消息\");\n        message.sendToTarget();\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        if(myLooper != null)\n            myLooper.quit();\n    }\n}\n```\n\n## 机型适配\n[机型适配](http://blog.csdn.net/mwq384807683/article/details/72594027)\n\n* **魅族3和魅族4**\n\n场景：魅族手机ListView的Item中的EditText无法编辑，点击EditText弹出软键盘后，软键盘会立即自动隐藏 \n机型：[魅族3，魅族4] \n解决方案： \n方法一：将ListView换成RecyclerView\n\n方法二：[https://github.com/Aspsine/EditTextInListView](https://github.com/Aspsine/EditTextInListView)\n\n* **HTC M8**\n\n场景：HTC M8 从一个Activity 使用QQSDK 登陆, 登陆成功后, 返回Activity结果Activity 被销毁了 \n机型：HTC M8 等某些带有 虚拟 Menu 键盘的手机 \n解决方案：后来调查发现是这个Activity是全屏,屏蔽了Menu键盘的黑条. 但是跳转到QQ却把那个Menu的黑条显示了出来, 这导致发生了 screenSize 的变化 从而导致我的Activity销毁了. \n知道了这个原因, 在manifest中的 configChanges 添加screenSize 解决了这个问题.\n\n* **所有手机**\n\nPopupWindow中嵌套EditText，会出现EditText长按无法触发“粘贴”选项，可以改成Dialog嵌套EditText，包括DialogFragment。\n\n* **所有手机**\n\n场景：输入法中的emoji适配，Android4.1之前的系统不支持emoji显示\n\n解决方案：所以对于Android4.1之前的系统，我采用了bitmap来显示emoji。\n\n* **OPPO 手机**\n\n场景：OPPO 手机启动 Service 报 SecurityException \n解决方案：try catch 该异常\n\n## 性能优化\n [性能优化](https://pxfile.github.io/2018/03/08/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/)\n\n## 内存泄漏\n [内存泄漏](https://pxfile.github.io/2018/02/14/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/)\n\n## Binder机制\n [Binder机制](https://pxfile.github.io/2018/03/07/Binder%E6%9C%BA%E5%88%B6/)\n\n## 混合开发\n[混合开发](https://bxbxbai.github.io/2015/08/16/talk-about-bybird-app/)\n\n## [HTTPS和HTTP的区别](http://blog.csdn.net/whatday/article/details/38147103)\n\n### 什么是 HTTPS?\n\nHTTPS (基于安全套接字层的超文本传输协议 或者是 HTTP over SSL) 是一个 Netscape 开发的 Web 协议。\n\n你也可以说：HTTPS = HTTP + SSL\n\nHTTPS 在 HTTP 应用层的基础上使用安全套接字层作为子层。\n\n### 为什么需要 HTTPS ？\n\n超文本传输协议 (HTTP) 是一个用来通过互联网传输和接收信息的协议。HTTP 使用请求/响应的过程，因此信息可在服务器间快速、轻松而且精确的进行传输。当你访问 Web 页面的时候你就是在使用 HTTP 协议，但 HTTP 是不安全的，可以轻松对窃听你跟 Web 服务器之间的数据传输。在很多情况下，客户和服务器之间传输的是敏感歇息，需要防止未经授权的访问。为了满足这个要求，网景公司(Netscape)推出了[HTTPS](http://www.nowamagic.net/librarys/veda/tag/https)，也就是基于安全套接字层的 HTTP 协议。\n\n### HTTP 和 HTTPS 的相同点\n\n大多数情况下，HTTP 和 HTTPS 是相同的，因为都是采用同一个基础的协议，作为 HTTP 或 HTTPS 客户端——浏览器，设立一个连接到 Web 服务器指定的端口。当服务器接收到请求，它会返回一个状态码以及消息，这个回应可能是请求信息、或者指示某个错误发送的错误信息。系统使用统一资源定位器 URI 模式，因此资源可以被唯一指定。而 HTTPS 和 HTTP 唯一不同的只是一个协议头(https)的说明，其他都是一样的。\n\n### HTTP 和 HTTPS 的不同之处\n\n1.  HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头\n2.  HTTP 是不安全的，而 HTTPS 是安全的\n3.  HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443\n4.  在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层\n5.  HTTP 无需加密，而 HTTPS 对传输的数据进行加密\n6.  HTTP 无需证书，而 HTTPS 需要认证证书\n\n### HTTPS 如何工作?\n\n使用 HTTPS 连接时，服务器要求有公钥和签名的证书。\n\n当使用 https 连接，服务器响应初始连接，并提供它所支持的加密方法。作为回应，客户端选择一个连接方法，并且客户端和服务器端交换证书验证彼此身份。完成之后，在确保使用相同密钥的情况下传输加密信息，然后关闭连接。为了提供 https 连接支持，服务器必须有一个公钥证书，该证书包含经过证书机构认证的密钥信息，大部分证书都是通过第三方机构授权的，以保证证书是安全的。\n\n换句话说，HTTPS 跟 HTTP 一样，只不过增加了 [SSL](http://www.nowamagic.net/librarys/veda/tag/SSL)。\n\nHTTP 包含如下动作：\n\n1.  浏览器打开一个 TCP 连接\n2.  浏览器发送 HTTP 请求到服务器端\n3.  服务器发送 HTTP 回应信息到浏览器\n4.  TCP 连接关闭\n\nSSL 包含如下动作：\n\n1.  验证服务器端\n2.  允许客户端和服务器端选择加密算法和密码，确保双方都支持\n3.  验证客户端(可选)\n4.  使用公钥加密技术来生成共享加密数据\n5.  创建一个加密的 SSL 连接\n6.  基于该 SSL 连接传递 HTTP 请求\n\n### 什么时候该使用 HTTPS?\n\n银行网站、支付网关、购物网站、登录页、电子邮件以及一些企业部门的网站应该使用 HTTPS，例如：\n\n*   PayPal: https://www.paypal.com\n*   Google AdSense: https://www.google.com/adsense/\n\n如果某个网站要求你填写信用卡信息，首先你要检查该网页是否使用 https 加密连接，如果没有，那么请不要输入任何敏感信息如信用卡号。\n\n## 如何有效的减少重复的代码\n\n**一、使用include标签引用重复布局**\n\n**二、使用style定义样式**\n\n**三、使用ViewStub减少整体布局的重复**\n\n**四、多使用应用资源**\n\n**五、代码的抽象与继承**\n\n## Android进程保活\n\n### 黑色保活\n利用不同App进程相互广播来相互唤醒\n\n**场景1**：开机，网络切换、拍照、拍视频时候，利用系统产生的广播唤醒app\n\n**场景2**：接入第三方SDK也会唤醒相应的app进程，如微信sdk会唤醒微信，支付宝sdk会唤醒支付宝。由此发散开去，就会直接触发了下面的 **场景3**\n\n**场景3**：假如你手机里装了支付宝、淘宝、天猫、UC等阿里系的app，那么你打开任意一个阿里系的app后，有可能就顺便把其他阿里系的app给唤醒了。（只是拿阿里打个比方，其实BAT系都差不多）\n\n针对**场景1**，估计Google已经开始意识到这些问题，所以在最新的Android N取消了 ACTION_NEW_PICTURE（拍照），ACTION_NEW_VIDEO（拍视频），CONNECTIVITY_ACTION（网络切换）等三种广播，无疑给了很多app沉重的打击。\n\n而开机广播的话，记得有一些定制ROM的厂商早已经将其去掉。\n\n针对**场景2**和**场景3**，因为调用SDK唤醒app进程属于正常行为，此处不讨论。但是在借助LBE分析app之间的唤醒路径的时候，发现了两个问题：\n\n1.  很多推送SDK也存在唤醒app的功能\n2.  app之间的唤醒路径真是多，且错综复杂\n\n### 白色保活\n调用系统api启动一个前台的Service进程，这样会在系统的通知栏生成一个Notification，用来让用户知道有这样一个app在运行着，哪怕当前的app退到了后台。QQ音乐就是这样。\n\n### 灰色保活\n灰色保活，这种保活手段是应用范围最广泛。它是利用系统的漏洞来启动一个前台的Service进程，与普通的启动方式区别在于，它不会在系统通知栏处出现一个Notification，看起来就如同运行着一个后台Service进程一样。这样做带来的好处就是，用户无法察觉到你运行着一个前台进程（因为看不到Notification）,但你的进程优先级又是高于普通后台进程的。\n\n那么如何利用系统的漏洞呢，大致的实现思路和代码如下：\n\n*   思路一：API < 18，启动前台Service时直接传入new Notification()；\n*   思路二：API >= 18，同时启动两个id相同的前台Service，然后再将后启动的Service做stop处理；\n\n```\n\npublic class GrayService extends Service {\n\n    private final static int GRAY_SERVICE_ID = 1001;\n\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        if (Build.VERSION.SDK_INT < 18) {\n            startForeground(GRAY_SERVICE_ID, new Notification());//API < 18 ，此方法能有效隐藏Notification上的图标\n        } else {\n            Intent innerIntent = new Intent(this, GrayInnerService.class);\n            startService(innerIntent);\n            startForeground(GRAY_SERVICE_ID, new Notification());\n        }\n\n        return super.onStartCommand(intent, flags, startId);\n    }\n\n    ...\n    ...\n\n    /**\n     * 给 API >= 18 的平台上用的灰色保活手段\n     */\n    public static class GrayInnerService extends Service {\n\n        @Override\n        public int onStartCommand(Intent intent, int flags, int startId) {\n            startForeground(GRAY_SERVICE_ID, new Notification());\n            stopForeground(true);\n            stopSelf();\n            return super.onStartCommand(intent, flags, startId);\n        }\n\n    }\n}\n```\n[Android 进程保活招式大全](https://segmentfault.com/a/1190000006251859)\n\n## Dalvik虚拟机与java虚拟机的区别\n\n* 1.java虚拟机运行的是Java字节码，Dalvik虚拟机运行的是Dalvik字节码；传统的Java程序经过编译，生成Java字节码保存在class文件中，java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Dalvik字节码，所有的Dalvik字节码由Java字节码转换而来，并被打包到一个DEX(Dalvik Executable)可执行文件中Dalvik虚拟机通过解释Dex文件来执行这些字节码。\n\n* 2.Dalvik可执行文件体积更小。SDK中有一个叫dx的工具负责将java字节码转换为Dalvik字节码。\n\n* 3.java虚拟机与Dalvik虚拟机架构不同。java虚拟机基于栈架构。程序在运行时虚拟机需要频繁的从栈上读取或写入数据。这过程需要更多的指令分派与内存访问次数，会耗费不少CPU时间，对于像手机设备资源有限的设备来说，这是相当大的一笔开销。Dalvik虚拟机基于寄存器架构，数据的访问通过寄存器间直接传递，这样的访问方式比基于栈方式快的多.\n\n## HttpClient与HttpUrlConnection的区别\n\nVolley框架的源码，在Android 2.3及以上版本，使用的是HttpURLConnection，而在Android 2.2及以下版本，使用的是HttpClient。\n\n### 哪一种才是最好的？\n\n在Android 2.2版本之前，HttpClient拥有较少的bug，因此使用它是最好的选择。\n\n而在Android 2.3版本及以后，HttpURLConnection则是最佳的选择。它的API简单，体积较小，因而非常适用于Android项目。压缩和缓存机制可以有效地减少网络访问的流量，在提升速度和省电方面也起到了较大的作用。对于新的应用程序应该更加偏向于使用HttpURLConnection.\n\n[Android访问网络，使用HttpURLConnection还是HttpClient？](http://blog.csdn.net/sinyu890807/article/details/12452307)\n\n## 三级缓存（各大图片框架都可以扯到这上面来） \n（1）内存缓存，（2）本地缓存，（3）网络 \n* 内存：\n[http://blog.csdn.net/guolin_blog/article/details/9526203](http://blog.csdn.net/guolin_blog/article/details/9526203)\n内存缓存使用的是**LruCache**\n \n* 本地：[http://blog.csdn.net/guolin_blog/article/details/28863651](http://blog.csdn.net/guolin_blog/article/details/28863651)\n本地缓存使用的是**Android DiskLruCache**\n\n## RecyclerView\n有了ListView、GridView为什么还需要RecyclerView这样的控件呢？整体上看RecyclerView架构，提供了一种插拔式的体验，高度的解耦，异常的灵活，通过设置它提供的不同LayoutManager，ItemDecoration , ItemAnimator实现令人瞠目的效果。\n\n*   你想要控制其显示的方式，请通过布局管理器LayoutManager\n*   你想要控制Item间的间隔（可绘制），请通过ItemDecoration\n*   你想要控制Item增删的动画，请通过ItemAnimator\n*   你想要控制点击、长按事件，请自己写（擦，这点尼玛。）\n\n## 多个进程同时调用一个ContentProvider的query获取数据，ContentPrvoider是如何反应的呢？\n一个content provider可以接受来自另外一个进程的数据请求。尽管ContentResolver与ContentProvider类隐藏了实现细节，但是ContentProvider所提供的query()，insert()，delete()，update()都是在ContentProvider进程的线程池中被调用执行的，而不是进程的主线程中。这个线程池是有Binder创建和维护的，其实使用的就是每个应用进程中的Binder线程池。\n\n## Android设计ContentProvider的目的是什么？\n\n*   1.  隐藏数据的实现方式，对外提供统一的数据访问接口；\n*   1.  更好的数据访问权限管理。ContentProvider可以对开发的数据进行权限设置，不同的URI可以对应不同的权限，只有符合权限要求的组件才能访问到ContentProvider的具体操作。\n*   1.  ContentProvider封装了跨进程共享的逻辑，我们只需要Uri即可访问数据。由系统来管理ContentProvider的创建、生命周期及访问的线程分配，简化我们在应用间共享数据（进程间通信）的方式。我们只管通过ContentResolver访问ContentProvider所提示的数据接口，而不需要担心它所在进程是启动还是未启动\n\n## 运行在主线程的ContentProvider为什么不会影响主线程的UI操作?\n\n*   1.  ContentProvider的onCreate()是运行在UI线程的，而query()，insert()，delete()，update()是运行在线程池中的工作线程的，所以调用这向个方法并不会阻塞ContentProvider所在进程的主线程，但可能会阻塞调用者所在的进程的UI线程！\n*   1.  所以，调用ContentProvider的操作仍然要放在子线程中去做。虽然直接的CRUD的操作是在工作线程的，但系统会让你的调用线程等待这个异步的操作完成，你才可以继续线程之前的工作。\n\n## synchronized函数和synchronized代码块的区别\n\n*   1.  首先synchronized函数和synchronized代码快的作用范围有区别，synchronized函数一般锁定的是当前类对象，synchronized代码块锁定作用域可以选择是本对象，也可以是字符串等等.\n*   1.  当前类对象锁没有释放的时候，本类的所有synchronized(this)同步代码块都阻塞。如果有并发请求synchronized函数，同一时间只能有一个请求执行 .\n*   1.  但是当前类对象锁没有释放的时候，其他请求可以访问本类中不带synchronized(this)的代码块，也可以访问非同一把锁的代码块例如synchronized(Str)等.\n*   1.  由于作用范围有区别，一般作用范围越小执行效率越高，平时开发中一般选择作用范围较小的synchronized.\n\n## Android中Service是否是区别于Activity的进程还是在你应用中的进程?\n\n| 类别 | 区别 | 优点 | 缺点 | 应用 |\n|---|---|---|---|---|\n| 本地服务 | 该服务依附在主进程上 | 服务依附在主进程上而不是独立的进程，这样在一定程度上节约了资源，另外Local服务因为是在同一进程因此不需要IPC，也不需要AIDL。相应`bindService会`方便很多。 | 主进程被Kill后，服务便会终止。 | 如：音乐播放器播放等不需要常驻的服务。 | 如：音乐播放器播放等不需要常驻的服务。 |\n| 远程服务 | 该服务是独立的进程 | 服务为独立的进程，对应进程名格式为所在包名加上你指定的`android:process`字符串。由于是独立的进程，因此在Activity所在进程被Kill的时候，该服务依然在运行，不受其他进程影响，有利于为多个进程提供服务具有较高的灵活性。 | 该服务是独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。 |  一些提供系统服务的Service，这种Service是常驻的。 |\n\n## Android的AMS和WMS理解\n\n## Android逆向\n\n###   Android中如果函数内的方法需要被更改，你是如何做的呢？ \n\n直接进行使用汇编在此处进行使用跳转语句修改后，再跳回来。好好运行的程序怎么可能让你直接用汇编操作，有一个框架已经实现了。 \n[Android中的so注入(inject)和挂钩(hook) - For both x86 and arm](http://blog.csdn.net/jinzhuojun/article/details/9900105) \n[看雪论坛上 inline hook的实现原理](https://bbs.pediy.com/thread-180918.htm) \n[看雪牛人放出的：libinject](https://bbs.pediy.com/thread-141355.htm)\n\n###  可以给我说一下 大端和小端（Big endian and Little endian）嘛？  \n[大端和小端（Big endian and Little endian）](http://www.cnblogs.com/luxiaoxun/archive/2012/09/05/2671697.html)\n\n## Android JNI开发\n\n###   如何捕获在线上服务中SO出现的异常，你是怎么获取奔溃的堆栈信息呢。 \n    这个问题我真的没想过，都是用Application 实现`Thread.UncaughtExceptionHandler`接口做未捕获异常上报。这下在JNI层的so出现异常该怎么做呢。 \n    [JNI异常处理](http://blog.csdn.net/xyang81/article/details/45770551)\n\n    **题外话：**\n\n    1.  [JNI/NDK的开发指南的专栏](http://blog.csdn.net/column/details/blogjnindk.html)\n    2.  [NDK-Stack定位crash](http://blog.csdn.net/a568478312/article/details/78182422)\n###   ENV是几级指针 \n    这里要区分 C还是C++了，C是二级指针，而C++中是一级指针\n\n###   adb你会使用吗？说说你经常用的命令？ \n    [ADB的相关命令](https://developer.android.com/studio/command-line/adb.html?hl=zh-cn)\n###   你会linux嘛？罗列进程是那个指令？\n\n    ps命令查找与进程相关的PID号\n\t使用kill命令结束进程：kill xxx \n    常用：kill －9 324\n\tLinux下还提供了一个killall命令，可以直接使用进程的名字而\t     不是进程标识号 \n    例如：# killall -9 NAME\n###  Android中如果你声明了一个Activity的class类，但没有在清单文件中声明他，是否可以将其吊起？ 如果不能 有什么方法可以吊起嘛?\n[Android免清单注册吊起Activity](http://blog.csdn.net/qfanmingyiq/article/details/78216446)\n\n## IOS逆向\n\n###  ASO体系并不是这么简单，你确定你开发的是有效的？ \n    我只能说，在我开发出来时候，做了（改机，清keychain，AppStore排名优化，自动启动AppStore,账号登录登出，适配10系统，评论功能，模拟触碰，动态IP池，自动下载和成功后的取消下载）。我只能说我当时做出来是有效的，Apple的策略改变没有，在公司倒闭后 我就没再更深的了解了。这个东西并不是那么容易玩的转的。\n\n###  你除了对arm汇编 了解完 你懂x86汇编嘛？（哎 我一个玩arm平台的 突然问我x86我还是依然懵逼） \n    [X86汇编指令](http://www.cnblogs.com/YukiJohnson/archive/2012/10/27/2741836.html)\n\n## final, finally, finalize的区别\n\n*   final 用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承.\n\n*   finally 是异常处理语句结构的一部分，表示总是执行.\n\n*   finalize 是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用.\n\n## [Android 多线程编程的总结](https://www.diycode.cc/topics/213)\n\n\n\n## Android面试题\n[Android面试题](http://blog.csdn.net/angel_w/article/details/79103141)",[[1520908614616,["gengmei_pxf@gengmei123.local",[[1,23420,"###"]],[23420,23420],[23423,23423]]],[1520908615407,["gengmei_pxf@gengmei123.local",[[-1,23422,"#"]],[23423,23423],[23422,23422]]],[1520908616170,["gengmei_pxf@gengmei123.local",[[1,23422," # RecyclerView 和 ListView"]],[23422,23422],[23448,23448]]],[1520908618397,["gengmei_pxf@gengmei123.local",[[-1,23423,"# "]],[23425,23425],[23423,23423]]],[1520908621973,["gengmei_pxf@gengmei123.local",[[1,23448,"\n"]],[23446,23446],[23447,23447]]],[1520908636738,["gengmei_pxf@gengmei123.local",[[1,23447,"###"]],[23447,23447],[23450,23450]]],[1520908637877,["gengmei_pxf@gengmei123.local",[[-1,23447,"###"]],[23450,23450],[23447,23447]]],[1520908639959,["gengmei_pxf@gengmei123.local",[[1,23447,"* ## 布局效果对比"]],[23447,23447],[23458,23458]]],[1520908643172,["gengmei_pxf@gengmei123.local",[[-1,23449,"## "]],[23452,23452],[23449,23449]]],[1520908645260,["gengmei_pxf@gengmei123.local",[[1,23457,"\n"]],[23455,23455],[23456,23456]]],[1520908679857,["gengmei_pxf@gengmei123.local",[[1,23458,"\n"]],[23456,23456],[23457,23457]]],[1520908681588,["gengmei_pxf@gengmei123.local",[[1,23457,"## ## API 使用对比"]],[23457,23457],[23471,23471]]],[1520908684714,["gengmei_pxf@gengmei123.local",[[-1,23457,"## ## "]],[23463,23463],[23457,23457]]],[1520908686127,["gengmei_pxf@gengmei123.local",[[1,23457,"* "]],[23457,23457],[23459,23459]]],[1520908687457,["gengmei_pxf@gengmei123.local",[[1,23469,"\n"]],[23467,23467],[23468,23468]]],[1520908708955,["gengmei_pxf@gengmei123.local",[[1,23468,"ListView 的基础使用大家再熟悉不过，其使用的关键点主要如下：\n\n*   继承重写 BaseAdapter 类\n*   自定义 ViewHolder 和 convertView 一起完成复用优化工作\n\n由于 ListView 已经老生常谈，所以此处就不去写示例代码了。 RecyclerView 基础使用关键点同样有两点：\n\n*   继承重写 RecyclerView.Adapter 和 RecyclerView.ViewHolder\n*   设置布局管理器，控制布局效果\n\n作者：D_clock爱吃葱花\n链接：https://www.jianshu.com/p/f592f3715ae2\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[23468,23468],[23807,23807]]],[1520908715177,["gengmei_pxf@gengmei123.local",[[-1,23457,"*"]],[23458,23458],[23457,23457]]],[1520908716452,["gengmei_pxf@gengmei123.local",[[1,23457,"###"]],[23457,23457],[23460,23460]]],[1520908719872,["gengmei_pxf@gengmei123.local",[[-1,23447,"*"]],[23448,23448],[23447,23447]]],[1520908720468,["gengmei_pxf@gengmei123.local",[[1,23447,"￥"]],[23447,23447],[23448,23448]]],[1520908721105,["gengmei_pxf@gengmei123.local",[[-1,23447,"￥"]],[23448,23448],[23447,23447]]],[1520908721923,["gengmei_pxf@gengmei123.local",[[1,23447,"###"]],[23447,23447],[23450,23450]]],[1520908724097,["gengmei_pxf@gengmei123.local",[[1,23459,"\n"]],[23457,23457],[23458,23458]]],[1520908749814,["gengmei_pxf@gengmei123.local",[[1,23458,"ListView只有一种滑动布局"]],[23458,23458],[23474,23474]]],[1520908750872,["gengmei_pxf@gengmei123.local",[[1,23476,"\n"]],[23474,23474],[23475,23475]]],[1520908763844,["gengmei_pxf@gengmei123.local",[[1,23475,"RecyclerView"]],[23475,23475],[23487,23487]]],[1520908795375,["gengmei_pxf@gengmei123.local",[[1,23487,"通过布局管理器能展示多种布局，有"]],[23487,23487],[23503,23503]]],[1520908809122,["gengmei_pxf@gengmei123.local",[[-1,23501,"，有"]],[23503,23503],[23501,23501]]],[1520908885325,["gengmei_pxf@gengmei123.local",[[-1,23758,"作者：D_clock爱吃葱花\n链接：https://www.jianshu.com/p/f592f3715ae2\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[23758,23855],[23758,23758]]],[1520908939464,["gengmei_pxf@gengmei123.local",[[1,23758,"### ## 空数据处理"]],[23758,23758],[23770,23770]]],[1520908941541,["gengmei_pxf@gengmei123.local",[[-1,23762,"## "]],[23765,23765],[23762,23762]]],[1520908943884,["gengmei_pxf@gengmei123.local",[[1,23769,"\n"]],[23767,23767],[23768,23768]]],[1520909015346,["gengmei_pxf@gengmei123.local",[[1,23768,"ListView 提供了 setEmptyView 这个 API 来让我们处理 Adapter 中数据为空的情况，只需轻轻一 set 就能搞定一切。代码设置和效果如下\n\n```\n\n        mListView = (ListView) findViewById(R.id.listview);\n        mListView.setEmptyView(findViewById(R.id.empty_layout));//设置内容为空时显示的视图\n\n```\n\n作者：D_clock爱吃葱花\n链接：https://www.jianshu.com/p/f592f3715ae2\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[23768,23768],[24100,24100]]],[1520909024726,["gengmei_pxf@gengmei123.local",[[-1,23858,"        "]],[23866,23866],[23858,23858]]],[1520909030982,["gengmei_pxf@gengmei123.local",[[-1,23995,"作者：D_clock爱吃葱花\n链接：https://www.jianshu.com/p/f592f3715ae2\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n"]],[23994,24092],[23994,23994]]],[1520909034310,["gengmei_pxf@gengmei123.local",[[1,23768,"\n"]],[23768,23768],[23769,23769]]],[1520909036764,["gengmei_pxf@gengmei123.local",[[1,23769,"* "]],[23769,23769],[23771,23771]]],[1520909063327,["gengmei_pxf@gengmei123.local",[[1,23997,"* RecyclerView没有相应的API，需要自己动手去完成"]],[23997,23997],[24029,24029]]],[1520909064397,["gengmei_pxf@gengmei123.local",[[1,24031,"\n"]],[24029,24029],[24030,24030]]],[1520909064980,["gengmei_pxf@gengmei123.local",[[1,24032,"\n"]],[24030,24030],[24031,24031]]],[1520909088511,["gengmei_pxf@gengmei123.local",[[1,24031,"## HeaderView 和 FooterView\n\n在 ListView 的设计中，存在着 HeaderView 和 FooterView 两种类型的视图，并且系统也提供了相应的 API 来让我们设置"]],[24031,24031],[24133,24133]]],[1520909092734,["gengmei_pxf@gengmei123.local",[[1,24033,"#"]],[24033,24033],[24034,24034]]],[1520909097587,["gengmei_pxf@gengmei123.local",[[1,24136,"\n"]],[24134,24134],[24135,24135]]],[1520909098075,["gengmei_pxf@gengmei123.local",[[1,24137,"\n"]],[24135,24135],[24136,24136]]],[1520909104281,["gengmei_pxf@gengmei123.local",[[1,24060,"* "]],[24060,24060],[24062,24062]]],[1520909105549,["gengmei_pxf@gengmei123.local",[[1,24138,"* RecyclerView没有相应的API，需要自己动手去完成"]],[24138,24138],[24170,24170]]],[1520909106579,["gengmei_pxf@gengmei123.local",[[1,24172,"\n"]],[24170,24170],[24171,24171]]],[1520909108994,["gengmei_pxf@gengmei123.local",[[1,24173,"\n"]],[24171,24171],[24172,24172]]],[1520909110261,["gengmei_pxf@gengmei123.local",[[1,24172,"### "]],[24172,24172],[24176,24176]]],[1520909130029,["gengmei_pxf@gengmei123.local",[[1,24176,"## 局部刷新"]],[24176,24176],[24183,24183]]],[1520909132057,["gengmei_pxf@gengmei123.local",[[-1,24176,"## "]],[24179,24179],[24176,24176]]],[1520909134153,["gengmei_pxf@gengmei123.local",[[1,24182,"\n"]],[24180,24180],[24181,24181]]],[1520909203040,["gengmei_pxf@gengmei123.local",[[1,24181,"然而 ListView 并没有提供局部刷新刷新某个 Item 的 API 给我们，同样自己自足，套路大致如下方的 updateItemView：\n\n```\n\npublic class AuthorListAdapter extends BaseAdapter {\n\n    ...\n\n    @Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n        ...\n        return convertView;\n    }\n\n    /**\n     * 更新Item视图，减少不必要的重绘\n     *\n     * @param listView\n     * @param position\n     */\n    public void updateItemView(ListView listView, int position) {\n        //换算成 Item View 在 ViewGroup 中的 index\n        int index = position - listView.getFirstVisiblePosition();\n        if (index >= 0 && index < listView.getChildCount()) {\n            //更新数据\n            AuthorInfo authorInfo = mAuthorInfoList.get(position);\n            authorInfo.setNickName(\"Google Android\");\n            authorInfo.setMotto(\"My name is Android .\");\n            authorInfo.setPortrait(R.mipmap.ic_launcher);\n            //更新单个Item\n            View itemView = listView.getChildAt(index);\n            getView(position, itemView, listView);\n        }\n    }\n\n}\n\n```\n\n即可实现刷新单个 Item 的效果\n\n作者：D_clock爱吃葱花\n链接：https://www.jianshu.com/p/f592f3715ae2\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[24181,24181],[25320,25320]]],[1520909207007,["gengmei_pxf@gengmei123.local",[[-1,24181,"然而"],[1,24183,"*"]],[24181,24183],[24182,24182]]],[1520909217107,["gengmei_pxf@gengmei123.local",[[-1,25222,"作者：D_clock爱吃葱花\n链接：https://www.jianshu.com/p/f592f3715ae2\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[25222,25319],[25222,25222]]],[1520909242480,["gengmei_pxf@gengmei123.local",[[1,25222,"[RecyclerView.Adapter](https://link.jianshu.com/?t=https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html) 则我们提供了 notifyItemChanged 用于更新单个 Item View 的刷新，我们可以省去自己写局部更新的工作。\n\n![](https://upload-images.jianshu.io/upload_images/912181-b8051dce7450291e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)"]],[25222,25222],[25560,25560]]],[1520909293726,["gengmei_pxf@gengmei123.local",[[-1,25365," "],[1,25366," "],[1,25560,"\n"]],[25560,25560],[25561,25561]]],[1520909294325,["gengmei_pxf@gengmei123.local",[[1,25563,"\n"]],[25561,25561],[25562,25562]]],[1520909294823,["gengmei_pxf@gengmei123.local",[[1,25562,"## 动画效果\n\n如果你细心观察上面 ListView 和 RecyclerView 局部更新 Item 的效果，你会发现相比 ListView 而言， RecyclerView 在做局部刷新的时候有一个渐变的动画效果。这也是 RecyclerView 相对非常值得一提的地方，作为 ListView 自身并没有为我们提供封装好的 API 来实现动画效果切换。所以，如果要给 ListView 的 Item 加动画，我们只能自己通过属性动画来操作 Item 的视图。 Github 也有很多封装得好好的开源库给我们用，如：[ListViewAnimations](https://link.jianshu.com?t=https://github.com/nhaarman/ListViewAnimations) 就封装了大量的效果供我们玩耍，童鞋们可以自行学习一下\n\n作者：D_clock爱吃葱花\n链接：https://www.jianshu.com/p/f592f3715ae2\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[25562,25562],[26044,26044]]],[1520909298976,["gengmei_pxf@gengmei123.local",[[1,25564,"#"]],[25564,25564],[25565,25565]]],[1520909313664,["gengmei_pxf@gengmei123.local",[[-1,25948,"作者：D_clock爱吃葱花\n链接：https://www.jianshu.com/p/f592f3715ae2\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[25948,26045],[25948,25948]]],[1520909329053,["gengmei_pxf@gengmei123.local",[[-1,25572,"如果你细心观察上面 ListView 和 RecyclerView 局部更新 Item 的效果，你会发现相比 ListView 而言， RecyclerView 在做局部刷新的时候有一个渐变的动画效果。这也是 RecyclerView 相对非常值得一提的地方，"]],[25572,25702],[25572,25572]]],[1520909338684,["gengmei_pxf@gengmei123.local",[[-1,25789," 就封装了大量的效果供我们玩耍，童鞋们可以自行学习一下"]],[25789,25816],[25789,25789]]],[1520909339314,["gengmei_pxf@gengmei123.local",[[1,25793,"\n"]],[25789,25789],[25790,25790]]],[1520909339746,["gengmei_pxf@gengmei123.local",[[1,25794,"\n"]],[25790,25790],[25791,25791]]],[1520909342927,["gengmei_pxf@gengmei123.local",[[1,25572,"* "]],[25572,25572],[25574,25574]]],[1520909344759,["gengmei_pxf@gengmei123.local",[[1,25793,"* "]],[25793,25793],[25795,25795]]],[1520909444253,["gengmei_pxf@gengmei123.local",[[1,25799,"\n"]],[25795,25795],[25796,25796]]],[1520909444741,["gengmei_pxf@gengmei123.local",[[1,25800,"\n"]],[25796,25796],[25797,25797]]],[1520909445303,["gengmei_pxf@gengmei123.local",[[1,25797,"## 监听 Item 的事件\n\nListView 为我们准备了几个专门用于监听 Item 的回调接口，如单击、长按、选中某个 Item 等"]],[25797,25797],[25866,25866]]],[1520909447264,["gengmei_pxf@gengmei123.local",[[1,25799,"#"]],[25799,25799],[25800,25800]]],[1520909474602,["gengmei_pxf@gengmei123.local",[[1,25795,"RecyclerView 则为我们提供了很多基本的动画 API ，如下方的**增删移改**\n\n![](https://upload-images.jianshu.io/upload_images/912181-af00cdaa75008b0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\n简单的调用即可实现相应的效果，用起来方便很多，视觉交互上也会更好些"]],[25795,25795],[26006,26006]]],[1520909536005,["gengmei_pxf@gengmei123.local",[[1,26008,"\n"]],[26006,26006],[26007,26007]]],[1520909536628,["gengmei_pxf@gengmei123.local",[[1,26009,"\n"]],[26007,26007],[26008,26008]]],[1520909539580,["gengmei_pxf@gengmei123.local",[[-1,26009,"\n"]],[26008,26008],[26007,26007]]],[1520909539948,["gengmei_pxf@gengmei123.local",[[-1,26008,"\n"]],[26007,26007],[26006,26006]]],[1520909542204,["gengmei_pxf@gengmei123.local",[[1,26025,"\n"]],[26023,26023],[26024,26024]]],[1520909542788,["gengmei_pxf@gengmei123.local",[[1,26026,"\n"]],[26024,26024],[26025,26025]]],[1520909543192,["gengmei_pxf@gengmei123.local",[[1,26025,"RecyclerView ，它并没有像 ListView 提供太多关于 Item 的某种事件监听，唯一的就是 addOnItemTouchListener"]],[26025,26025],[26102,26102]]],[1520909559829,["gengmei_pxf@gengmei123.local",[[1,26025,"\n"]],[26023,26023],[26024,26024]]],[1520909560214,["gengmei_pxf@gengmei123.local",[[1,26024,"ListView 为我们准备了几个专门用于监听 Item 的回调接口，如单击、长按、选中某个 Item 等\n\n![](https://upload-images.jianshu.io/upload_images/912181-eb82b15ab33d5bc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)"]],[26024,26024],[26208,26208]]],[1520909562479,["gengmei_pxf@gengmei123.local",[[1,26024,"* "]],[26024,26024],[26026,26026]]],[1520909564963,["gengmei_pxf@gengmei123.local",[[1,26212,"* "]],[26212,26212],[26214,26214]]],[1520909567971,["gengmei_pxf@gengmei123.local",[[-1,26292,"\n"]],[26292,26292],[26291,26291]]],[1520909574338,["gengmei_pxf@gengmei123.local",[[-1,26292,"ListView 为我们准备了几个专门用于监听 Item 的回调接口，如单击、长按、选中某个 Item 等"]],[26292,26345],[26292,26292]]],[1520909628424,["gengmei_pxf@gengmei123.local",[[1,26296,"\n"]],[26292,26292],[26293,26293]]],[1520909630812,["gengmei_pxf@gengmei123.local",[[1,26293,"### ## 嵌套滚动机制"]],[26293,26293],[26306,26306]]],[1520909632984,["gengmei_pxf@gengmei123.local",[[-1,26296," ##"]],[26299,26299],[26296,26296]]],[1520909634879,["gengmei_pxf@gengmei123.local",[[1,26307,"\n"]],[26303,26303],[26304,26304]]],[1520909648666,["gengmei_pxf@gengmei123.local",[[1,26304,"RecyclerView支持嵌套滑动"]],[26304,26304],[26322,26322]]],[1520909648999,["gengmei_pxf@gengmei123.local",[[1,26326,"\n"]],[26322,26322],[26323,26323]]],[1520909654794,["gengmei_pxf@gengmei123.local",[[1,26323,"ListView不支持"]],[26323,26323],[26334,26334]]],[1520910974643,["gengmei_pxf@gengmei123.local",[[1,26336,"## RecyclerView与ListView的"]],[26336,26336],[26361,26361]]],[1520910981156,["gengmei_pxf@gengmei123.local",[[1,26361,"滑动对吧"]],[26361,26361],[26365,26365]]],[1520910982176,["gengmei_pxf@gengmei123.local",[[-1,26363,"对吧"]],[26365,26365],[26363,26363]]],[1520910984331,["gengmei_pxf@gengmei123.local",[[1,26363,"对比"]],[26363,26363],[26365,26365]]],[1520910984927,["gengmei_pxf@gengmei123.local",[[1,26367,"\n"]],[26365,26365],[26366,26366]]],[1520910985487,["gengmei_pxf@gengmei123.local",[[1,26368,"\n"]],[26366,26366],[26367,26367]]],[1520910986126,["gengmei_pxf@gengmei123.local",[[1,26367,"RecyclerView的滑动过程可以分为2个阶段：手指在屏幕上移动，使RecyclerView滑动的过程，可以称为scroll；手指离开屏幕，RecyclerView继续滑动一段距离的过程，可以称为fling。"]],[26367,26367],[26473,26473]]],[1520910988771,["gengmei_pxf@gengmei123.local",[[1,26367,"* "]],[26367,26367],[26369,26369]]],[1520910991226,["gengmei_pxf@gengmei123.local",[[1,26477,"\n"]],[26475,26475],[26476,26476]]],[1520910992594,["gengmei_pxf@gengmei123.local",[[1,26478,"\n"]],[26476,26476],[26477,26477]]],[1520911018952,["gengmei_pxf@gengmei123.local",[[1,26477,"当RecyclerView接收到ACTION_MOVE事件后，会先计算出手指移动距离（dy），并与滑动阀值（mTouchSlop）比较，当大于此阀值时将滑动状态设置为SCROLL_STATE_DRAGGING，而后调用scrollByInternal()方法，使RecyclerView滑动，这样RecyclerView的滑动的第一阶段scroll就完成了；当接收到ACTION_UP事件时，会根据之前的滑动距离与时间计算出一个初速度yvel，这步计算是由VelocityTracker实现的，然后再以此初速度，调用方法fling()，完成RecyclerView滑动的第二阶段fling。"]],[26477,26477],[26772,26772]]],[1520911030070,["gengmei_pxf@gengmei123.local",[[1,26368,"\n"]],[26368,26368],[26369,26369]]],[1520911031688,["gengmei_pxf@gengmei123.local",[[-1,26369," "]],[26370,26370],[26369,26369]]],[1520911034043,["gengmei_pxf@gengmei123.local",[[1,26368," RecyclerView的滑动"]],[26368,26368],[26384,26384]]],[1520911037143,["gengmei_pxf@gengmei123.local",[[1,26385,"\n"]],[26384,26384],[26385,26385]]],[1520911045497,["gengmei_pxf@gengmei123.local",[[1,26791,"\n"]],[26790,26790],[26791,26791]]],[1520911046449,["gengmei_pxf@gengmei123.local",[[1,26792,"\n"]],[26791,26791],[26792,26792]]],[1520911055230,["gengmei_pxf@gengmei123.local",[[1,26791,"ListView的滑动对比"]],[26791,26791],[26804,26804]]],[1520911058225,["gengmei_pxf@gengmei123.local",[[-1,26802,"对比"]],[26804,26804],[26802,26802]]],[1520911061451,["gengmei_pxf@gengmei123.local",[[1,26791,"* "]],[26791,26791],[26793,26793]]],[1520911064809,["gengmei_pxf@gengmei123.local",[[1,26806,"\n"]],[26804,26804],[26805,26805]]],[1520911065345,["gengmei_pxf@gengmei123.local",[[1,26807,"\n"]],[26805,26805],[26806,26806]]],[1520925290854,["gengmei_pxf@gengmei123.local",[[1,26808,"\n"]],[26806,26806],[26807,26807]]],[1520925291606,["gengmei_pxf@gengmei123.local",[[1,26807,"![6大原则](http://www.uml.org.cn/sjms/images/2012110233.jpg)"]],[26807,26807],[26864,26864]]],[1520925295981,["gengmei_pxf@gengmei123.local",[[1,26807,"\n"]],[26805,26805],[26806,26806]]],[1520925304943,["gengmei_pxf@gengmei123.local",[[1,26806,"## Android中6"]],[26806,26806],[26818,26818]]],[1520925305987,["gengmei_pxf@gengmei123.local",[[-1,26817,"6"]],[26818,26818],[26817,26817]]],[1520925311257,["gengmei_pxf@gengmei123.local",[[1,26817,"设计模式的6大原则"]],[26817,26817],[26826,26826]]],[1520933533721,["gengmei_pxf@gengmei123.local",[[1,26887,"\n"]],[26885,26885],[26886,26886]]],[1520933533961,["gengmei_pxf@gengmei123.local",[[1,26888,"\n"]],[26886,26886],[26887,26887]]],[1520933534522,["gengmei_pxf@gengmei123.local",[[1,26887,"# WebView的基本使用以及Android和js的交互"]],[26887,26887],[26916,26916]]],[1520933536948,["gengmei_pxf@gengmei123.local",[[1,26888,"#"]],[26888,26888],[26889,26889]]],[1520933541140,["gengmei_pxf@gengmei123.local",[[1,26890,"【"]],[26890,26890],[26891,26891]]],[1520933542161,["gengmei_pxf@gengmei123.local",[[-1,26890,"【"]],[26891,26891],[26890,26890]]],[1520933542549,["gengmei_pxf@gengmei123.local",[[1,26890,"["]],[26890,26890],[26891,26891]]],[1520933545933,["gengmei_pxf@gengmei123.local",[[1,26918,"]()"]],[26918,26918],[26921,26921]]],[1520933552643,["gengmei_pxf@gengmei123.local",[[1,26920,"https://www.jianshu.com/p/b9164500d3fb"]],[26920,26920],[26958,26958]]],[1520934488705,["gengmei_pxf@gengmei123.local",[[1,26958,"\n"]],[26958,26958],[26959,26959]]],[1520934490257,["gengmei_pxf@gengmei123.local",[[-1,26958,"\n"]],[26959,26959],[26958,26958]]],[1520934491201,["gengmei_pxf@gengmei123.local",[[1,26961,"\n"]],[26959,26959],[26960,26960]]],[1520934491561,["gengmei_pxf@gengmei123.local",[[1,26962,"\n"]],[26960,26960],[26961,26961]]],[1520934493596,["gengmei_pxf@gengmei123.local",[[1,26961,"## [Retrofit+okhttp网络框架介绍](http://blog.csdn.net/zhanggang740/article/details/51569108)"]],[26961,26961],[27047,27047]]],[1520934824742,["gengmei_pxf@gengmei123.local",[[1,27049,"\n"]],[27048,27048],[27049,27049]]],[1520934824942,["gengmei_pxf@gengmei123.local",[[1,27050,"\n"]],[27049,27049],[27050,27050]]],[1520934827145,["gengmei_pxf@gengmei123.local",[[1,27049,"## # Okhttp3结合Retrofit2 实现缓存"]],[27049,27049],[27077,27077]]],[1520934829022,["gengmei_pxf@gengmei123.local",[[-1,27052,"# "]],[27054,27054],[27052,27052]]],[1520934831921,["gengmei_pxf@gengmei123.local",[[1,27052,"["]],[27052,27052],[27053,27053]]],[1520934835753,["gengmei_pxf@gengmei123.local",[[1,27076,"]()"]],[27076,27076],[27079,27079]]],[1520934845976,["gengmei_pxf@gengmei123.local",[[1,27078,"https://www.jianshu.com/p/74d2c10c3eba?from=timeline"]],[27078,27078],[27130,27130]]],[1520943114290,["gengmei_pxf@gengmei123.local",[[1,27133,"\n"]],[27131,27131],[27132,27132]]],[1520943114955,["gengmei_pxf@gengmei123.local",[[1,27134,"\n"]],[27132,27132],[27133,27133]]],[1520943118844,["gengmei_pxf@gengmei123.local",[[1,27133,"## ## SmartHeaderFooterRecyclerview"]],[27133,27133],[27168,27168]]],[1520943122562,["gengmei_pxf@gengmei123.local",[[-1,27136,"## "]],[27139,27139],[27136,27136]]],[1520943125721,["gengmei_pxf@gengmei123.local",[[1,27167,"\n"]],[27165,27165],[27166,27166]]],[1520943168428,["gengmei_pxf@gengmei123.local",[[1,27166,"* 4, Support LinearLayoutManager & GridLayoutManager\n\n```\n支持 LinearLayoutManager & GridLayoutManager 两种布局管理器\n```非常方便的实现Recyclerview添加HeaderView和FooterView， \n* 1, No need change anyting with your target adapter\n\n```\n 不需要修改Target Adapter\n\n```\n\n* 2, Not destroy target adapter position\n\n```\n 不会破坏Target adapter中的 position (PS: 不需要 +1 -1)\n\n```\n\n* 3, Support dynamic add & remove\n\n```\n 支持动态添加移除\n\n```\n\n"]],[27166,27166],[27562,27562]]],[1520943179640,["gengmei_pxf@gengmei123.local",[[-1,27209," \n* 1, No need change anyting"],[-1,27239,"with your target adapter"],[-1,27264,"\n```"]],[27211,27268],[27211,27211]]],[1520943180415,["gengmei_pxf@gengmei123.local",[[-1,27211,"\n"]],[27211,27211],[27210,27210]]],[1520943184703,["gengmei_pxf@gengmei123.local",[[-1,27232,"\n```\n\n* 2, Not destroy target adapter position\n\n```\n "]],[27232,27285],[27232,27232]]],[1520943186523,["gengmei_pxf@gengmei123.local",[[1,27232,"* "]],[27232,27232],[27234,27234]]],[1520943188802,["gengmei_pxf@gengmei123.local",[[1,27211,"*"]],[27211,27211],[27212,27212]]],[1520943214311,[null,[[-1,27166,"* 4, Support LinearLayoutManager & GridLayotg*布局管理器\n```"],[-1,27233,"* anyting with your target adapter\n\n```\n"],[1,27273,"lerview添加HeaderView和FooterView， \n*"],[-1,27294,"\n```\n\n"],[-1,27302,"2, Not destroy target adapter position\n\n```\n "],[1,27454,"* 4, Support LinearLayoutManager & GridLayoutManager\n\n```\n支持 LinearLayoutManager & GridLayoutManager 两种布局管理器\n```"]],[27166,27166],[27566,27566]]],[1520943214311,[null,[[1,27166,"* 4, Support LinearLayoutManager & GridLayotg*布局管理器\n```"],[1,27178,"* anyting with your target adapter\n\n```\n"],[-1,27178,"lerview添加HeaderView和FooterView， \n*"],[1,27233,"\n```\n\n"],[1,27235,"2, Not destroy target adapter position\n\n```\n "],[-1,27342,"* 4, Support LinearLayoutManager & GridLayoutManager\n\n```\n支持 LinearLayoutManager & GridLayoutManager 两种布局管理器\n```"]],[27566,27566],[27166,27166]]],[1520943194306,["gengmei_pxf@gengmei123.local",[[1,27283," "]],[27283,27283],[27284,27284]]],[1520943196223,["gengmei_pxf@gengmei123.local",[[-1,27281,"\n"]],[27281,27281],[27280,27280]]],[1520943202415,["gengmei_pxf@gengmei123.local",[[-1,27292,"```\n\n* 4, Support LinearLayoutManager & GridLayoutManager\n\n```\n"]],[27292,27355],[27292,27292]]],[1520943204455,["gengmei_pxf@gengmei123.local",[[1,27292,"* "]],[27292,27292],[27294,27294]]],[1520943207847,["gengmei_pxf@gengmei123.local",[[-1,27345,"```"]],[27345,27348],[27345,27345]]],[1520943208438,["gengmei_pxf@gengmei123.local",[[-1,27346,"\n"]],[27345,27345],[27344,27344]]],[1520943211094,["gengmei_pxf@gengmei123.local",[[1,27166,"\n"]],[27165,27165],[27166,27166]]],[1520943244252,[null,[[-1,27167,"* 4, Support LinearLayoutManager & GridLayotg*布局管理器\n```"],[-1,27234,"* anyting with your target adapter\n\n```\n"],[1,27274,"lerview添加HeaderView和FooterView， \n*"],[1,27282,"r"],[-1,27283," "],[1,27293,"r\n"],[1,27295,"不会破坏Targ"],[-1,27333,"\n```\n\n* 3, Sur dynamic add & remove\n\n```\n 支持动态添加移除\n\n```\n\n"],[1,27390,"* 支持动态添加移除\n* 支持 LinearLayoutManager & GridLayoutManager 两种布局管理器"]],[27167,27167],[27453,27453]]],[1520943244252,[null,[[1,27167,"* 4, Support LinearLayoutManager & GridLayotg*布局管理器\n```"],[1,27179,"* anyting with your target adapter\n\n```\n"],[-1,27179,"lerview添加HeaderView和FooterView， \n*"],[-1,27221,"r"],[1,27223," "],[-1,27232,"r\n"],[-1,27236,"不会破坏Targ"],[1,27282,"\n```\n\n* 3, Sur dynamic add & remove\n\n```\n 支持动态添加移除\n\n```\n\n"],[-1,27282,"* 支持动态添加移除\n* 支持 LinearLayoutManager & GridLayoutManager 两种布局管理器"]],[27453,27453],[27167,27167]]],[1520943233029,["gengmei_pxf@gengmei123.local",[[1,27347,"\n"]],[27345,27345],[27346,27346]]],[1520943233341,["gengmei_pxf@gengmei123.local",[[1,27348,"\n"]],[27346,27346],[27347,27347]]],[1520943239663,["gengmei_pxf@gengmei123.local",[[1,27348,"```\nRecyclerView.Adapter targetAdapter = new RecyclerView.Adapter() { ... };\n      GridLayoutManager gridLayoutManager = new GridLayoutManager(this, 3);\n      SmartRecyclerAdapter smartRecyclerAdapter = new SmartRecyclerAdapter(targetAdapter, gridLayoutManager);\n      smartRecyclerAdapter.setFooterView(footerView);\n      smartRecyclerAdapter.setHeaderView(headerView);\n      recyclerView.setAdapter(smartRecyclerAdapter);\n```\n\n"]],[27347,27347],[27776,27776]]],[1520943468614,[null,[[-1,27167,"* 4, Support LinearLayoutManager & GridLayotg*布局管理器\n```"],[-1,27234,"* anyting with your target adapter\n\n```\n"],[1,27274,"lerview添加HeaderView和FooterView， \n*"],[1,27282,"r"],[-1,27283," "],[1,27293,"r\n"],[1,27295,"不会破坏Targ"],[-1,27333,"\n```\n\n* 3, Sur"],[1,27347,"* 支持动态添加移除\n* 支持 LinearLayoutManager & GridLayoutManager 两种布局管理器\n\n"],[-1,27775,"\n\n\n dynamic add & remove\n\n```\n 支持动态添加移除\n\n```\n"]],[27167,27167],[27775,27775]]],[1520943468614,[null,[[1,27167,"* 4, Support LinearLayoutManager & GridLayotg*布局管理器\n```"],[1,27179,"* anyting with your target adapter\n\n```\n"],[-1,27179,"lerview添加HeaderView和FooterView， \n*"],[-1,27221,"r"],[1,27223," "],[-1,27232,"r\n"],[-1,27236,"不会破坏Targ"],[1,27282,"\n```\n\n* 3, Sur"],[-1,27282,"* 支持动态添加移除\n* 支持 LinearLayoutManager & GridLayoutManager 两种布局管理器\n\n"],[1,27775,"\n\n\n dynamic add & remove\n\n```\n 支持动态添加移除\n\n```\n"]],[27775,27775],[27167,27167]]],[1520943438572,["gengmei_pxf@gengmei123.local",[[1,27136,"\n"]],[27136,27136],[27137,27137]]],[1520943439211,["gengmei_pxf@gengmei123.local",[[1,27137,"\n"]],[27137,27137],[27138,27138]]],[1520943446549,["gengmei_pxf@gengmei123.local",[[1,27136,"RecyclerView t"]],[27136,27136],[27150,27150]]],[1520943446923,["gengmei_pxf@gengmei123.local",[[-1,27149,"t"]],[27150,27150],[27149,27149]]],[1520943459670,["gengmei_pxf@gengmei123.local",[[1,27149,"添加Header和FooterView"]],[27149,27149],[27168,27168]]],[1520943464363,["gengmei_pxf@gengmei123.local",[[1,27157,"View"]],[27157,27157],[27161,27161]]],[1520943528603,[null,[[-1,27205,"* 4, Support LinearLayoutManager & GridLayotg*布局管理器\n```"],[-1,27272,"* anyting with your target adapter\n\n```\n"],[1,27312,"lerview添加HeaderView和FooterView， \n*"],[1,27320,"r"],[-1,27321," "],[1,27331,"r\n"],[1,27333,"不会破坏Targ"],[-1,27371,"\n```\n\n* 3, Sur"],[1,27385,"* 支持动态添加移除\n* 支持 LinearLayoutManager & GridLayoutManager 两种布局管理器\n\n"],[-1,27813,"\n\n\n dynamic add & remove\n\n```\n 支持动态添加移除\n\n```\n"]],[27205,27205],[27813,27813]]],[1520943528603,[null,[[1,27205,"* 4, Support LinearLayoutManager & GridLayotg*布局管理器\n```"],[1,27217,"* anyting with your target adapter\n\n```\n"],[-1,27217,"lerview添加HeaderView和FooterView， \n*"],[-1,27259,"r"],[1,27261," "],[-1,27270,"r\n"],[-1,27274,"不会破坏Targ"],[1,27320,"\n```\n\n* 3, Sur"],[-1,27320,"* 支持动态添加移除\n* 支持 LinearLayoutManager & GridLayoutManager 两种布局管理器\n\n"],[1,27813,"\n\n\n dynamic add & remove\n\n```\n 支持动态添加移除\n\n```\n"]],[27813,27813],[27205,27205]]],[1520943482990,["gengmei_pxf@gengmei123.local",[[1,27814,"## rertofit"]],[27814,27814],[27825,27825]]],[1520943486122,["gengmei_pxf@gengmei123.local",[[-1,27817,"rertofit"]],[27825,27825],[27817,27817]]],[1520943501930,["gengmei_pxf@gengmei123.local",[[1,27817,"retrofit z"]],[27817,27817],[27827,27827]]],[1520943502417,["gengmei_pxf@gengmei123.local",[[-1,27826,"z"]],[27827,27827],[27826,27826]]],[1520943502716,["gengmei_pxf@gengmei123.local",[[1,27826,"s"]],[27826,27826],[27827,27827]]],[1520943503097,["gengmei_pxf@gengmei123.local",[[-1,27826,"s"]],[27827,27827],[27826,27826]]],[1520943506477,["gengmei_pxf@gengmei123.local",[[1,27826,"上传文件"]],[27826,27826],[27830,27830]]],[1520943506793,["gengmei_pxf@gengmei123.local",[[1,27832,"\n"]],[27830,27830],[27831,27831]]],[1520943507880,["gengmei_pxf@gengmei123.local",[[1,27831,"/**\n * 上传信息 */ @Multipart @POST(\"files/upload/\")\nCall<GMResponse<JSONObject>> uploadFile(@Part(\"type\") String type,\n  @Part() MultipartBody.Part file);"]],[27831,27831],[27982,27982]]],[1520943509026,["gengmei_pxf@gengmei123.local",[[-1,27831,"/**\n * 上传信息 */ @Multipart @POST(\"files/upload/\")\nCall<GMResponse<JSONObject>> uploadFile(@Part(\"type\") String type,\n  @Part() MultipartBody.Part file);"]],[27982,27982],[27831,27831]]],[1520943515549,["gengmei_pxf@gengmei123.local",[[1,27832,"```\n /**\n     * 上传信息\n     */\n    @Multipart\n    @POST(\"files/upload/\")\n    Call<GMResponse<JSONObject>> uploadFile(@Part(\"type\") String type,\n                                            @Part() MultipartBody.Part file);\n```\n\n"]],[27831,27831],[28056,28056]]],[1520943523760,["gengmei_pxf@gengmei123.local",[[-1,27832,"```\n /**\n     * 上传信息\n     */\n    @Multipart\n    @POST(\"files/upload/\")\n    Call<GMResponse<JSONObject>> uploadFile(@Part(\"type\") String type,\n                                            @Part() MultipartBody.Part file);\n```\n\n"]],[28056,28056],[27831,27831]]],[1520943588596,[null,[[-1,27205,"* 4, Support LinearLayoutManager & GridLayotg*布局管理器\n```"],[-1,27272,"* anyting with your target adapter\n\n```\n"],[1,27312,"lerview添加HeaderView和FooterView， \n*"],[1,27320,"r"],[-1,27321," "],[1,27331,"r\n"],[1,27333,"不会破坏Targ"],[-1,27371,"\n```\n\n* 3, Sur"],[1,27385,"* 支持动态添加移除\n* 支持 LinearLayoutManager & GridLayoutManager 两种布局管理器\n\n"],[-1,27830,"\n\n\n dynamic add & remove\n\n```\n 支持动态添加移除\n\n```\n"]],[27205,27205],[27830,27830]]],[1520943588596,[null,[[1,27205,"* 4, Support LinearLayoutManager & GridLayotg*布局管理器\n```"],[1,27217,"* anyting with your target adapter\n\n```\n"],[-1,27217,"lerview添加HeaderView和FooterView， \n*"],[-1,27259,"r"],[1,27261," "],[-1,27270,"r\n"],[-1,27274,"不会破坏Targ"],[1,27320,"\n```\n\n* 3, Sur"],[-1,27320,"* 支持动态添加移除\n* 支持 LinearLayoutManager & GridLayoutManager 两种布局管理器\n\n"],[1,27830,"\n\n\n dynamic add & remove\n\n```\n 支持动态添加移除\n\n```\n"]],[27830,27830],[27205,27205]]],[1520943561698,["gengmei_pxf@gengmei123.local",[[1,27831,"/**\n * 上传信息 */ @Multipart @POST(\"files/upload/\")\nCall<GMResponse<JSONObject>> uploadFile(@Part(\"type\") String type,\n  @Part() MultipartBody.Part file);"]],[27831,27831],[27982,27982]]],[1520943563759,["gengmei_pxf@gengmei123.local",[[-1,27831,"/**\n * 上传信息 */ @Multipart @POST(\"files/upload/\")\nCall<GMResponse<JSONObject>> uploadFile(@Part(\"type\") String type,\n  @Part() MultipartBody.Part file);"]],[27982,27982],[27831,27831]]],[1520943566034,["gengmei_pxf@gengmei123.local",[[1,27831,"·"]],[27831,27831],[27832,27832]]],[1520943567120,["gengmei_pxf@gengmei123.local",[[-1,27831,"·"]],[27832,27832],[27831,27831]]],[1520943569131,["gengmei_pxf@gengmei123.local",[[1,27831,"··"]],[27831,27831],[27833,27833]]],[1520943570198,["gengmei_pxf@gengmei123.local",[[-1,27831,"··"]],[27833,27833],[27831,27831]]],[1520943571905,["gengmei_pxf@gengmei123.local",[[1,27831,"```"]],[27831,27831],[27834,27834]]],[1520943572277,["gengmei_pxf@gengmei123.local",[[1,27836,"\n"]],[27834,27834],[27835,27835]]],[1520943572766,["gengmei_pxf@gengmei123.local",[[1,27837,"\n"]],[27835,27835],[27836,27836]]],[1520943574297,["gengmei_pxf@gengmei123.local",[[1,27836,"```"]],[27836,27836],[27839,27839]]],[1520943575711,["gengmei_pxf@gengmei123.local",[[1,27835,"/**\n * 上传信息 */ @Multipart @POST(\"files/upload/\")\nCall<GMResponse<JSONObject>> uploadFile(@Part(\"type\") String type,\n  @Part() MultipartBody.Part file);"]],[27835,27835],[27986,27986]]],[1520943580965,["gengmei_pxf@gengmei123.local",[[1,27849,"\n"]],[27849,27849],[27850,27850]]],[1520943582870,["gengmei_pxf@gengmei123.local",[[-1,27850," "]],[27851,27851],[27850,27850]]],[1520943648595,[null,[[-1,27205,"* 4, Support LinearLayoutManager & GridLayotg*布局管理器\n```"],[-1,27272,"* anyting with your target adapter\n\n```\n"],[1,27312,"lerview添加HeaderView和FooterView， \n*"],[1,27320,"r"],[-1,27321," "],[1,27331,"r\n"],[1,27333,"不会破坏Targ"],[-1,27371,"\n```\n\n* 3, Sur"],[1,27385,"* 支持动态添加移除\n* 支持 LinearLayoutManager & GridLayoutManager 两种布局管理器\n\n"],[-1,27990,"\n\n dynamic add & remove\n\n```\n 支持动态添加移除\n\n```\n\n"]],[27205,27205],[27990,27990]]],[1520943648595,[null,[[1,27205,"* 4, Support LinearLayoutManager & GridLayotg*布局管理器\n```"],[1,27217,"* anyting with your target adapter\n\n```\n"],[-1,27217,"lerview添加HeaderView和FooterView， \n*"],[-1,27259,"r"],[1,27261," "],[-1,27270,"r\n"],[-1,27274,"不会破坏Targ"],[1,27320,"\n```\n\n* 3, Sur"],[-1,27320,"* 支持动态添加移除\n* 支持 LinearLayoutManager & GridLayoutManager 两种布局管理器\n\n"],[1,27990,"\n\n dynamic add & remove\n\n```\n 支持动态添加移除\n\n```\n\n"]],[27990,27990],[27205,27205]]],[1520943595365,["gengmei_pxf@gengmei123.local",[[-1,27951,"  "]],[27953,27953],[27951,27951]]],[1520943595773,["gengmei_pxf@gengmei123.local",[[-1,27950,"\n"]],[27951,27951],[27950,27950]]],[1520943602612,["gengmei_pxf@gengmei123.local",[[1,27950,"\n"]],[27950,27950],[27951,27951]]],[1520943605796,["gengmei_pxf@gengmei123.local",[[1,27924,"\n"]],[27924,27924],[27925,27925]]],[1520943631259,["gengmei_pxf@gengmei123.local",[[1,27991,"\n"]],[27990,27990],[27991,27991]]],[1520943631550,["gengmei_pxf@gengmei123.local",[[1,27992,"\n"]],[27991,27991],[27992,27992]]],[1520943647014,["gengmei_pxf@gengmei123.local",[[1,27990,"```"]],[27990,27990],[27993,27993]]],[1520943647698,["gengmei_pxf@gengmei123.local",[[1,27996,"\n"]],[27993,27993],[27994,27994]]],[1520943647890,["gengmei_pxf@gengmei123.local",[[1,27997,"\n"]],[27994,27994],[27995,27995]]],[1520943648438,["gengmei_pxf@gengmei123.local",[[1,27995,"``"]],[27995,27995],[27997,27997]]],[1520943708600,[null,[[-1,27205,"* 4, Support LinearLayoutManager & GridLayotg*布局管理器\n```"],[-1,27272,"* anyting with your target adapter\n\n```\n"],[1,27312,"lerview添加HeaderView和FooterView， \n*"],[1,27320,"r"],[-1,27321," "],[1,27331,"r\n"],[1,27333,"不会破坏Targ"],[-1,27371,"\n```\n\n* 3, Sur"],[1,27385,"* 支持动态添加移除\n* 支持 LinearLayoutManager & GridLayoutManager 两种布局管理器\n\n"],[-1,27997,"\n\n\n dynamic add & remove\n\n```\n 支持动态添加移除\n\n```\n"]],[27205,27205],[27997,27997]]],[1520943708600,[null,[[1,27205,"* 4, Support LinearLayoutManager & GridLayotg*布局管理器\n```"],[1,27217,"* anyting with your target adapter\n\n```\n"],[-1,27217,"lerview添加HeaderView和FooterView， \n*"],[-1,27259,"r"],[1,27261," "],[-1,27270,"r\n"],[-1,27274,"不会破坏Targ"],[1,27320,"\n```\n\n* 3, Sur"],[-1,27320,"* 支持动态添加移除\n* 支持 LinearLayoutManager & GridLayoutManager 两种布局管理器\n\n"],[1,27997,"\n\n\n dynamic add & remove\n\n```\n 支持动态添加移除\n\n```\n"]],[27997,27997],[27205,27205]]],[1520943648666,["gengmei_pxf@gengmei123.local",[[1,27997,"`"]],[27997,27997],[27998,27998]]],[1520943650036,["gengmei_pxf@gengmei123.local",[[1,27994,"/**\n * 上传图片 */ private void uploadImage(String imgUrlAbsolute) {\n    showLD();\n  call = ApiService.instance().uploadFile(\"image\", RetrofitUtil.buildFilePart(\"file\", imgUrlAbsolute));\n  call.enqueue(new BusinessCallback(0) {\n\n        @Override\n  public void onSuccess(int requestCode, Object bean, GMResponse response) {\n            String path = ((JSONObject) bean).getString(\"file\");\n  pathArray.add(path);\n if (null != pathArray && pathArray.size() == array.size()) {\n                completeHandler.sendEmptyMessage(MESSAGE_GET_UPLOAD_IMAGE_COMPLETE);\n  }\n        }\n\n        @Override\n  public void onError(int requestCode, int errorCode, String errorMessage) {\n            ToastUtils.showText(errorMessage);\n  }\n\n        @Override\n  public void onComplete(int requestCode, Call call) {\n            super.onComplete(requestCode, call);\n  }\n    }); }"]],[27994,27994],[28846,28846]]],[1520943653975,["gengmei_pxf@gengmei123.local",[[-1,27994,"/**\n * 上传图片 */ private void uploadImage(String imgUrlAbsolute) {\n    showLD();\n  call = ApiService.instance().uploadFile(\"image\", RetrofitUtil.buildFilePart(\"file\", imgUrlAbsolute));\n  call.enqueue(new BusinessCallback(0) {\n\n        @Override\n  public void onSuccess(int requestCode, Object bean, GMResponse response) {\n            String path = ((JSONObject) bean).getString(\"file\");\n  pathArray.add(path);\n if (null != pathArray && pathArray.size() == array.size()) {\n                completeHandler.sendEmptyMessage(MESSAGE_GET_UPLOAD_IMAGE_COMPLETE);\n  }\n        }\n\n        @Override\n  public void onError(int requestCode, int errorCode, String errorMessage) {\n            ToastUtils.showText(errorMessage);\n  }\n\n        @Override\n  public void onComplete(int requestCode, Call call) {\n            super.onComplete(requestCode, call);\n  }\n    }); }"]],[28846,28846],[27994,27994]]],[1520943693794,["gengmei_pxf@gengmei123.local",[[1,27994,"![]"]],[27994,27994],[27997,27997]]],[1520943694992,["gengmei_pxf@gengmei123.local",[[-1,27994,"![]"]],[27997,27997],[27994,27994]]],[1520943695803,["gengmei_pxf@gengmei123.local",[[-1,27995,"```"]],[27998,27998],[27995,27995]]],[1520943696498,["gengmei_pxf@gengmei123.local",[[-1,27997,"\n"]],[27995,27995],[27994,27994]]],[1520943697077,["gengmei_pxf@gengmei123.local",[[-1,27996,"\n"]],[27994,27994],[27993,27993]]],[1520943697627,["gengmei_pxf@gengmei123.local",[[-1,27990,"```"]],[27993,27993],[27990,27990]]],[1520943700361,["gengmei_pxf@gengmei123.local",[[1,27990,"![]()"]],[27990,27990],[27995,27995]]],[1520943768600,[null,[[-1,27205,"* 4, Support LinearLayoutManager & GridLayotg*布局管理器\n```"],[-1,27272,"* anyting with your target adapter\n\n```\n"],[1,27312,"lerview添加HeaderView和FooterView， \n*"],[1,27320,"r"],[-1,27321," "],[1,27331,"r\n"],[1,27333,"不会破坏Targ"],[-1,27371,"\n```\n\n* 3, Sur"],[1,27385,"* 支持动态添加移除\n* 支持 LinearLayoutManager & GridLayoutManager 两种布局管理器\n\n"],[-1,27995,"\n\n\n dynamic add & remove\n\n```\n 支持动态添加移除\n\n```\n"]],[27205,27205],[27995,27995]]],[1520943768600,[null,[[1,27205,"* 4, Support LinearLayoutManager & GridLayotg*布局管理器\n```"],[1,27217,"* anyting with your target adapter\n\n```\n"],[-1,27217,"lerview添加HeaderView和FooterView， \n*"],[-1,27259,"r"],[1,27261," "],[-1,27270,"r\n"],[-1,27274,"不会破坏Targ"],[1,27320,"\n```\n\n* 3, Sur"],[-1,27320,"* 支持动态添加移除\n* 支持 LinearLayoutManager & GridLayoutManager 两种布局管理器\n\n"],[1,27995,"\n\n\n dynamic add & remove\n\n```\n 支持动态添加移除\n\n```\n"]],[27995,27995],[27205,27205]]],[1520943729095,["gengmei_pxf@gengmei123.local",[[-1,27990,"![]()"]],[27995,27995],[27990,27990]]],[1520943738566,["gengmei_pxf@gengmei123.local",[[1,27991,"![upload_img]($res/upload_img.png)\n\n"]],[27990,27990],[28026,28026]]],[1520943743111,["gengmei_pxf@gengmei123.local",[[1,28029,"\n"]],[28025,28025],[28026,28026]]],[1520943743503,["gengmei_pxf@gengmei123.local",[[1,28030,"\n"]],[28026,28026],[28027,28027]]]]],["1bcfa8aa-ed93-4f7a-9e24-eaf795e56454",1520943856108,"简历中的questions\n==\n*   **基础知识 – 四大组件（生命周期，使用场景，如何启动）**\n*   **java基础 – 数据结构，线程，mvc框架**\n*   **通信 – 网络连接（HttpClient，HttpUrlConnetion），Socket**\n*   **数据持久化 – SQLite，SharedPreferences，ContentProvider**\n*   **性能优化 – 布局优化，内存优化，电量优化**\n*   **安全 – 数据加密，代码混淆，WebView/Js调用，https**\n*   **UI– 动画**\n*   **其他 – JNI，AIDL，Handler，Intent等**\n*   **开源框架 – Volley，Gilde，RxJava等（简历上写你会的，用过的）**\n*   **拓展 – Android6.0/7.0/8.0特性，kotlin语言，I/O大会**\n\n## Android中的设计模式\n\n [Android中的设计模式](https://pxfile.github.io/2018/03/08/Android%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/)\n\n1.单例 全局性 减少对象创建，降低系统内存的消耗，减少gc次数和卡顿时间 初始化资源的工具类\n2.创建者模式 创建对象的参数很多且不定，参数个数和类型不确定， AlertDialog glide okhttp\n3.适配器模式 baseAdapter\n4.装饰模式 context\n5.外观模式 contextImple\n6.策略模式 属性动画 插值器\n7.组合模式 view和viewGroup\n8.模板方法 Activity fragment\n9.观察者模式 RxJava\n10.责任链模式 try catch，事件分发机制\n\n##  Android各组件和机制\n\n### [Activity](https://pxfile.github.io/2018/03/08/%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3Activity/)\n\nActivity\n\n#### 1.四大组件中Activity是用的最多也是最基础的，Activity提供窗口来与用户进行交互\n\n#### 2.Android默认会为每一个App应用提供一个task的栈老存放和管理该App所有的Activity task默认的name是该App的包名 也可以在mainfest清单文件中设置Activity的taskAffinity属性来自定义task，但是不建议这样使用，如果别App也设置一样的task，它就可能启动你的Activity，带来各种安全隐患\n\n#### 3.Activity的生命周期 onCreate -> onStart -> onResume -> onPause -> onStop -> onDestroy\n\n正常情况下生命周期的调用\n（1）A页面打开B页面或者切回到桌面 A Activity：onPause -》 onStop，如果B Activity采用了透明主题 则不会调用 onStop\n\n（2）先调用A的onPause再调用B的onResume方法\n\n（3）再回到A页面时，onRestart -》 onStart -》onResume\n\n（4）按返回键时，onPause -》 onStop -》onDestroy\n\n异常情况下在生命周期的调用\n\n（1）资源相关的系统配置发生改变时，Activity被杀死 例如Activity竖屏，突然旋转屏幕，Activity默认会销毁并重新创建\n\nonSaveInstanceState -》 onDestroy   重新创建  onCreate 。。。-》 onDestroy\n\n（2）系统资源不足导致优先级低的Activity被回收\n\nonSaveInstanceState -》 onDestroy   重新创建  onCreate 。。。-》 onDestroy\n\n#### 4.Activity信息保存和恢复\n\n系统会调用onSaveInstanceState来保存当前Activity的状态，这个方法调用的时机是在onStop之前，他和onPause没有既定的时序关系，他即可能在onPause之前调用，也有可能在之后调用，需要强调的是，这个方法只出现在Activity被异常终止的情况下，正常情况下是不会走这个方法的，当我们onSaveInstanceState保存到Bundler对象作为参数传递给onRestoreInstanceState和onCreate方法，因此我们可以通过onRestoreInstanceState和onCreate方法来判断Activity是否被重建。如果被重建了，我们就取出之前的数据恢复，从时序上来说，onRestoreInstanceState的调用时机应该在onStart之后\n\n#### 5.启动模式\n\n（1）定义启动模式的方法\n\nmanifest中声明 \n\n<activity\n            ．．．．．．\n            android:launchMode=\"standard\"\n             >\n           ．．．．．．．\n        </activity>\n\n 使用Intent标志\n\nIntent i = new Intent(this,ＮewActivity.class);\n\t\ti.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\t\tstartActivity(i);\n\n（2）模式类型\n\n**standard** 默认模式\n**singleTop** 当目标Activity位于task栈的栈顶时，直接复用，不会创建新的Activity，否则泽创建新的Activity并添加到task栈中\n**singleTask** 如果目标Activity位于Task栈顶中，则复用，如果没有位于栈顶就将目标Activity之前的Activity移除栈，然后调用，否则就创建新的Activity并添加到栈中\n**singleInstance** 如果目标Activity不存在，创建一个新的task栈添加目标Activity并调用，如果Activity已存在就将Activity所在的task移到前台并调用\n\n###  [Service](https://pxfile.github.io/2018/03/08/Service%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93/)\n\nService 应用程序组件 能够在后台执行耗时较长的操作，并且不提供界面\n\n#### Service分类\n\n##### 按运行分类\n\n* 前台Service \n\nstartForeground 开启前台服务 \n\nstopForeground  移除前台服务\n\n* 后台Service\n\n##### 按使用分类\n\n* 本地服务\n\n运用于应用程序内部实现一些耗时操作，并不占用Activity的线程，而是新开一个线程在后台执行 \n\nContext.startService 启动\n\nContext.stopService 结束\n\n在内部可以调用Service.stopSelf() 或 Service.stopSelfResult()来自己停止。\n\n* 远程服务 \n\n用于应用程序之间，可被其他应用程序复用 例如天气预报，其他应用程序不需要在写这样的服务，调用即可\n\n通过暴露接口供其他应用程序调用\n\n#### Contex.bindService 连接\n\n#### Context.unbinService 断开连接\n\n#### Service生命周期\n\n* onCreate -》 onStartCommand -》 onDestroy\n\n* onCreate -》 onBind =》onUnBind -》onDestroy\n\n#### onStartCommand()方法必须返回一个整数。\n\n* START_NOT_STICKY 杀死了服务，则不会重建服务\n\n* START_STICKY  杀死了服务，则将重建服务并调用onStartCommand()，但不会再次送入上一个intent  这适用于媒体播放器（或类似服务），它们不执行命令，但需要一直运行并随时待命\n\n* START_REDELIVER_INTENT 杀死了服务，则将重建服务并用上一个已送过的intent调用onStartCommand() 适用于那些需要立即恢复工作的活跃服务，比如下载文件\n\n#### start服务\n\n#### bind服务\n\n#### 在mainfest中声明服务\n\n``` \n<manifest ... >\n\t... \n\t<application ... >\n\t <service android:name=\".ExampleService\" /> \n\t... \n\t</application> \n</manifest>\n```\n\n###  [ContentProvider](https://pxfile.github.io/2018/03/08/ContentProvider%E5%AE%9E%E4%BE%8B%E8%AF%A6%E8%A7%A3/)\n\nContentProvider（内容提供者）是Android的四大组件之一，管理android以结构化方式存放的数据，以相对安全的方式封装数据（表）并且提供简易的处理机制和统一的访问接口供**其他程序**调用。　\n\n　　Android的数据存储方式总共有五种，分别是：Shared Preferences、网络存储、文件存储、外储存储、SQLite。但一般这些存储都只是在单独的一个应用程序之中达到一个数据的共享，有时候我们需要操作其他应用程序的一些数据，就会用到ContentProvider。而且Android为常见的一些数据提供了默认的ContentProvider（包括音频、视频、图片和通讯录等）。\n\n　　但注意ContentProvider它也只是一个中间人，真正操作的数据源可能是数据库，也可以是文件、xml或网络等其他存储方式。\n\n###  [BroadcastReceiver](https://pxfile.github.io/2018/03/08/BroadcastReceiver%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/)\n\n广播是一种广泛运用的在应用程序之间传输信息的机制，主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。\n\n　　在实现开机启动服务和网络状态改变、电量变化、短信和来电时通过接收系统的广播让应用程序作出相应的处理。\n\n　　BroadcastReceiver 自身并不实现图形用户界面，但是当它收到某个通知后， BroadcastReceiver 可以通过启动 Service 、启动 Activity 或是 NotificationMananger 提醒用户。\n\n静态注册\n\n在AndroidManifest.xml的application里面定义receiver并设置要接收的action。\n\n``` \n< receiver android:name = \".MyBroadcastReceiver\" > \n < intent-filter android:priority = \"777\" > <action android:name = \"android.provider.Telephony.SMS_RECEIVED\" /> </ intent-filter >  </ receiver > \n```\n动态注册\n在Activity中声明BroadcastReceiver的扩展对象，在onResume中注册，onPause中卸载.\n\n#### 静态注册和动态注册的区别\n \n  　　1、静态注册的广播接收者一经安装就常驻在系统之中，不需要重新启动唤醒接收者；\n　　动态注册的广播接收者随着应用的生命周期，由registerReceiver开始监听，由unregisterReceiver撤销监听，如果应用退出后，没有撤销已经注册的接收者应用应用将会报错。\n\n　　2、当广播接收者通过intent启动一个activity或者service时，如果intent中无法匹配到相应的组件。　\n　　动态注册的广播接收者将会导致应用报错\n　　而静态注册的广播接收者将不会有任何报错，因为自从应用安装完成后，广播接收者跟应用已经脱离了关系。\n\n#### 总结\n\n- 静态广播接收的处理器是由PackageManagerService负责，当手机启动或者新安装了应用的时候，PackageManagerService会扫描手机中所有已安装的APP应用，将AndroidManifest.xml中有关注册广播的信息解析出来，存储至一个全局静态变量当中。\n\n - 动态广播接收的处理器是由ActivityManagerService负责，当APP的服务或者进程起来之后，执行了注册广播接收的代码逻辑，即进行加载，最后会存储在一个另外的全局静态变量中。需要注意的是：\n\n　　 1、 这个并非是一成不变的，当程序被杀死之后，已注册的动态广播接收器也会被移出全局变量，直到下次程序启动，再进行动态广播的注册，当然这里面的顺序也已经变更了一次。\n\n　　 2、这里也并没完整的进行广播的排序，只记录的注册的先后顺序，并未有结合优先级的处理。\n\n - 广播发出的时候，广播接收者接收的顺序如下：\n\n　　１．当广播为**普通广播**时，有如下的接收顺序：\n\n　　无视优先级\n　　动态优先于静态\n　　同优先级的动态广播接收器，**先注册的大于后注册的** 　　同优先级的静态广播接收器，**先扫描的大于后扫描的**　\n\n　　２．如果广播为**有序广播**，那么会将动态广播处理器和静态广播处理器合并在一起处理广播的消息，最终确定广播接收的顺序：　\n\n　　优先级高的先接收　\n　　同优先级的动静态广播接收器，**动态优先于静态** 　　同优先级的动态广播接收器，**先注册的大于后注册的** 　　同优先级的静态广播接收器，**先扫描的大于后扫描的**\n\n#### **广播怎么不跨进程**\n\n无论是使用扩展变量作用域、基于接口的回调还是Handler-post/Handler-Message等方式，都可以直接处理此类问题，若适用广播机制，显然有些“杀鸡牛刀”的感觉，会显太“重”；\n\n##  模块化和组件化开发\n[模块化和组件化开发](https://pxfile.github.io/2018/03/02/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/)\n\n### 模块化\n按照功能划分成相互独立的模块，使其只包含与其相关的功能。登录，搜索，交易，社区等\n### 组件化\n基于可重用的目的，将一个系统按照拆分关注点的形式，拆分成一个的组件，减少解耦\n\n### 模块化vs组件化\n\n模块化和组件化本质思想是一样的,都是”大化小”,两者的目的都是为了重用和解耦,只是叫法不一样.如果非要说区别,那么可以认为模块化粒度更小,更侧重于重用,而组件化粒度稍大于模块,更侧重于业务解耦。\n\n### 优点\n\n*   **1.模块间解耦，复用，避免重复造轮子，节省开发维护成本** 对业务进行模块化拆分后，为了使各业务模块间解耦，因此各个都是独立的模块，它们之间是没有依赖关系。每个模块负责的功能不同，业务逻辑不同，模块间业务解耦。模块功能比较单一，可在多个项目中使用\n\n*   **2.可单独编译某个模块，降低项目复杂性，提升开发效率** 每个模块实际上也是一个完整的项目，可以进行单独编译，调试\n\n*   **3.可以多团队并行开发，测试 多个团队公用同一个组件，在一定层度上确保了技术方案的统一性** 每个团队负责不同的模块，提升开发，测试效率\n\n##  Android开发模式(MVC，MVVM，MVP)\n[浅谈MVC、MVP、MVVM架构模式的区别和联系](http://www.cnblogs.com/guwei4037/p/5591183.html)\n\n### MVC \nView  xml\nController Activity\nModel 建立的数据机构和相关的类\n\n1.View传达指令到Controller\n2.Controller完成业务逻辑后，要求Model改变状态\n3.Model将新的数据发送给View，更新视图，用户得到反馈 \n\nMVC可分为2种 \n\n1.通过View接受指令\n2.通过Controller接受指令\n\n缺点\n\n在Android开发中，Activity并不是一个标准的MVC模式中的Controller，它的首要职责是加载应用的布局和初始化用户界面 ，并接受并处理来自用户的操作请求，进而作出响应。随着界面及其逻辑的复杂度不断提升， Activity类的职责不断增加，以致变得庞大臃肿。\n\n### MVP\n在App开发过程中，经常出现的问题就是某部分的代码过 ，虽然做模块划分和接隔离，但也很难完全避免。从实践中看到，这多的出现在UI部分，也就是Activity 。想象下， 个2000+ 以上基本 带注释的Activity，我的第 反应就是想吐。Activity内容过多的原因其实很好解释，因为Activity本身需要担负 与用户之间的操作交互，界面的展示， 是单纯的Controller或View。 且现在部分的Activity还对整个App 起到类似iOS中的【ViewController】的作 ，这又带入的逻辑代码，造成Activity的臃肿。为 解决这个问题，让我们引MVP框架。\n\n将Controller改成了Presenter，同时改变了通信方向\n1.Presenter和View是可以双向通信的\n2.Presenter和Model也是可以双向通信的\n3.View和Model之间不能通信，都是通过Presenter传递的\n4.View和薄，没有任何业务逻辑，而Presenter很厚，所有的业务逻辑都在这处理\n\n\n\n### MVVM\n将Presenter改成了Viewmodel，通信方式基本和MVP差不多，最大的区别是MVVM有双向绑定，View的变动反映在ViewModel上，ViewModel的修改也会更新View\n\n## 事件分发机制\n[事件分发机制](https://www.jianshu.com/p/38015afcdb58)\n\n![onTouchEvent](https://upload-images.jianshu.io/upload_images/944365-aea821bbb613c195.png)\n\n## Handler机制\n[Handler机制](https://pxfile.github.io/2018/03/08/%E7%B2%BE%E9%80%9AAndroid%E4%B8%8B%E7%9A%84Handler%E6%9C%BA%E5%88%B6/)\n\n![](http://upload-images.jianshu.io/upload_images/1824194-a947dcc5b22f69fb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n*   1.在创建Activity之前，当系统启动的时候，先加载ActivityThread这个类，在这个类中的main函数，调用了Looper.prepareMainLooper()方法进行初始化Looper对象；\n\n*   2.然后创建了主线程的handler对象（Tips：加载ActivityThread的时候，其内部的Handler对象[静态的]还未创建）；\n\n*   3.随后才创建了ActivityThread对象；\n\n*   4.最后调用了Looper.loop();方法，不断的进行轮询消息队列的消息。\n\n*   也就是说，在ActivityThread和Activity创建之前（同样也是Handler创建之前，当然handler由于这两者初始化），就已经开启了Looper的loop()方法，不断的进行轮询消息。\n\n* 需要注意的是，这个轮询的方法是阻塞式的，没有消息就一直等待（实际是等着MessageQueue的next()方法返回消息）。\n\n* 在应用一执行的时候，就已经开启了Looper，并初始化了Handler对象。此时，系统的某些组件或者其他的一些活动等发送了系统级别的消息，这个时候主线程中的Looper就可以进行轮询消息，并调用msg.target.dispatchMessage(msg)（msg.target即为handler）进行分发消息，并通过handler的handleMessage方法进行处理；所以会优于我们自己创建的handler中的消息而处理系统消息。\n\n下面，我们按照启动顺序来进行源码分析：\n\n![](http://upload-images.jianshu.io/upload_images/1824194-298ebb16ce4a3b70.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 让主线程给子线程发送消息\n\n### 1、首先我们在Activity中的onCreate方法中开启一个子线程，然后在子线程中进行Looper和Handler的创建等\n\n```\n@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                /**\n                 *  1、创建了Looper对象，然后Looper对象中创建了MessageQueue\n                 *  2、并将当前的Looper对象跟当前的线程（子线程）绑定ThreadLocal\n                 */\n                Looper.prepare();\n\n                /**\n                 * 1、创建Handler对象，然后从当前线程中获取Looper对象，然后获取到MessageQueue对象\n                 */\n                subHandler = new Handler(){\n                    @Override\n                    public void handleMessage(Message msg) {\n                        super.handleMessage(msg);\n                        Toast.makeText(MainActivity.this,msg.obj.toString(),Toast.LENGTH_LONG).show();\n                    }\n                };\n\n                /**\n                 * 1、从当前线程中找到之前创建的Looper对象，然后找到MessageQueue\n                 * 2、开启死循环，遍历消息池中的消息\n                 * 3、当获取到msg的时候，调用这个msg的handler的dispatchMsg方法，让msg执行起来\n                 */\n                Looper.loop();\n                Log.e(\"zxj\",\"loop()方法执行完了\");\n            }\n        }).start();\n    }\n\n```\n\n### 2、然后在点击事件中发送消息\n\n```\npublic void onSendClick(View v){\n    //从消息池中获取一个旧的msg，如果没有，重新创建消息\n    Message message = subHandler.obtainMessage(1, \"我是主线程发送来是消息\");\n    message.sendToTarget();\n}\n\n```\n\n### 3、问题\n\n以上的写法还是存在一些问题的，其实你在运行起来后，点击按钮发送消息后，当你退出当前Activity后，发现上面定义的log日志，没有执行，这就说明，那个子线程一直未执行完，为啥呢？其实就是因为loop()这个方法，因为这个方法就一个死循环的，所以这个方法一直在循环中，从而导致子线程一直没有执行完，最终会导致内存泄露\n\n### 4、解决方法\n\n在子线程中拿到创建的Looper对象(Looper.myLooper()),然后在onDestroy中中止loop方法\n\n```\n@Override\nprotected void onDestroy() {\n    super.onDestroy();\n    if(myLooper != null)\n        myLooper.quit();\n}\n\n```\n### 5、最终代码\n\n```\npublic class MainActivity extends AppCompatActivity {\n    private Handler subHandler;//是在子线程中创建的Handler对象\n    private Looper myLooper;//子线程中的Looper对象\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                /**\n                 *  1、创建了Looper对象，然后Looper对象中创建了MessageQueue\n                 *  2、并将当前的Looper对象跟当前的线程（子线程）绑定ThreadLocal\n                 */\n                Looper.prepare();\n\n                /**\n                 * 1、创建Handler对象，然后从当前线程中获取Looper对象，然后获取到MessageQueue对象\n                 */\n                subHandler = new Handler(){\n                    @Override\n                    public void handleMessage(Message msg) {\n                        super.handleMessage(msg);\n                        Toast.makeText(MainActivity.this,msg.obj.toString(),Toast.LENGTH_LONG).show();\n                    }\n                };\n\n                //获取当前线程中的Looper对象\n                myLooper = Looper.myLooper();\n\n                /**\n                 * 1、从当前线程中找到之前创建的Looper对象，然后找到MessageQueue\n                 * 2、开启死循环，遍历消息池中的消息\n                 * 3、当获取到msg的时候，调用这个msg的handler的dispatchMsg方法，让msg执行起来\n                 */\n                Looper.loop();\n                Log.e(\"zxj\",\"loop()方法执行完了\");\n            }\n        }).start();\n    }\n\n    public void onSendClick(View v){\n        //从消息池中获取一个旧的msg，如果没有，重新创建消息\n        Message message = subHandler.obtainMessage(1, \"我是主线程发送来是消息\");\n        message.sendToTarget();\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        if(myLooper != null)\n            myLooper.quit();\n    }\n}\n```\n\n## 机型适配\n[机型适配](http://blog.csdn.net/mwq384807683/article/details/72594027)\n\n* **魅族3和魅族4**\n\n场景：魅族手机ListView的Item中的EditText无法编辑，点击EditText弹出软键盘后，软键盘会立即自动隐藏 \n机型：[魅族3，魅族4] \n解决方案： \n方法一：将ListView换成RecyclerView\n\n方法二：[https://github.com/Aspsine/EditTextInListView](https://github.com/Aspsine/EditTextInListView)\n\n* **HTC M8**\n\n场景：HTC M8 从一个Activity 使用QQSDK 登陆, 登陆成功后, 返回Activity结果Activity 被销毁了 \n机型：HTC M8 等某些带有 虚拟 Menu 键盘的手机 \n解决方案：后来调查发现是这个Activity是全屏,屏蔽了Menu键盘的黑条. 但是跳转到QQ却把那个Menu的黑条显示了出来, 这导致发生了 screenSize 的变化 从而导致我的Activity销毁了. \n知道了这个原因, 在manifest中的 configChanges 添加screenSize 解决了这个问题.\n\n* **所有手机**\n\nPopupWindow中嵌套EditText，会出现EditText长按无法触发“粘贴”选项，可以改成Dialog嵌套EditText，包括DialogFragment。\n\n* **所有手机**\n\n场景：输入法中的emoji适配，Android4.1之前的系统不支持emoji显示\n\n解决方案：所以对于Android4.1之前的系统，我采用了bitmap来显示emoji。\n\n* **OPPO 手机**\n\n场景：OPPO 手机启动 Service 报 SecurityException \n解决方案：try catch 该异常\n\n## 性能优化\n [性能优化](https://pxfile.github.io/2018/03/08/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/)\n\n## 内存泄漏\n [内存泄漏](https://pxfile.github.io/2018/02/14/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/)\n\n## Binder机制\n [Binder机制](https://pxfile.github.io/2018/03/07/Binder%E6%9C%BA%E5%88%B6/)\n\n## 混合开发\n[混合开发](https://bxbxbai.github.io/2015/08/16/talk-about-bybird-app/)\n\n## [HTTPS和HTTP的区别](http://blog.csdn.net/whatday/article/details/38147103)\n\n### 什么是 HTTPS?\n\nHTTPS (基于安全套接字层的超文本传输协议 或者是 HTTP over SSL) 是一个 Netscape 开发的 Web 协议。\n\n你也可以说：HTTPS = HTTP + SSL\n\nHTTPS 在 HTTP 应用层的基础上使用安全套接字层作为子层。\n\n### 为什么需要 HTTPS ？\n\n超文本传输协议 (HTTP) 是一个用来通过互联网传输和接收信息的协议。HTTP 使用请求/响应的过程，因此信息可在服务器间快速、轻松而且精确的进行传输。当你访问 Web 页面的时候你就是在使用 HTTP 协议，但 HTTP 是不安全的，可以轻松对窃听你跟 Web 服务器之间的数据传输。在很多情况下，客户和服务器之间传输的是敏感歇息，需要防止未经授权的访问。为了满足这个要求，网景公司(Netscape)推出了[HTTPS](http://www.nowamagic.net/librarys/veda/tag/https)，也就是基于安全套接字层的 HTTP 协议。\n\n### HTTP 和 HTTPS 的相同点\n\n大多数情况下，HTTP 和 HTTPS 是相同的，因为都是采用同一个基础的协议，作为 HTTP 或 HTTPS 客户端——浏览器，设立一个连接到 Web 服务器指定的端口。当服务器接收到请求，它会返回一个状态码以及消息，这个回应可能是请求信息、或者指示某个错误发送的错误信息。系统使用统一资源定位器 URI 模式，因此资源可以被唯一指定。而 HTTPS 和 HTTP 唯一不同的只是一个协议头(https)的说明，其他都是一样的。\n\n### HTTP 和 HTTPS 的不同之处\n\n1.  HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头\n2.  HTTP 是不安全的，而 HTTPS 是安全的\n3.  HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443\n4.  在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层\n5.  HTTP 无需加密，而 HTTPS 对传输的数据进行加密\n6.  HTTP 无需证书，而 HTTPS 需要认证证书\n\n### HTTPS 如何工作?\n\n使用 HTTPS 连接时，服务器要求有公钥和签名的证书。\n\n当使用 https 连接，服务器响应初始连接，并提供它所支持的加密方法。作为回应，客户端选择一个连接方法，并且客户端和服务器端交换证书验证彼此身份。完成之后，在确保使用相同密钥的情况下传输加密信息，然后关闭连接。为了提供 https 连接支持，服务器必须有一个公钥证书，该证书包含经过证书机构认证的密钥信息，大部分证书都是通过第三方机构授权的，以保证证书是安全的。\n\n换句话说，HTTPS 跟 HTTP 一样，只不过增加了 [SSL](http://www.nowamagic.net/librarys/veda/tag/SSL)。\n\nHTTP 包含如下动作：\n\n1.  浏览器打开一个 TCP 连接\n2.  浏览器发送 HTTP 请求到服务器端\n3.  服务器发送 HTTP 回应信息到浏览器\n4.  TCP 连接关闭\n\nSSL 包含如下动作：\n\n1.  验证服务器端\n2.  允许客户端和服务器端选择加密算法和密码，确保双方都支持\n3.  验证客户端(可选)\n4.  使用公钥加密技术来生成共享加密数据\n5.  创建一个加密的 SSL 连接\n6.  基于该 SSL 连接传递 HTTP 请求\n\n### 什么时候该使用 HTTPS?\n\n银行网站、支付网关、购物网站、登录页、电子邮件以及一些企业部门的网站应该使用 HTTPS，例如：\n\n*   PayPal: https://www.paypal.com\n*   Google AdSense: https://www.google.com/adsense/\n\n如果某个网站要求你填写信用卡信息，首先你要检查该网页是否使用 https 加密连接，如果没有，那么请不要输入任何敏感信息如信用卡号。\n\n## 如何有效的减少重复的代码\n\n**一、使用include标签引用重复布局**\n\n**二、使用style定义样式**\n\n**三、使用ViewStub减少整体布局的重复**\n\n**四、多使用应用资源**\n\n**五、代码的抽象与继承**\n\n## Android进程保活\n\n### 黑色保活\n利用不同App进程相互广播来相互唤醒\n\n**场景1**：开机，网络切换、拍照、拍视频时候，利用系统产生的广播唤醒app\n\n**场景2**：接入第三方SDK也会唤醒相应的app进程，如微信sdk会唤醒微信，支付宝sdk会唤醒支付宝。由此发散开去，就会直接触发了下面的 **场景3**\n\n**场景3**：假如你手机里装了支付宝、淘宝、天猫、UC等阿里系的app，那么你打开任意一个阿里系的app后，有可能就顺便把其他阿里系的app给唤醒了。（只是拿阿里打个比方，其实BAT系都差不多）\n\n针对**场景1**，估计Google已经开始意识到这些问题，所以在最新的Android N取消了 ACTION_NEW_PICTURE（拍照），ACTION_NEW_VIDEO（拍视频），CONNECTIVITY_ACTION（网络切换）等三种广播，无疑给了很多app沉重的打击。\n\n而开机广播的话，记得有一些定制ROM的厂商早已经将其去掉。\n\n针对**场景2**和**场景3**，因为调用SDK唤醒app进程属于正常行为，此处不讨论。但是在借助LBE分析app之间的唤醒路径的时候，发现了两个问题：\n\n1.  很多推送SDK也存在唤醒app的功能\n2.  app之间的唤醒路径真是多，且错综复杂\n\n### 白色保活\n调用系统api启动一个前台的Service进程，这样会在系统的通知栏生成一个Notification，用来让用户知道有这样一个app在运行着，哪怕当前的app退到了后台。QQ音乐就是这样。\n\n### 灰色保活\n灰色保活，这种保活手段是应用范围最广泛。它是利用系统的漏洞来启动一个前台的Service进程，与普通的启动方式区别在于，它不会在系统通知栏处出现一个Notification，看起来就如同运行着一个后台Service进程一样。这样做带来的好处就是，用户无法察觉到你运行着一个前台进程（因为看不到Notification）,但你的进程优先级又是高于普通后台进程的。\n\n那么如何利用系统的漏洞呢，大致的实现思路和代码如下：\n\n*   思路一：API < 18，启动前台Service时直接传入new Notification()；\n*   思路二：API >= 18，同时启动两个id相同的前台Service，然后再将后启动的Service做stop处理；\n\n```\n\npublic class GrayService extends Service {\n\n    private final static int GRAY_SERVICE_ID = 1001;\n\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        if (Build.VERSION.SDK_INT < 18) {\n            startForeground(GRAY_SERVICE_ID, new Notification());//API < 18 ，此方法能有效隐藏Notification上的图标\n        } else {\n            Intent innerIntent = new Intent(this, GrayInnerService.class);\n            startService(innerIntent);\n            startForeground(GRAY_SERVICE_ID, new Notification());\n        }\n\n        return super.onStartCommand(intent, flags, startId);\n    }\n\n    ...\n    ...\n\n    /**\n     * 给 API >= 18 的平台上用的灰色保活手段\n     */\n    public static class GrayInnerService extends Service {\n\n        @Override\n        public int onStartCommand(Intent intent, int flags, int startId) {\n            startForeground(GRAY_SERVICE_ID, new Notification());\n            stopForeground(true);\n            stopSelf();\n            return super.onStartCommand(intent, flags, startId);\n        }\n\n    }\n}\n```\n[Android 进程保活招式大全](https://segmentfault.com/a/1190000006251859)\n\n## Dalvik虚拟机与java虚拟机的区别\n\n* 1.java虚拟机运行的是Java字节码，Dalvik虚拟机运行的是Dalvik字节码；传统的Java程序经过编译，生成Java字节码保存在class文件中，java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Dalvik字节码，所有的Dalvik字节码由Java字节码转换而来，并被打包到一个DEX(Dalvik Executable)可执行文件中Dalvik虚拟机通过解释Dex文件来执行这些字节码。\n\n* 2.Dalvik可执行文件体积更小。SDK中有一个叫dx的工具负责将java字节码转换为Dalvik字节码。\n\n* 3.java虚拟机与Dalvik虚拟机架构不同。java虚拟机基于栈架构。程序在运行时虚拟机需要频繁的从栈上读取或写入数据。这过程需要更多的指令分派与内存访问次数，会耗费不少CPU时间，对于像手机设备资源有限的设备来说，这是相当大的一笔开销。Dalvik虚拟机基于寄存器架构，数据的访问通过寄存器间直接传递，这样的访问方式比基于栈方式快的多.\n\n## HttpClient与HttpUrlConnection的区别\n\nVolley框架的源码，在Android 2.3及以上版本，使用的是HttpURLConnection，而在Android 2.2及以下版本，使用的是HttpClient。\n\n### 哪一种才是最好的？\n\n在Android 2.2版本之前，HttpClient拥有较少的bug，因此使用它是最好的选择。\n\n而在Android 2.3版本及以后，HttpURLConnection则是最佳的选择。它的API简单，体积较小，因而非常适用于Android项目。压缩和缓存机制可以有效地减少网络访问的流量，在提升速度和省电方面也起到了较大的作用。对于新的应用程序应该更加偏向于使用HttpURLConnection.\n\n[Android访问网络，使用HttpURLConnection还是HttpClient？](http://blog.csdn.net/sinyu890807/article/details/12452307)\n\n## 三级缓存（各大图片框架都可以扯到这上面来） \n（1）内存缓存，（2）本地缓存，（3）网络 \n* 内存：\n[http://blog.csdn.net/guolin_blog/article/details/9526203](http://blog.csdn.net/guolin_blog/article/details/9526203)\n内存缓存使用的是**LruCache**\n \n* 本地：[http://blog.csdn.net/guolin_blog/article/details/28863651](http://blog.csdn.net/guolin_blog/article/details/28863651)\n本地缓存使用的是**Android DiskLruCache**\n\n## RecyclerView\n有了ListView、GridView为什么还需要RecyclerView这样的控件呢？整体上看RecyclerView架构，提供了一种插拔式的体验，高度的解耦，异常的灵活，通过设置它提供的不同LayoutManager，ItemDecoration , ItemAnimator实现令人瞠目的效果。\n\n*   你想要控制其显示的方式，请通过布局管理器LayoutManager\n*   你想要控制Item间的间隔（可绘制），请通过ItemDecoration\n*   你想要控制Item增删的动画，请通过ItemAnimator\n*   你想要控制点击、长按事件，请自己写（擦，这点尼玛。）\n\n## 多个进程同时调用一个ContentProvider的query获取数据，ContentPrvoider是如何反应的呢？\n一个content provider可以接受来自另外一个进程的数据请求。尽管ContentResolver与ContentProvider类隐藏了实现细节，但是ContentProvider所提供的query()，insert()，delete()，update()都是在ContentProvider进程的线程池中被调用执行的，而不是进程的主线程中。这个线程池是有Binder创建和维护的，其实使用的就是每个应用进程中的Binder线程池。\n\n## Android设计ContentProvider的目的是什么？\n\n*   1.  隐藏数据的实现方式，对外提供统一的数据访问接口；\n*   1.  更好的数据访问权限管理。ContentProvider可以对开发的数据进行权限设置，不同的URI可以对应不同的权限，只有符合权限要求的组件才能访问到ContentProvider的具体操作。\n*   1.  ContentProvider封装了跨进程共享的逻辑，我们只需要Uri即可访问数据。由系统来管理ContentProvider的创建、生命周期及访问的线程分配，简化我们在应用间共享数据（进程间通信）的方式。我们只管通过ContentResolver访问ContentProvider所提示的数据接口，而不需要担心它所在进程是启动还是未启动\n\n## 运行在主线程的ContentProvider为什么不会影响主线程的UI操作?\n\n*   1.  ContentProvider的onCreate()是运行在UI线程的，而query()，insert()，delete()，update()是运行在线程池中的工作线程的，所以调用这向个方法并不会阻塞ContentProvider所在进程的主线程，但可能会阻塞调用者所在的进程的UI线程！\n*   1.  所以，调用ContentProvider的操作仍然要放在子线程中去做。虽然直接的CRUD的操作是在工作线程的，但系统会让你的调用线程等待这个异步的操作完成，你才可以继续线程之前的工作。\n\n## synchronized函数和synchronized代码块的区别\n\n*   1.  首先synchronized函数和synchronized代码快的作用范围有区别，synchronized函数一般锁定的是当前类对象，synchronized代码块锁定作用域可以选择是本对象，也可以是字符串等等.\n*   1.  当前类对象锁没有释放的时候，本类的所有synchronized(this)同步代码块都阻塞。如果有并发请求synchronized函数，同一时间只能有一个请求执行 .\n*   1.  但是当前类对象锁没有释放的时候，其他请求可以访问本类中不带synchronized(this)的代码块，也可以访问非同一把锁的代码块例如synchronized(Str)等.\n*   1.  由于作用范围有区别，一般作用范围越小执行效率越高，平时开发中一般选择作用范围较小的synchronized.\n\n## Android中Service是否是区别于Activity的进程还是在你应用中的进程?\n\n| 类别 | 区别 | 优点 | 缺点 | 应用 |\n|---|---|---|---|---|\n| 本地服务 | 该服务依附在主进程上 | 服务依附在主进程上而不是独立的进程，这样在一定程度上节约了资源，另外Local服务因为是在同一进程因此不需要IPC，也不需要AIDL。相应`bindService会`方便很多。 | 主进程被Kill后，服务便会终止。 | 如：音乐播放器播放等不需要常驻的服务。 | 如：音乐播放器播放等不需要常驻的服务。 |\n| 远程服务 | 该服务是独立的进程 | 服务为独立的进程，对应进程名格式为所在包名加上你指定的`android:process`字符串。由于是独立的进程，因此在Activity所在进程被Kill的时候，该服务依然在运行，不受其他进程影响，有利于为多个进程提供服务具有较高的灵活性。 | 该服务是独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。 |  一些提供系统服务的Service，这种Service是常驻的。 |\n\n## Android的AMS和WMS理解\n\n## Android逆向\n\n###   Android中如果函数内的方法需要被更改，你是如何做的呢？ \n\n直接进行使用汇编在此处进行使用跳转语句修改后，再跳回来。好好运行的程序怎么可能让你直接用汇编操作，有一个框架已经实现了。 \n[Android中的so注入(inject)和挂钩(hook) - For both x86 and arm](http://blog.csdn.net/jinzhuojun/article/details/9900105) \n[看雪论坛上 inline hook的实现原理](https://bbs.pediy.com/thread-180918.htm) \n[看雪牛人放出的：libinject](https://bbs.pediy.com/thread-141355.htm)\n\n###  可以给我说一下 大端和小端（Big endian and Little endian）嘛？  \n[大端和小端（Big endian and Little endian）](http://www.cnblogs.com/luxiaoxun/archive/2012/09/05/2671697.html)\n\n## Android JNI开发\n\n###   如何捕获在线上服务中SO出现的异常，你是怎么获取奔溃的堆栈信息呢。 \n    这个问题我真的没想过，都是用Application 实现`Thread.UncaughtExceptionHandler`接口做未捕获异常上报。这下在JNI层的so出现异常该怎么做呢。 \n    [JNI异常处理](http://blog.csdn.net/xyang81/article/details/45770551)\n\n    **题外话：**\n\n    1.  [JNI/NDK的开发指南的专栏](http://blog.csdn.net/column/details/blogjnindk.html)\n    2.  [NDK-Stack定位crash](http://blog.csdn.net/a568478312/article/details/78182422)\n###   ENV是几级指针 \n    这里要区分 C还是C++了，C是二级指针，而C++中是一级指针\n\n###   adb你会使用吗？说说你经常用的命令？ \n    [ADB的相关命令](https://developer.android.com/studio/command-line/adb.html?hl=zh-cn)\n###   你会linux嘛？罗列进程是那个指令？\n\n    ps命令查找与进程相关的PID号\n\t使用kill命令结束进程：kill xxx \n    常用：kill －9 324\n\tLinux下还提供了一个killall命令，可以直接使用进程的名字而\t     不是进程标识号 \n    例如：# killall -9 NAME\n###  Android中如果你声明了一个Activity的class类，但没有在清单文件中声明他，是否可以将其吊起？ 如果不能 有什么方法可以吊起嘛?\n[Android免清单注册吊起Activity](http://blog.csdn.net/qfanmingyiq/article/details/78216446)\n\n## IOS逆向\n\n###  ASO体系并不是这么简单，你确定你开发的是有效的？ \n    我只能说，在我开发出来时候，做了（改机，清keychain，AppStore排名优化，自动启动AppStore,账号登录登出，适配10系统，评论功能，模拟触碰，动态IP池，自动下载和成功后的取消下载）。我只能说我当时做出来是有效的，Apple的策略改变没有，在公司倒闭后 我就没再更深的了解了。这个东西并不是那么容易玩的转的。\n\n###  你除了对arm汇编 了解完 你懂x86汇编嘛？（哎 我一个玩arm平台的 突然问我x86我还是依然懵逼） \n    [X86汇编指令](http://www.cnblogs.com/YukiJohnson/archive/2012/10/27/2741836.html)\n\n## final, finally, finalize的区别\n\n*   final 用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承.\n\n*   finally 是异常处理语句结构的一部分，表示总是执行.\n\n*   finalize 是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用.\n\n## [Android 多线程编程的总结](https://www.diycode.cc/topics/213)\n\n## RecyclerView 和 ListView\n### 布局效果对比\nListView只有一种滑动布局\nRecyclerView通过布局管理器能展示多种布局\n\n### API 使用对比\nListView 的基础使用大家再熟悉不过，其使用的关键点主要如下：\n\n*   继承重写 BaseAdapter 类\n*   自定义 ViewHolder 和 convertView 一起完成复用优化工作\n\n由于 ListView 已经老生常谈，所以此处就不去写示例代码了。 RecyclerView 基础使用关键点同样有两点：\n\n*   继承重写 RecyclerView.Adapter 和 RecyclerView.ViewHolder\n*   设置布局管理器，控制布局效果\n\n### 空数据处理\n\n* ListView 提供了 setEmptyView 这个 API 来让我们处理 Adapter 中数据为空的情况，只需轻轻一 set 就能搞定一切。代码设置和效果如下\n\n```\n\nmListView = (ListView) findViewById(R.id.listview);\n        mListView.setEmptyView(findViewById(R.id.empty_layout));//设置内容为空时显示的视图\n\n```\n* RecyclerView没有相应的API，需要自己动手去完成\n\n### HeaderView 和 FooterView\n\n* 在 ListView 的设计中，存在着 HeaderView 和 FooterView 两种类型的视图，并且系统也提供了相应的 API 来让我们设置\n\n* RecyclerView没有相应的API，需要自己动手去完成\n\n### 局部刷新\n* ListView 并没有提供局部刷新刷新某个 Item 的 API 给我们，同样自己自足，套路大致如下方的 updateItemView：\n\n```\n\npublic class AuthorListAdapter extends BaseAdapter {\n\n    ...\n\n    @Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n        ...\n        return convertView;\n    }\n\n    /**\n     * 更新Item视图，减少不必要的重绘\n     *\n     * @param listView\n     * @param position\n     */\n    public void updateItemView(ListView listView, int position) {\n        //换算成 Item View 在 ViewGroup 中的 index\n        int index = position - listView.getFirstVisiblePosition();\n        if (index >= 0 && index < listView.getChildCount()) {\n            //更新数据\n            AuthorInfo authorInfo = mAuthorInfoList.get(position);\n            authorInfo.setNickName(\"Google Android\");\n            authorInfo.setMotto(\"My name is Android .\");\n            authorInfo.setPortrait(R.mipmap.ic_launcher);\n            //更新单个Item\n            View itemView = listView.getChildAt(index);\n            getView(position, itemView, listView);\n        }\n    }\n\n}\n\n```\n\n即可实现刷新单个 Item 的效果\n\n[RecyclerView.Adapter](https://link.jianshu.com/?t=https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html) 则我们提供了 notifyItemChanged 用于更新单个 Item View 的刷新，我们可以省去自己写局部更新的工作。\n\n![](https://upload-images.jianshu.io/upload_images/912181-b8051dce7450291e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\n### 动画效果\n\n* 作为 ListView 自身并没有为我们提供封装好的 API 来实现动画效果切换。所以，如果要给 ListView 的 Item 加动画，我们只能自己通过属性动画来操作 Item 的视图。 Github 也有很多封装得好好的开源库给我们用，如：[ListViewAnimations](https://link.jianshu.com?t=https://github.com/nhaarman/ListViewAnimations)\n\n* RecyclerView 则为我们提供了很多基本的动画 API ，如下方的**增删移改**\n\n![](https://upload-images.jianshu.io/upload_images/912181-af00cdaa75008b0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\n简单的调用即可实现相应的效果，用起来方便很多，视觉交互上也会更好些\n\n### 监听 Item 的事件\n* ListView 为我们准备了几个专门用于监听 Item 的回调接口，如单击、长按、选中某个 Item 等\n\n![](https://upload-images.jianshu.io/upload_images/912181-eb82b15ab33d5bc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\n* RecyclerView ，它并没有像 ListView 提供太多关于 Item 的某种事件监听，唯一的就是 addOnItemTouchListener\n\n### 嵌套滚动机制\nRecyclerView支持嵌套滑动\nListView不支持\n\n## RecyclerView与ListView的滑动对比\n\n* RecyclerView的滑动\n\nRecyclerView的滑动过程可以分为2个阶段：手指在屏幕上移动，使RecyclerView滑动的过程，可以称为scroll；手指离开屏幕，RecyclerView继续滑动一段距离的过程，可以称为fling。\n\n当RecyclerView接收到ACTION_MOVE事件后，会先计算出手指移动距离（dy），并与滑动阀值（mTouchSlop）比较，当大于此阀值时将滑动状态设置为SCROLL_STATE_DRAGGING，而后调用scrollByInternal()方法，使RecyclerView滑动，这样RecyclerView的滑动的第一阶段scroll就完成了；当接收到ACTION_UP事件时，会根据之前的滑动距离与时间计算出一个初速度yvel，这步计算是由VelocityTracker实现的，然后再以此初速度，调用方法fling()，完成RecyclerView滑动的第二阶段fling。\n\n* ListView的滑动\n\n## Android中设计模式的6大原则\n\n![6大原则](http://www.uml.org.cn/sjms/images/2012110233.jpg)\n\n## [WebView的基本使用以及Android和js的交互](https://www.jianshu.com/p/b9164500d3fb)\n\n## [Retrofit+okhttp网络框架介绍](http://blog.csdn.net/zhanggang740/article/details/51569108)\n\n## [Okhttp3结合Retrofit2 实现缓存](https://www.jianshu.com/p/74d2c10c3eba?from=timeline)\n\n## RecyclerView 添加HeaderView和FooterView\n\nSmartHeaderFooterRecyclerview\n\n非常方便的实现Recyclerview添加HeaderView和FooterView， \n* 不需要修改Target Adapter\n* 不会破坏Target adapter中的 position (PS: 不需要 +1 -1)\n* 支持动态添加移除\n* 支持 LinearLayoutManager & GridLayoutManager 两种布局管理器\n\n\n```\nRecyclerView.Adapter targetAdapter = new RecyclerView.Adapter() { ... };\n      GridLayoutManager gridLayoutManager = new GridLayoutManager(this, 3);\n      SmartRecyclerAdapter smartRecyclerAdapter = new SmartRecyclerAdapter(targetAdapter, gridLayoutManager);\n      smartRecyclerAdapter.setFooterView(footerView);\n      smartRecyclerAdapter.setHeaderView(headerView);\n      recyclerView.setAdapter(smartRecyclerAdapter);\n```\n## retrofit 上传文件\n```\n/**\n * 上传信息 */\n@Multipart @POST(\"files/upload/\")\nCall<GMResponse<JSONObject>> uploadFile(\n@Part(\"type\") String type,\n@Part() MultipartBody.Part file);\n```\n\n![upload_img]($res/upload_img.png)\n\n\n\n\n\n## Android面试题\n[Android面试题](http://blog.csdn.net/angel_w/article/details/79103141)",[[1520943852990,["gengmei_pxf@gengmei123.local",[[1,28028,"![uoload_img2]($res/uoload_img2.png)\n\n"]],[28027,28027],[28065,28065]]],[1520952947112,["gengmei_pxf@gengmei123.local",[[1,28069,"\n"]],[28065,28065],[28066,28066]]],[1520952954818,["gengmei_pxf@gengmei123.local",[[1,28066,"## 刷新"]],[28066,28066],[28071,28071]]],[1520952955462,["gengmei_pxf@gengmei123.local",[[1,28075,"\n"]],[28071,28071],[28072,28072]]],[1520952956505,["gengmei_pxf@gengmei123.local",[[1,28072,"PullToRefresh"]],[28072,28072],[28085,28085]]],[1520955056677,["gengmei_pxf@gengmei123.local",[[1,28089,"\n"]],[28086,28086],[28087,28087]]],[1520955067292,["gengmei_pxf@gengmei123.local",[[1,28087,"## 社区卡片化"]],[28087,28087],[28095,28095]]],[1520955067982,["gengmei_pxf@gengmei123.local",[[1,28098,"\n"]],[28095,28095],[28096,28096]]],[1520955092593,["gengmei_pxf@gengmei123.local",[[1,28096,"new CardViewAdapter(getActivity(), beans)"]],[28096,28096],[28137,28137]]],[1520955096027,["gengmei_pxf@gengmei123.local",[[1,28140,"\n"]],[28137,28137],[28138,28138]]],[1520955123518,["gengmei_pxf@gengmei123.local",[[1,28138,"beans extends CardBean"]],[28138,28138],[28160,28160]]],[1520955129607,["gengmei_pxf@gengmei123.local",[[1,28163,"\n"]],[28160,28160],[28161,28161]]],[1520955130445,["gengmei_pxf@gengmei123.local",[[1,28164,"\n"]],[28161,28161],[28162,28162]]],[1520955132766,["gengmei_pxf@gengmei123.local",[[1,28162,"Card"]],[28162,28162],[28166,28166]]],[1520955135021,["gengmei_pxf@gengmei123.local",[[-1,28162,"Card"]],[28166,28166],[28162,28162]]],[1520955135333,["gengmei_pxf@gengmei123.local",[[-1,28164,"\n"]],[28162,28162],[28161,28161]]],[1520955139079,["gengmei_pxf@gengmei123.local",[[1,28161,"CardBean limian"]],[28161,28161],[28176,28176]]],[1520955140437,["gengmei_pxf@gengmei123.local",[[-1,28170,"limian"]],[28176,28176],[28170,28170]]],[1520955153820,["gengmei_pxf@gengmei123.local",[[1,28173,"\n"]],[28170,28170],[28171,28171]]],[1520955156422,["gengmei_pxf@gengmei123.local",[[1,28171,"getCardType"]],[28171,28171],[28182,28182]]],[1520955158643,["gengmei_pxf@gengmei123.local",[[-1,28171,"getCardType"]],[28182,28182],[28171,28171]]],[1520955159764,["gengmei_pxf@gengmei123.local",[[-1,28173,"\n"]],[28171,28171],[28170,28170]]],[1520955162135,["gengmei_pxf@gengmei123.local",[[1,28170,"getCardType，"]],[28170,28170],[28182,28182]]],[1520955169884,["gengmei_pxf@gengmei123.local",[[-1,28181,"，"]],[28182,28182],[28181,28181]]],[1520955170747,["gengmei_pxf@gengmei123.local",[[1,28181,"（）"]],[28181,28181],[28183,28183]]],[1520955171923,["gengmei_pxf@gengmei123.local",[[-1,28181,"（）"]],[28183,28183],[28181,28181]]],[1520955175423,["gengmei_pxf@gengmei123.local",[[1,28181,"(),getUniqueId()"]],[28181,28181],[28197,28197]]],[1520955186731,["gengmei_pxf@gengmei123.local",[[1,28182,"卡片类型"]],[28182,28182],[28186,28186]]],[1520955195060,["gengmei_pxf@gengmei123.local",[[1,28200,"去重id"]],[28200,28200],[28204,28204]]],[1520955199519,["gengmei_pxf@gengmei123.local",[[1,28208,"\n"]],[28205,28205],[28206,28206]]],[1520955215851,["gengmei_pxf@gengmei123.local",[[1,28096,"* "]],[28096,28096],[28098,28098]]],[1520955217963,["gengmei_pxf@gengmei123.local",[[1,28097,"1."]],[28097,28097],[28099,28099]]],[1520955219699,["gengmei_pxf@gengmei123.local",[[1,28097," "]],[28097,28097],[28098,28098]]],[1520955225106,["gengmei_pxf@gengmei123.local",[[1,28143,"* 2."]],[28143,28143],[28147,28147]]],[1520955227535,["gengmei_pxf@gengmei123.local",[[-1,28100," "]],[28101,28101],[28100,28100]]],[1520955231722,["gengmei_pxf@gengmei123.local",[[1,28169,"* 3."]],[28169,28169],[28173,28173]]],[1520955239026,["gengmei_pxf@gengmei123.local",[[1,28218,"* 4..registerCard(Constants.CardViewType.TYPE_DIARY, new DiaryCardProvider(mCurrentTab.tab_name))"]],[28218,28218],[28315,28315]]],[1520955245638,["gengmei_pxf@gengmei123.local",[[1,28318,"\n"]],[28315,28315],[28316,28316]]],[1520955246358,["gengmei_pxf@gengmei123.local",[[1,28319,"\n"]],[28316,28316],[28317,28317]]],[1520955249418,["gengmei_pxf@gengmei123.local",[[1,28317,"* 5."]],[28317,28317],[28321,28321]]],[1520955280963,["gengmei_pxf@gengmei123.local",[[1,28321,"public abstract class CardViewProvider<T, V extends GMRecyclerAdapter.GMRecyclerViewHolder>"]],[28321,28321],[28412,28412]]],[1520955284552,["gengmei_pxf@gengmei123.local",[[1,28415,"\n"]],[28412,28412],[28413,28413]]],[1520955318113,["gengmei_pxf@gengmei123.local",[[1,28413,"```"]],[28413,28413],[28416,28416]]],[1520955318779,["gengmei_pxf@gengmei123.local",[[1,28419,"\n"]],[28416,28416],[28417,28417]]],[1520955318981,["gengmei_pxf@gengmei123.local",[[1,28420,"\n"]],[28417,28417],[28418,28418]]],[1520955319920,["gengmei_pxf@gengmei123.local",[[1,28418,"```"]],[28418,28418],[28421,28421]]],[1520955321570,["gengmei_pxf@gengmei123.local",[[1,28417,"@NonNull public abstract V onCreateViewHolder(\n        @NonNull LayoutInflater inflater, @NonNull ViewGroup parent);   public abstract void onBindViewHolder(@NonNull V holder, @NonNull T t, int position);"]],[28417,28417],[28621,28621]]],[1520955326534,["gengmei_pxf@gengmei123.local",[[1,28533,"\n"]],[28533,28533],[28534,28534]]],[1520955329197,["gengmei_pxf@gengmei123.local",[[-1,28534,"   "]],[28534,28537],[28534,28534]]],[1520955342669,["gengmei_pxf@gengmei123.local",[[1,28426,"\n"]],[28426,28426],[28427,28427]]],[1520955429670,["gengmei_pxf@gengmei123.local",[[1,28625,"* "]],[28625,28625],[28627,28627]]],[1520955432433,["gengmei_pxf@gengmei123.local",[[1,28627,"6.CardViewAdapter"]],[28627,28627],[28644,28644]]],[1520955435017,["gengmei_pxf@gengmei123.local",[[1,28646,"\n"]],[28644,28644],[28645,28645]]],[1520955437411,["gengmei_pxf@gengmei123.local",[[1,28645,"```"]],[28645,28645],[28648,28648]]],[1520955437790,["gengmei_pxf@gengmei123.local",[[1,28650,"\n"]],[28648,28648],[28649,28649]]],[1520955438281,["gengmei_pxf@gengmei123.local",[[1,28651,"\n"]],[28649,28649],[28650,28650]]],[1520955439060,["gengmei_pxf@gengmei123.local",[[1,28650,"```"]],[28650,28650],[28653,28653]]],[1520955489246,["gengmei_pxf@gengmei123.local",[[-1,28645,"```\n\n```"]],[28645,28653],[28645,28645]]],[1520955499155,["gengmei_pxf@gengmei123.local",[[1,28646,"![rcv_card_view_adpater]($res/rcv_card_view_adpater.png)\n\n"]],[28645,28645],[28703,28703]]],[1520955546642,["gengmei_pxf@gengmei123.local",[[-1,28413,"```\n@NonNull \npublic abstract V onCreateViewHolder(\n        @NonNull LayoutInflater inflater, @NonNull ViewGroup parent);\npublic abstract void onBindViewHolder(@NonNull V holder, @NonNull T t, int position);\n```"]],[28413,28624],[28413,28413]]],[1520955555927,["gengmei_pxf@gengmei123.local",[[1,28414,"![rcv_cardview_provider]($res/rcv_cardview_provider.png)\n\n"]],[28413,28413],[28471,28471]]],[1520956367300,["gengmei_pxf@gengmei123.local",[[1,28551,"## zhib"]],[28551,28551],[28558,28558]]],[1520956368436,["gengmei_pxf@gengmei123.local",[[-1,28554,"zhib"]],[28558,28558],[28554,28554]]],[1520956372098,["gengmei_pxf@gengmei123.local",[[1,28554,"直播弹幕"]],[28554,28554],[28558,28558]]],[1520956372460,["gengmei_pxf@gengmei123.local",[[1,28559,"\n"]],[28558,28558],[28559,28559]]],[1520956373748,["gengmei_pxf@gengmei123.local",[[1,28560,"\n"]],[28559,28559],[28560,28560]]],[1520956378222,["gengmei_pxf@gengmei123.local",[[1,28559,"* 1."]],[28559,28559],[28563,28563]]],[1520956421461,["gengmei_pxf@gengmei123.local",[[1,28563,"获取弹幕，保存到list集合中"]],[28563,28563],[28578,28578]]],[1520956422993,["gengmei_pxf@gengmei123.local",[[1,28580,"\n"]],[28578,28578],[28579,28579]]],[1520956425899,["gengmei_pxf@gengmei123.local",[[1,28579,"* 2."]],[28579,28579],[28583,28583]]],[1520956515129,["gengmei_pxf@gengmei123.local",[[1,28583,"根据同步弹幕间隔时间和弹幕延迟加载时间和"]],[28583,28583],[28603,28603]]],[1520956520399,["gengmei_pxf@gengmei123.local",[[1,28603,"某个"]],[28603,28603],[28605,28605]]],[1520956527957,["gengmei_pxf@gengmei123.local",[[-1,28602,"和某个"]],[28605,28605],[28602,28602]]],[1520956558752,["gengmei_pxf@gengmei123.local",[[1,28604,"\n"]],[28602,28602],[28603,28603]]],[1520956562515,["gengmei_pxf@gengmei123.local",[[1,28603,"```"]],[28603,28603],[28606,28606]]],[1520956563046,["gengmei_pxf@gengmei123.local",[[1,28608,"\n"]],[28606,28606],[28607,28607]]],[1520956563439,["gengmei_pxf@gengmei123.local",[[1,28609,"\n"]],[28607,28607],[28608,28608]]],[1520956564175,["gengmei_pxf@gengmei123.local",[[1,28608,"```"]],[28608,28608],[28611,28611]]],[1520956565723,["gengmei_pxf@gengmei123.local",[[1,28607,"// 向上取整 double count = 1000 / GET_DANMU_INTERVAL * Double.valueOf(danMuBean.delay); syncDanMuSize = (int) Math.ceil(((double) mDanmuMessages.size()) / count);"]],[28607,28607],[28765,28765]]],[1520956576246,["gengmei_pxf@gengmei123.local",[[1,28614,"\n"]],[28614,28614],[28615,28615]]],[1520956581238,["gengmei_pxf@gengmei123.local",[[-1,28615," "]],[28616,28616],[28615,28615]]],[1520956592719,["gengmei_pxf@gengmei123.local",[[1,28602,"sua"]],[28602,28602],[28605,28605]]],[1520956593414,["gengmei_pxf@gengmei123.local",[[-1,28602,"sua"]],[28605,28605],[28602,28602]]],[1520956606048,["gengmei_pxf@gengmei123.local",[[1,28602,"算出每次同步弹幕条数"]],[28602,28602],[28612,28612]]],[1520956613749,["gengmei_pxf@gengmei123.local",[[1,28779,"* 3."]],[28779,28779],[28783,28783]]],[1520956616813,["gengmei_pxf@gengmei123.local",[[1,28779,"\n"]],[28779,28779],[28780,28780]]],[1520956661347,["gengmei_pxf@gengmei123.local",[[1,28784,"handler f"]],[28784,28784],[28793,28793]]],[1520956662114,["gengmei_pxf@gengmei123.local",[[-1,28791," f"]],[28793,28793],[28791,28791]]],[1520956663011,["gengmei_pxf@gengmei123.local",[[1,28791,"fa"]],[28791,28791],[28793,28793]]],[1520956663585,["gengmei_pxf@gengmei123.local",[[-1,28791,"fa"]],[28793,28793],[28791,28791]]],[1520956674979,["gengmei_pxf@gengmei123.local",[[1,28791,"发送延迟消息，"]],[28791,28791],[28798,28798]]],[1520956714473,["gengmei_pxf@gengmei123.local",[[1,28784,"循环"]],[28784,28784],[28786,28786]]],[1520956717861,["gengmei_pxf@gengmei123.local",[[-1,28784,"循环"]],[28786,28786],[28784,28784]]],[1520956722441,["gengmei_pxf@gengmei123.local",[[1,28791,"循环"]],[28791,28791],[28793,28793]]],[1520956727320,["gengmei_pxf@gengmei123.local",[[1,28800,"将积压队列中的消息同步到UI队列里"]],[28800,28800],[28817,28817]]],[1520956754140,["gengmei_pxf@gengmei123.local",[[1,28819,"\n"]],[28817,28817],[28818,28818]]],[1520956756470,["gengmei_pxf@gengmei123.local",[[1,28818,"·"]],[28818,28818],[28819,28819]]],[1520956757379,["gengmei_pxf@gengmei123.local",[[-1,28818,"·"]],[28819,28819],[28818,28818]]],[1520956758533,["gengmei_pxf@gengmei123.local",[[1,28818,"```"]],[28818,28818],[28821,28821]]],[1520956759096,["gengmei_pxf@gengmei123.local",[[1,28823,"\n"]],[28821,28821],[28822,28822]]],[1520956759424,["gengmei_pxf@gengmei123.local",[[1,28824,"\n"]],[28822,28822],[28823,28823]]],[1520956760210,["gengmei_pxf@gengmei123.local",[[1,28823,"```"]],[28823,28823],[28826,28826]]],[1520956761814,["gengmei_pxf@gengmei123.local",[[1,28822,"mDanmakuHandler.sendMessageDelayed(mDanmakuHandler.obtainMessage(MSG_WHAT_SYNC), GET_DANMU_INTERVAL);"]],[28822,28822],[28923,28923]]],[1520956765458,["gengmei_pxf@gengmei123.local",[[1,28924,"\n"]],[28923,28923],[28924,28924]]],[1520956767869,["gengmei_pxf@gengmei123.local",[[1,28924,"..."]],[28924,28924],[28927,28927]]],[1520956768481,["gengmei_pxf@gengmei123.local",[[1,28928,"\n"]],[28927,28927],[28928,28928]]],[1520956768889,["gengmei_pxf@gengmei123.local",[[1,28929,"\n"]],[28928,28928],[28929,28929]]],[1520956798116,["gengmei_pxf@gengmei123.local",[[1,28929,"private class DanmakuHandler extends Handler {\n    @Override\n  public void handleMessage(Message msg) {\n        switch (msg.what) {\n            case MSG_WHAT_SYNC:\n                // 将积压队列中的消息同步到UI队列里\n  mDanmakuHandler.sendMessageDelayed(mDanmakuHandler.obtainMessage(MSG_WHAT_SYNC), GET_DANMU_INTERVAL);\n  addMessage();\n break; case MSG_WHAT_GET_DANMU:\n                // 获取弹幕\n  getDanmuMessages();\n break;  }\n    }\n}"]],[28929,28929],[29347,29347]]],[1520956800299,["gengmei_pxf@gengmei123.local",[[-1,28929,"private class DanmakuHandler extends Handler {\n    @Override\n  public void handleMessage(Message msg) {\n        switch (msg.what) {\n            case MSG_WHAT_SYNC:\n                // 将积压队列中的消息同步到UI队列里\n  mDanmakuHandler.sendMessageDelayed(mDanmakuHandler.obtainMessage(MSG_WHAT_SYNC), GET_DANMU_INTERVAL);\n  addMessage();\n break; case MSG_WHAT_GET_DANMU:\n                // 获取弹幕\n  getDanmuMessages();\n break;  }\n    }\n}"]],[29347,29347],[28929,28929]]],[1520956833502,["gengmei_pxf@gengmei123.local",[[-1,28929,"\n"]],[28929,28929],[28928,28928]]],[1520956833801,["gengmei_pxf@gengmei123.local",[[-1,28928,"\n"]],[28928,28928],[28927,28927]]],[1520956835892,["gengmei_pxf@gengmei123.local",[[1,28933,"\n"]],[28931,28931],[28932,28932]]],[1520956852319,["gengmei_pxf@gengmei123.local",[[1,28933,"![danmu_handler]($res/danmu_handler.png)\n\n"]],[28932,28932],[28974,28974]]],[1520956932744,["gengmei_pxf@gengmei123.local",[[1,28976,"\n"]],[28974,28974],[28975,28975]]],[1520956934123,["gengmei_pxf@gengmei123.local",[[1,28975,"```"]],[28975,28975],[28978,28978]]],[1520956934735,["gengmei_pxf@gengmei123.local",[[1,28980,"\n"]],[28978,28978],[28979,28979]]],[1520956934967,["gengmei_pxf@gengmei123.local",[[1,28981,"\n"]],[28979,28979],[28980,28980]]],[1520956935602,["gengmei_pxf@gengmei123.local",[[1,28980,"```"]],[28980,28980],[28983,28983]]],[1520956937715,["gengmei_pxf@gengmei123.local",[[1,28979,"if (addMessage(messages)) {\n    mDanmuMessages.removeAll(messages); }"]],[28979,28979],[29048,29048]]],[1520956941127,["gengmei_pxf@gengmei123.local",[[1,29054,"\n"]],[29052,29052],[29053,29053]]],[1520956986649,["gengmei_pxf@gengmei123.local",[[1,29054,"![danmu_add_msg]($res/danmu_add_msg.png)\n\n"]],[29053,29053],[29095,29095]]],[1520957049769,["gengmei_pxf@gengmei123.local",[[1,29054,"\n"]],[29052,29052],[29053,29053]]],[1520957057431,["gengmei_pxf@gengmei123.local",[[1,29054,"![danmu_add_msgs]($res/danmu_add_msgs.png)\n\n"]],[29053,29053],[29097,29097]]],[1520957060737,["gengmei_pxf@gengmei123.local",[[-1,29098,"\n"]],[29097,29097],[29096,29096]]],[1520957286239,["gengmei_pxf@gengmei123.local",[[1,29141,"\n"]],[29138,29138],[29139,29139]]],[1520957286694,["gengmei_pxf@gengmei123.local",[[1,29142,"\n"]],[29139,29139],[29140,29140]]],[1520957292144,["gengmei_pxf@gengmei123.local",[[1,29140,"## z"]],[29140,29140],[29144,29144]]],[1520957293389,["gengmei_pxf@gengmei123.local",[[-1,29143,"z"]],[29144,29144],[29143,29143]]],[1520957296370,["gengmei_pxf@gengmei123.local",[[1,29143,"直播"]],[29143,29143],[29145,29145]]],[1520957305626,["gengmei_pxf@gengmei123.local",[[1,29145,"点赞动画"]],[29145,29145],[29149,29149]]],[1520957306093,["gengmei_pxf@gengmei123.local",[[1,29152,"\n"]],[29149,29149],[29150,29150]]],[1520957306637,["gengmei_pxf@gengmei123.local",[[1,29153,"\n"]],[29150,29150],[29151,29151]]],[1520957349415,["gengmei_pxf@gengmei123.local",[[1,29150,"handler循环发送延迟消息，随机添加一个ImageView，给其添加一个"]],[29150,29150],[29188,29188]]],[1520957401652,["gengmei_pxf@gengmei123.local",[[1,29188,"Bezier曲线的动画。"]],[29188,29188],[29200,29200]]],[1520957402527,["gengmei_pxf@gengmei123.local",[[1,29204,"\n"]],[29200,29200],[29201,29201]]],[1520957403044,["gengmei_pxf@gengmei123.local",[[1,29201,"//因为不停的add 导致子view数量只增不减,所以在view动画结束后remove掉 removeView((target));"]],[29201,29201],[29267,29267]]],[1520957598921,["gengmei_pxf@gengmei123.local",[[1,29269,"zhib"]],[29269,29269],[29273,29273]]],[1520957599790,["gengmei_pxf@gengmei123.local",[[-1,29269,"zhib"]],[29273,29273],[29269,29269]]],[1520957615706,["gengmei_pxf@gengmei123.local",[[1,29269,"## 直播伸缩动画"]],[29269,29269],[29278,29278]]],[1520957616117,["gengmei_pxf@gengmei123.local",[[1,29280,"\n"]],[29278,29278],[29279,29279]]],[1520957627059,["gengmei_pxf@gengmei123.local",[[1,29280,"![scale_anima]($res/scale_anima.png)\n\n"]],[29279,29279],[29317,29317]]],[1520957628708,["gengmei_pxf@gengmei123.local",[[-1,29318,"\n"]],[29317,29317],[29316,29316]]]]]]}