{"compress":true,"commitItems":[["89d7195d-3764-421f-a308-d0095fc4c0d6",1512042391450,"",[[1512042381933,["gengmei_pxf@gengmei123.local",[[1,0,"#### 电话面试题\n\n1.ArrayList 和 Hashmap 简单说一些,区别,底层的数据结构.\n\n2.Handler 消息机制\n\n3.引起内存泄漏的场景\n\n4.多线程的使用场景?\n\n5.常用的线程池有哪几种?\n\n6.在公司做了什么?团队规模?为什么离职?\n\n#### 面试中实际涉及到的问题\n\n**第一轮**\n\n1.知道哪些单例模式,写一个线程安全的单例,并分析为什么是线程安全的?\n\n2.Java中的集合有哪些?解释一下HashMap?底部的数据结构?散列表冲突的处理方法,散列表是一个什么样的数据结构?HashMap是采用什么方法处理冲突的?\n\n3.解释一下什么是MVP架构,画出图解,一句话解释MVP和MVC的区别?\n\n4.Handle消息机制?在使用Handler的时候要注意哪些东西,是否会引起内存泄漏?画一下Handler机制的图解?\n\n5.是否做过性能优化?已经采取了哪些措施进行优化?\n\n6.引起内存泄漏的原因是什么?以及你是怎么解决的?\n\n这些问题应该都是比较基础的问题,每个开发者都应该是非常熟悉并能详细叙述的.这一轮的面试官问的技术都是平时用到的.\n\n**第二轮**\n\n1.关于并发理解多少?说几个并发的集合?\n\n2.Handler 消息机制图解?\n\n3.在项目中做了哪些东西?\n\n4.画图说明View 事件传递机制?并举一个例子阐述\n\n5.类加载机制,如何换肤,换肤插件中存在的问题?hotfix是否用过,原理是否了解?\n\n6.说说项目中用到了哪些设计模式,说了一下策略模式和观察者模式?\n\n7.会JS么?有Hybid开发经验么?\n\n8.说一下快排的思想?手写代码\n\n9.堆有哪些数据结构?\n\n对于这轮米那是明显感觉到压力,知识的纵向了解也比较深,应该是个leader.\n\n**第三轮**\n\n1.介绍一下在项目中的角色?\n\n2.遇到困难是怎么解决的?\n\n3.如何与人相处,与别人意见相左的时候是怎么解决的,并举生活中的一个例子.\n\n4.有没有压力特别大的时候?\n\n这个应该是项目经理了,问的问题偏向于生活性格方面.\n\n作者：gexinzhao\n链接：http://www.jianshu.com/p/251b1bf72cd8\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[0,0],[969,969]]],[1512042389919,["gengmei_pxf@gengmei123.local",[[-1,1,"###"]],[4,4],[1,1]]],[1512042392766,["gengmei_pxf@gengmei123.local",[[-1,131,"###"]],[134,134],[131,131]]],[1512042399807,["gengmei_pxf@gengmei123.local",[[-1,869,"作者：gexinzhao\n链接：http://www.jianshu.com/p/251b1bf72cd8\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[868,963],[868,868]]],[1512042400047,["gengmei_pxf@gengmei123.local",[[-1,868,"\n"]],[868,868],[867,867]]],[1512042400214,["gengmei_pxf@gengmei123.local",[[-1,866,"."]],[867,867],[866,866]]],[1512042401573,["gengmei_pxf@gengmei123.local",[[1,866,"."]],[866,866],[867,867]]],[1512042410886,["gengmei_pxf@gengmei123.local",[[1,50,"\n"]],[48,48],[49,49]]],[1512042452159,["gengmei_pxf@gengmei123.local",[[1,50,"1、特点：存储对象；长度可变；存储对象的类型可不同；\n\n2、集合框架：\n\n**2****）****Collection**\n\n（1）List：有序的；元素可重复，有索引\n\n（add(index, element)、add(index, Collection)、remove(index)、set(index,element)、get(index)、subList(from, to)、listIterator()）\n\n①ArrayList：底层是数组结构，查询快，增删慢，不同步。\n\n②LinkedList：底层是链表结构，增删快，查询慢，不同步\n\naddFist();addLast() getFirst();getLast() \n\nremoveFirst();removeLast() 获取并删除元素，无元素将抛异常：NoSuchElementException\n\n替代的方法(JDK1.6)：\n\nofferFirst();offerLast();\n\npeekFirst();peekLast();无元素返回null\n\npollFirst();pollLast();删除并返回此元素，无元素返回null\n\n③Vector：底层是数组结构，线程同步，被ArrayList取代了\n\n注：了对于判断是否存在，以及删除等操作，以依赖的方法是元素的hashCode和equals方法\n\nArrayList判断是否存在和删除操作依赖的是equals方法\n\n（2）Set：无序的，无索引，元素不可重复\n\n①HashSet：底层是哈希表，线程不同步，无序、高效\n\n保证元素唯一性：通过元素的hashCode和equals方法。若hashCode值相同，则会判断equals的结果是否为true；hashCode不同，不会调用equals方法\n\nLinkedHashSet：有序，是HashSet的子类\n\n②TreeSet：底层是二叉树，可对元素进行排序，默认是自然顺序\n\n保证唯一性：Comparable接口的compareTo方法的返回值\n\n**===****》****TreeSet****两种排序方式：**两种方式都存在时，以比较器为主\n\n第一种：自然排序（默认排序）：\n\n添加的对象需要实现Comparable接口，覆盖compareTo方法\n\n第二种：比较器\n\n添加的元素自身不具备比较性或不是想要的比较方式。将比较器作为参数传递进去。\n\n定义一个类，实现Comparator接口，覆盖compare方法。当主要条件相同时，比较次要条件。\n\n**3****）****Map****集合：**\n\n（1）HashTable：底层数据结构是哈希表，不可存入null键和null值。同步的\n\nProperties继承自HashTable，可保存在流中或从流中加载，是集合和IO流的结合产物\n\n（2）HashMap：底层数据结构是哈希表；允许使用null键和null值，不同步，效率高\n\nTreeMap：\n\n底层数据结构时二叉树，不同步，可排序\n\n与Set很像，Set底层就是使用了Map集合\n\n方法：\n\nV put(K key, V value) ; void putAll(Map m)\n\nvoid clear(); V remove(Object key)\n\nboolean containsKey(Object key); containsValue(Object key); isEmpty()\n\nV get(Object key); int size(); Collection<V> values()\n\nSet<K> keySet(); Set<Map.Entry<K,V>> entrySet()\n\n2.3、Map集合两种取出方式：\n\n第一种：Set<K> keySet()\n\n取出Map集合中的所有键放于Set集合中，然后再通过键取出对应的值\n\nSet<String> keySet = map.keySet();\n\nIterator<String> it = keySet.iterator();\n\nwhile(it.hasNext()){\n\nString key = it.next();\n\nString value = map.get(key);\n\n//…..\n\n}\n\n第二种：Set<Map.Entry<K,V>> entrySet()\n\n取出Map集合中键值对的映射放于Set集合中，然后通过Map集合中的内部接口，然后通过其中的方法取出\n\nSet<Map.Entry<String,String>> entrySet = map.entrySet();\n\nIterator<Map.Entry<String,String>> it = entrySet.iterator();\n\nWhile(it.hasNext()){\n\nMap.Entry<String,String> entry = it.next();\n\nString key = entry.getKey();\n\nString value = entry.getValue();\n\n//……\n\n}\n\n2.4、Collection和Map的区别：\n\nCollection：单列集合，一次存一个元素\n\nMap：双列集合，一次存一对集合，两个元素（对象）存在着映射关系\n\n2.5、集合工具类：\n\nCollections：操作集合（一般是list集合）的工具类。方法全为静态的\n\nsort(List list);对list集合进行排序; sort(List list, Comparator c) 按指定比较器排序\n\nfill(List list, T obj);将集合元素替换为指定对象；\n\nswap(List list, int I, int j)交换集合指定位置的元素\n\nshuffle(List list); 随机对集合元素排序\n\nreverseOrder() ：返回比较器，强行逆转实现Comparable接口的对象自然顺序\n\nreverseOrder(Comparator c)：返回比较器，强行逆转指定比较器的顺序\n\n2.6、Collection和Collections的区别：\n\nCollections：java.util下的工具类，实现对集合的查找、排序、替换、线程安全化等操作。\n\nCollection：是java.util下的接口，是各种单列集合的父接口，实现此接口的有List和Set集合，存储对象并对其进行操作。\n\n3、Arrays：\n\n用于操作数组对象的工具类，全为静态方法\n\nasList()：将数组转为list集合\n\n好处：可通过list集合的方法操作数组中的元素：\n\nisEmpty()、contains()、indexOf()、set()\n\n弊端：数组长度固定，不可使用集合的增删操作。\n\n如果数组中存储的是基本数据类型，asList会将数组整体作为一个元素存入集合\n\n集合转为数组：Collection.toArray()；\n\n好处：限定了对集合中的元素进行增删操作，只需获取元素"]],[50,50],[2994,2994]]],[1512042469638,["gengmei_pxf@gengmei123.local",[[-1,93,"*"],[-1,365," "],[1,366," "]],[94,94],[93,93]]],[1512042469796,["gengmei_pxf@gengmei123.local",[[-1,92,"*"]],[93,93],[92,92]]],[1512042473348,["gengmei_pxf@gengmei123.local",[[-1,93,"**"]],[95,95],[93,93]]],[1512042490702,["gengmei_pxf@gengmei123.local",[[1,256,"**"]],[256,256],[258,258]]],[1512042492365,["gengmei_pxf@gengmei123.local",[[1,267,"**"]],[267,267],[269,269]]],[1512042494613,["gengmei_pxf@gengmei123.local",[[1,293,"**"]],[293,293],[295,295]]],[1512042496270,["gengmei_pxf@gengmei123.local",[[1,305,"**"]],[305,305],[307,307]]],[1512042503718,["gengmei_pxf@gengmei123.local",[[1,560,"**"]],[560,560],[562,562]]],[1512042504861,["gengmei_pxf@gengmei123.local",[[1,568,"**"]],[568,568],[570,570]]],[1512042509381,["gengmei_pxf@gengmei123.local",[[1,685,"**"]],[685,685],[687,687]]],[1512042510637,["gengmei_pxf@gengmei123.local",[[1,690,"**"]],[690,690],[692,692]]],[1512042517102,["gengmei_pxf@gengmei123.local",[[1,710,"**"]],[710,710],[712,712]]],[1512042518269,["gengmei_pxf@gengmei123.local",[[1,719,"**"]],[719,719],[721,721]]],[1512042522788,["gengmei_pxf@gengmei123.local",[[1,832,"**"]],[832,832],[834,834]]],[1512042523988,["gengmei_pxf@gengmei123.local",[[1,847,"**"]],[847,847],[849,849]]],[1512042525436,["gengmei_pxf@gengmei123.local",[[1,867,"**"]],[867,867],[869,869]]],[1512042526548,["gengmei_pxf@gengmei123.local",[[1,876,"**"]],[876,876],[878,878]]],[1512042533674,["gengmei_pxf@gengmei123.local",[[-1,1149,"**"]],[1151,1151],[1149,1149]]],[1512042536586,["gengmei_pxf@gengmei123.local",[[-1,1152,"**"]],[1150,1152],[1150,1150]]],[1512042541246,["gengmei_pxf@gengmei123.local",[[1,1157," "]],[1157,1157],[1158,1158]]],[1512042547212,["gengmei_pxf@gengmei123.local",[[1,1170,"**"]],[1170,1170],[1172,1172]]],[1512042548379,["gengmei_pxf@gengmei123.local",[[1,1181,"**"]],[1181,1181],[1183,1183]]],[1512042549716,["gengmei_pxf@gengmei123.local",[[1,1269,"**"]],[1269,1269],[1271,1271]]],[1512042551026,["gengmei_pxf@gengmei123.local",[[1,1278,"**"]],[1278,1278],[1280,1280]]],[1512042553626,["gengmei_pxf@gengmei123.local",[[1,1317,"**"]],[1317,1317],[1319,1319]]],[1512042554971,["gengmei_pxf@gengmei123.local",[[1,1326,"**"]],[1326,1326],[1328,1328]]],[1512042561443,["gengmei_pxf@gengmei123.local",[[1,1639,"**"]],[1639,1639],[1641,1641]]],[1512042562745,["gengmei_pxf@gengmei123.local",[[1,1652,"**"]],[1652,1652],[1654,1654]]],[1512042567794,["gengmei_pxf@gengmei123.local",[[1,2230,"**"]],[2230,2230],[2232,2232]]],[1512042568908,["gengmei_pxf@gengmei123.local",[[1,2249,"**"]],[2249,2249],[2251,2251]]],[1512042572576,["gengmei_pxf@gengmei123.local",[[1,2313,"**"]],[2313,2313],[2315,2315]]],[1512042573444,["gengmei_pxf@gengmei123.local",[[-1,2313,"**"]],[2315,2315],[2313,2313]]],[1512042574731,["gengmei_pxf@gengmei123.local",[[1,2317,"**"]],[2317,2317],[2319,2319]]],[1512042575643,["gengmei_pxf@gengmei123.local",[[1,2324,"**"]],[2324,2324],[2326,2326]]],[1512042578314,["gengmei_pxf@gengmei123.local",[[1,2650,"**"]],[2650,2650],[2652,2652]]],[1512042579492,["gengmei_pxf@gengmei123.local",[[1,2677,"**"]],[2677,2677],[2679,2679]]],[1512042581891,["gengmei_pxf@gengmei123.local",[[1,2807,"**"]],[2807,2807],[2809,2809]]],[1512042583483,["gengmei_pxf@gengmei123.local",[[1,2815,"**"]],[2815,2815],[2817,2817]]],[1512042589592,["gengmei_pxf@gengmei123.local",[[1,3048,"\n"]],[3047,3047],[3048,3048]]],[1512042599745,["gengmei_pxf@gengmei123.local",[[1,9,"## "]],[9,9],[12,12]]],[1512042604946,["gengmei_pxf@gengmei123.local",[[1,11,"#"]],[11,11],[12,12]]],[1512042606927,["gengmei_pxf@gengmei123.local",[[-1,11,"#"]],[12,12],[11,11]]],[1512042867549,["gengmei_pxf@gengmei123.local",[[1,3068,"\n"]],[3066,3066],[3067,3067]]]]],["0e859817-7e19-41bd-8c82-f50294ad0edd",1512096206882,"# 电话面试题\n\n## 1.ArrayList 和 Hashmap 简单说一些,区别,底层的数据结构.\n\n1、特点：存储对象；长度可变；存储对象的类型可不同；\n\n2、集合框架：\n\n**2**）**Collection**\n\n（1）List：有序的；元素可重复，有索引\n\n（add(index, element)、add(index, Collection)、remove(index)、set(index,element)、get(index)、subList(from, to)、listIterator()）\n\n①**ArrayList**：底层是数组结构，查询快，增删慢，不同步。\n\n②**LinkedList**：底层是链表结构，增删快，查询慢，不同步\n\naddFist();addLast() getFirst();getLast() \n\nremoveFirst();removeLast() 获取并删除元素，无元素将抛异常：NoSuchElementException\n\n替代的方法(JDK1.6)：\n\nofferFirst();offerLast();\n\npeekFirst();peekLast();无元素返回null\n\npollFirst();pollLast();删除并返回此元素，无元素返回null\n\n③**Vector**：底层是数组结构，线程同步，被ArrayList取代了\n\n注：了对于判断是否存在，以及删除等操作，以依赖的方法是元素的hashCode和equals方法\n\nArrayList判断是否存在和删除操作依赖的是equals方法\n\n（2）**Set**：无序的，无索引，元素不可重复\n\n①**HashSet**：底层是哈希表，线程不同步，无序、高效\n\n保证元素唯一性：通过元素的hashCode和equals方法。若hashCode值相同，则会判断equals的结果是否为true；hashCode不同，不会调用equals方法\n\n**LinkedHashSet**：有序，是HashSet的子类\n\n②**TreeSet**：底层是二叉树，可对元素进行排序，默认是自然顺序\n\n保证唯一性：Comparable接口的compareTo方法的返回值\n\n**===****》****TreeSet****两种排序方式：**两种方式都存在时，以比较器为主\n\n第一种：自然排序（默认排序）：\n\n添加的对象需要实现Comparable接口，覆盖compareTo方法\n\n第二种：比较器\n\n添加的元素自身不具备比较性或不是想要的比较方式。将比较器作为参数传递进去。\n\n定义一个类，实现Comparator接口，覆盖compare方法。当主要条件相同时，比较次要条件。\n\n**3**）**Map** **集合：**\n\n（1）**HashTable**：底层数据结构是哈希表，不可存入null键和null值。同步的\n\nProperties继承自HashTable，可保存在流中或从流中加载，是集合和IO流的结合产物\n\n（2）**HashMap**：底层数据结构是哈希表；允许使用null键和null值，不同步，效率高\n\n**TreeMap**：\n\n底层数据结构时二叉树，不同步，可排序\n\n与Set很像，Set底层就是使用了Map集合\n\n方法：\n\nV put(K key, V value) ; void putAll(Map m)\n\nvoid clear(); V remove(Object key)\n\nboolean containsKey(Object key); containsValue(Object key); isEmpty()\n\nV get(Object key); int size(); Collection<V> values()\n\nSet<K> keySet(); Set<Map.Entry<K,V>> entrySet()\n\n2.3、**Map集合两种取出方式**：\n\n第一种：Set<K> keySet()\n\n取出Map集合中的所有键放于Set集合中，然后再通过键取出对应的值\n\nSet<String> keySet = map.keySet();\n\nIterator<String> it = keySet.iterator();\n\nwhile(it.hasNext()){\n\nString key = it.next();\n\nString value = map.get(key);\n\n//…..\n\n}\n\n第二种：Set<Map.Entry<K,V>> entrySet()\n\n取出Map集合中键值对的映射放于Set集合中，然后通过Map集合中的内部接口，然后通过其中的方法取出\n\nSet<Map.Entry<String,String>> entrySet = map.entrySet();\n\nIterator<Map.Entry<String,String>> it = entrySet.iterator();\n\nWhile(it.hasNext()){\n\nMap.Entry<String,String> entry = it.next();\n\nString key = entry.getKey();\n\nString value = entry.getValue();\n\n//……\n\n}\n\n2.4、**Collection和Map的区别**：\n\nCollection：单列集合，一次存一个元素\n\nMap：双列集合，一次存一对集合，两个元素（对象）存在着映射关系\n\n2.5、**集合工具类**：\n\nCollections：操作集合（一般是list集合）的工具类。方法全为静态的\n\nsort(List list);对list集合进行排序; sort(List list, Comparator c) 按指定比较器排序\n\nfill(List list, T obj);将集合元素替换为指定对象；\n\nswap(List list, int I, int j)交换集合指定位置的元素\n\nshuffle(List list); 随机对集合元素排序\n\nreverseOrder() ：返回比较器，强行逆转实现Comparable接口的对象自然顺序\n\nreverseOrder(Comparator c)：返回比较器，强行逆转指定比较器的顺序\n\n2.6、**Collection和Collections的区别**：\n\nCollections：java.util下的工具类，实现对集合的查找、排序、替换、线程安全化等操作。\n\nCollection：是java.util下的接口，是各种单列集合的父接口，实现此接口的有List和Set集合，存储对象并对其进行操作。\n\n3、**Arrays**：\n\n用于操作数组对象的工具类，全为静态方法\n\nasList()：将数组转为list集合\n\n好处：可通过list集合的方法操作数组中的元素：\n\nisEmpty()、contains()、indexOf()、set()\n\n弊端：数组长度固定，不可使用集合的增删操作。\n\n如果数组中存储的是基本数据类型，asList会将数组整体作为一个元素存入集合\n\n集合转为数组：Collection.toArray()；\n\n好处：限定了对集合中的元素进行增删操作，只需获取元素\n\n2.Handler 消息机制\n\n\n3.引起内存泄漏的场景\n\n4.多线程的使用场景?\n\n5.常用的线程池有哪几种?\n\n6.在公司做了什么?团队规模?为什么离职?\n\n# 面试中实际涉及到的问题\n\n**第一轮**\n\n1.知道哪些单例模式,写一个线程安全的单例,并分析为什么是线程安全的?\n\n2.Java中的集合有哪些?解释一下HashMap?底部的数据结构?散列表冲突的处理方法,散列表是一个什么样的数据结构?HashMap是采用什么方法处理冲突的?\n\n3.解释一下什么是MVP架构,画出图解,一句话解释MVP和MVC的区别?\n\n4.Handle消息机制?在使用Handler的时候要注意哪些东西,是否会引起内存泄漏?画一下Handler机制的图解?\n\n5.是否做过性能优化?已经采取了哪些措施进行优化?\n\n6.引起内存泄漏的原因是什么?以及你是怎么解决的?\n\n这些问题应该都是比较基础的问题,每个开发者都应该是非常熟悉并能详细叙述的.这一轮的面试官问的技术都是平时用到的.\n\n**第二轮**\n\n1.关于并发理解多少?说几个并发的集合?\n\n2.Handler 消息机制图解?\n\n3.在项目中做了哪些东西?\n\n4.画图说明View 事件传递机制?并举一个例子阐述\n\n5.类加载机制,如何换肤,换肤插件中存在的问题?hotfix是否用过,原理是否了解?\n\n6.说说项目中用到了哪些设计模式,说了一下策略模式和观察者模式?\n\n7.会JS么?有Hybid开发经验么?\n\n8.说一下快排的思想?手写代码\n\n9.堆有哪些数据结构?\n\n对于这轮米那是明显感觉到压力,知识的纵向了解也比较深,应该是个leader.\n\n**第三轮**\n\n1.介绍一下在项目中的角色?\n\n2.遇到困难是怎么解决的?\n\n3.如何与人相处,与别人意见相左的时候是怎么解决的,并举生活中的一个例子.\n\n4.有没有压力特别大的时候?\n\n这个应该是项目经理了,问的问题偏向于生活性格方面.\n",[[1512096192875,["gengmei_pxf@gengmei123.local",[[1,53,"\n"]],[52,52],[53,53]]],[1512096193243,["gengmei_pxf@gengmei123.local",[[1,54,"\n"]],[53,53],[54,54]]],[1512096444468,["gengmei_pxf@gengmei123.local",[[1,53,"！"]],[53,53],[54,54]]],[1512096445169,["gengmei_pxf@gengmei123.local",[[-1,53,"！"]],[54,54],[53,53]]],[1512096445995,["gengmei_pxf@gengmei123.local",[[1,53,"!"]],[53,53],[54,54]]],[1512096447809,["gengmei_pxf@gengmei123.local",[[1,54,"[]()"]],[54,54],[58,58]]],[1512096448858,["gengmei_pxf@gengmei123.local",[[1,57,"http://ou21vt4uz.bkt.clouddn.com/Collection.png"]],[57,57],[104,104]]]]],["2dd4f4ce-5b5a-4513-ba30-a1fbe6701ac6",1512456121217,"# 电话面试题\n\n## 1.ArrayList 和 Hashmap 简单说一些,区别,底层的数据结构.\n\n![](http://ou21vt4uz.bkt.clouddn.com/Collection.png)\n\n1、特点：存储对象；长度可变；存储对象的类型可不同；\n\n2、集合框架：\n\n**2**）**Collection**\n\n（1）List：有序的；元素可重复，有索引\n\n（add(index, element)、add(index, Collection)、remove(index)、set(index,element)、get(index)、subList(from, to)、listIterator()）\n\n①**ArrayList**：底层是数组结构，查询快，增删慢，不同步。\n\n②**LinkedList**：底层是链表结构，增删快，查询慢，不同步\n\naddFist();addLast() getFirst();getLast() \n\nremoveFirst();removeLast() 获取并删除元素，无元素将抛异常：NoSuchElementException\n\n替代的方法(JDK1.6)：\n\nofferFirst();offerLast();\n\npeekFirst();peekLast();无元素返回null\n\npollFirst();pollLast();删除并返回此元素，无元素返回null\n\n③**Vector**：底层是数组结构，线程同步，被ArrayList取代了\n\n注：了对于判断是否存在，以及删除等操作，以依赖的方法是元素的hashCode和equals方法\n\nArrayList判断是否存在和删除操作依赖的是equals方法\n\n（2）**Set**：无序的，无索引，元素不可重复\n\n①**HashSet**：底层是哈希表，线程不同步，无序、高效\n\n保证元素唯一性：通过元素的hashCode和equals方法。若hashCode值相同，则会判断equals的结果是否为true；hashCode不同，不会调用equals方法\n\n**LinkedHashSet**：有序，是HashSet的子类\n\n②**TreeSet**：底层是二叉树，可对元素进行排序，默认是自然顺序\n\n保证唯一性：Comparable接口的compareTo方法的返回值\n\n**===****》****TreeSet****两种排序方式：**两种方式都存在时，以比较器为主\n\n第一种：自然排序（默认排序）：\n\n添加的对象需要实现Comparable接口，覆盖compareTo方法\n\n第二种：比较器\n\n添加的元素自身不具备比较性或不是想要的比较方式。将比较器作为参数传递进去。\n\n定义一个类，实现Comparator接口，覆盖compare方法。当主要条件相同时，比较次要条件。\n\n**3**）**Map** **集合：**\n\n（1）**HashTable**：底层数据结构是哈希表，不可存入null键和null值。同步的\n\nProperties继承自HashTable，可保存在流中或从流中加载，是集合和IO流的结合产物\n\n（2）**HashMap**：底层数据结构是哈希表；允许使用null键和null值，不同步，效率高\n\n**TreeMap**：\n\n底层数据结构时二叉树，不同步，可排序\n\n与Set很像，Set底层就是使用了Map集合\n\n方法：\n\nV put(K key, V value) ; void putAll(Map m)\n\nvoid clear(); V remove(Object key)\n\nboolean containsKey(Object key); containsValue(Object key); isEmpty()\n\nV get(Object key); int size(); Collection<V> values()\n\nSet<K> keySet(); Set<Map.Entry<K,V>> entrySet()\n\n2.3、**Map集合两种取出方式**：\n\n第一种：Set<K> keySet()\n\n取出Map集合中的所有键放于Set集合中，然后再通过键取出对应的值\n\nSet<String> keySet = map.keySet();\n\nIterator<String> it = keySet.iterator();\n\nwhile(it.hasNext()){\n\nString key = it.next();\n\nString value = map.get(key);\n\n//…..\n\n}\n\n第二种：Set<Map.Entry<K,V>> entrySet()\n\n取出Map集合中键值对的映射放于Set集合中，然后通过Map集合中的内部接口，然后通过其中的方法取出\n\nSet<Map.Entry<String,String>> entrySet = map.entrySet();\n\nIterator<Map.Entry<String,String>> it = entrySet.iterator();\n\nWhile(it.hasNext()){\n\nMap.Entry<String,String> entry = it.next();\n\nString key = entry.getKey();\n\nString value = entry.getValue();\n\n//……\n\n}\n\n2.4、**Collection和Map的区别**：\n\nCollection：单列集合，一次存一个元素\n\nMap：双列集合，一次存一对集合，两个元素（对象）存在着映射关系\n\n2.5、**集合工具类**：\n\nCollections：操作集合（一般是list集合）的工具类。方法全为静态的\n\nsort(List list);对list集合进行排序; sort(List list, Comparator c) 按指定比较器排序\n\nfill(List list, T obj);将集合元素替换为指定对象；\n\nswap(List list, int I, int j)交换集合指定位置的元素\n\nshuffle(List list); 随机对集合元素排序\n\nreverseOrder() ：返回比较器，强行逆转实现Comparable接口的对象自然顺序\n\nreverseOrder(Comparator c)：返回比较器，强行逆转指定比较器的顺序\n\n2.6、**Collection和Collections的区别**：\n\nCollections：java.util下的工具类，实现对集合的查找、排序、替换、线程安全化等操作。\n\nCollection：是java.util下的接口，是各种单列集合的父接口，实现此接口的有List和Set集合，存储对象并对其进行操作。\n\n3、**Arrays**：\n\n用于操作数组对象的工具类，全为静态方法\n\nasList()：将数组转为list集合\n\n好处：可通过list集合的方法操作数组中的元素：\n\nisEmpty()、contains()、indexOf()、set()\n\n弊端：数组长度固定，不可使用集合的增删操作。\n\n如果数组中存储的是基本数据类型，asList会将数组整体作为一个元素存入集合\n\n集合转为数组：Collection.toArray()；\n\n好处：限定了对集合中的元素进行增删操作，只需获取元素\n\n2.Handler 消息机制\n\n\n3.引起内存泄漏的场景\n\n4.多线程的使用场景?\n\n5.常用的线程池有哪几种?\n\n6.在公司做了什么?团队规模?为什么离职?\n\n# 面试中实际涉及到的问题\n\n**第一轮**\n\n1.知道哪些单例模式,写一个线程安全的单例,并分析为什么是线程安全的?\n\n2.Java中的集合有哪些?解释一下HashMap?底部的数据结构?散列表冲突的处理方法,散列表是一个什么样的数据结构?HashMap是采用什么方法处理冲突的?\n\n3.解释一下什么是MVP架构,画出图解,一句话解释MVP和MVC的区别?\n\n4.Handle消息机制?在使用Handler的时候要注意哪些东西,是否会引起内存泄漏?画一下Handler机制的图解?\n\n5.是否做过性能优化?已经采取了哪些措施进行优化?\n\n6.引起内存泄漏的原因是什么?以及你是怎么解决的?\n\n这些问题应该都是比较基础的问题,每个开发者都应该是非常熟悉并能详细叙述的.这一轮的面试官问的技术都是平时用到的.\n\n**第二轮**\n\n1.关于并发理解多少?说几个并发的集合?\n\n2.Handler 消息机制图解?\n\n3.在项目中做了哪些东西?\n\n4.画图说明View 事件传递机制?并举一个例子阐述\n\n5.类加载机制,如何换肤,换肤插件中存在的问题?hotfix是否用过,原理是否了解?\n\n6.说说项目中用到了哪些设计模式,说了一下策略模式和观察者模式?\n\n7.会JS么?有Hybid开发经验么?\n\n8.说一下快排的思想?手写代码\n\n9.堆有哪些数据结构?\n\n对于这轮米那是明显感觉到压力,知识的纵向了解也比较深,应该是个leader.\n\n**第三轮**\n\n1.介绍一下在项目中的角色?\n\n2.遇到困难是怎么解决的?\n\n3.如何与人相处,与别人意见相左的时候是怎么解决的,并举生活中的一个例子.\n\n4.有没有压力特别大的时候?\n\n这个应该是项目经理了,问的问题偏向于生活性格方面.\n",[[1512456107318,["gengmei_pxf@gengmei123.local",[[-1,53,"![](http://ou21vt4uz.bkt.clouddn.com/Collection.png)\n\n1、特点：存储对象；长度可变；存储对象的类型可不同；\n\n2、集合框架：\n\n**2**）**Collection**\n\n（1）List：有序的；元素可重复，有索引\n\n（add(index, element)、add(index, Collection)、remove(index)、set(index,element)、get(index)、subList(from, to)、listIterator()）\n\n①**ArrayList**：底层是数组结构，查询快，增删慢，不同步。\n\n②**LinkedList**：底层是链表结构，增删快，查询慢，不同步\n\naddFist();addLast() getFirst();getLast() \n\nremoveFirst();removeLast() 获取并删除元素，无元素将抛异常：NoSuchElementException\n\n替代的方法(JDK1.6)：\n\nofferFirst();offerLast();\n\npeekFirst();peekLast();无元素返回null\n\npollFirst();pollLast();删除并返回此元素，无元素返回null\n\n③**Vector**：底层是数组结构，线程同步，被ArrayList取代了\n\n注：了对于判断是否存在，以及删除等操作，以依赖的方法是元素的hashCode和equals方法\n\nArrayList判断是否存在和删除操作依赖的是equals方法\n\n（2）**Set**：无序的，无索引，元素不可重复\n\n①**HashSet**：底层是哈希表，线程不同步，无序、高效\n\n保证元素唯一性：通过元素的hashCode和equals方法。若hashCode值相同，则会判断equals的结果是否为true；hashCode不同，不会调用equals方法\n\n**LinkedHashSet**：有序，是HashSet的子类\n\n②**TreeSet**：底层是二叉树，可对元素进行排序，默认是自然顺序\n\n保证唯一性：Comparable接口的compareTo方法的返回值\n\n**===****》****TreeSet****两种排序方式：**两种方式都存在时，以比较器为主\n\n第一种：自然排序（默认排序）：\n\n添加的对象需要实现Comparable接口，覆盖compareTo方法\n\n第二种：比较器\n\n添加的元素自身不具备比较性或不是想要的比较方式。将比较器作为参数传递进去。\n\n定义一个类，实现Comparator接口，覆盖compare方法。当主要条件相同时，比较次要条件。\n\n**3**）**Map** **集合：**\n\n（1）**HashTable**：底层数据结构是哈希表，不可存入null键和null值。同步的\n\nProperties继承自HashTable，可保存在流中或从流中加载，是集合和IO流的结合产物\n\n（2）**HashMap**：底层数据结构是哈希表；允许使用null键和null值，不同步，效率高\n\n**TreeMap**：\n\n底层数据结构时二叉树，不同步，可排序\n\n与Set很像，Set底层就是使用了Map集合\n\n方法：\n\nV put(K key, V value) ; void putAll(Map m)\n\nvoid clear(); V remove(Object key)\n\nboolean containsKey(Object key); containsValue(Object key); isEmpty()\n\nV get(Object key); int size(); Collection<V> values()\n\nSet<K> keySet(); Set<Map.Entry<K,V>> entrySet()\n\n2.3、**Map集合两种取出方式**：\n\n第一种：Set<K> keySet()\n\n取出Map集合中的所有键放于Set集合中，然后再通过键取出对应的值\n\nSet<String> keySet = map.keySet();\n\nIterator<String> it = keySet.iterator();\n\nwhile(it.hasNext()){\n\nString key = it.next();\n\nString value = map.get(key);\n\n//…..\n\n}\n\n第二种：Set<Map.Entry<K,V>> entrySet()\n\n取出Map集合中键值对的映射放于Set集合中，然后通过Map集合中的内部接口，然后通过其中的方法取出\n\nSet<Map.Entry<String,String>> entrySet = map.entrySet();\n\nIterator<Map.Entry<String,String>> it = entrySet.iterator();\n\nWhile(it.hasNext()){\n\nMap.Entry<String,String> entry = it.next();\n\nString key = entry.getKey();\n\nString value = entry.getValue();\n\n//……\n\n}\n\n2.4、**Collection和Map的区别**：\n\nCollection：单列集合，一次存一个元素\n\nMap：双列集合，一次存一对集合，两个元素（对象）存在着映射关系\n\n2.5、**集合工具类**：\n\nCollections：操作集合（一般是list集合）的工具类。方法全为静态的\n\nsort(List list);对list集合进行排序; sort(List list, Comparator c) 按指定比较器排序\n\nfill(List list, T obj);将集合元素替换为指定对象；\n\nswap(List list, int I, int j)交换集合指定位置的元素\n\nshuffle(List list); 随机对集合元素排序\n\nreverseOrder() ：返回比较器，强行逆转实现Comparable接口的对象自然顺序\n\nreverseOrder(Comparator c)：返回比较器，强行逆转指定比较器的顺序\n\n2.6、**Collection和Collections的区别**：\n\nCollections：java.util下的工具类，实现对集合的查找、排序、替换、线程安全化等操作。\n\nCollection：是java.util下的接口，是各种单列集合的父接口，实现此接口的有List和Set集合，存储对象并对其进行操作。\n\n3、**Arrays**：\n\n用于操作数组对象的工具类，全为静态方法\n\nasList()：将数组转为list集合\n\n好处：可通过list集合的方法操作数组中的元素：\n\nisEmpty()、contains()、indexOf()、set()\n\n弊端：数组长度固定，不可使用集合的增删操作。\n\n如果数组中存储的是基本数据类型，asList会将数组整体作为一个元素存入集合\n\n集合转为数组：Collection.toArray()；\n\n好处：限定了对集合中的元素进行增删操作，只需获取元素\n"]],[53,3105],[53,53]]],[1512456108252,["gengmei_pxf@gengmei123.local",[[-1,53,"\n"]],[53,53],[52,52]]],[1512456112943,["gengmei_pxf@gengmei123.local",[[-1,9,"##"]],[11,11],[9,9]]],[1512456118895,["gengmei_pxf@gengmei123.local",[[-1,67,"\n"]],[67,67],[66,66]]],[1512456203885,["gengmei_pxf@gengmei123.local",[[1,869,"\n"]],[868,868],[869,869]]],[1512456205853,["gengmei_pxf@gengmei123.local",[[-1,869,"\n"]],[869,869],[868,868]]],[1512456213412,["gengmei_pxf@gengmei123.local",[[1,869,"\n"]],[868,868],[869,869]]],[1512456213532,["gengmei_pxf@gengmei123.local",[[1,870,"\n"]],[869,869],[870,870]]],[1512456216298,["gengmei_pxf@gengmei123.local",[[1,870,"**必问点**：Handler，多线程，http 与 https 的区别，事件分发与冲突，内存优化，内存泄漏等。\n\n**选问点**：设计模式，Fragment 与 Activity之间的通信，自定义 View，组件化架构等。\n\n几乎不怎么问的：MVP，屏幕适配，动画等。\n\n以后的一些面试方向：网络原理（五层模型的实现等），热更新，增量更新，JNI NDK（硬件公司重点之重点），跨进程通信（浅：广播，AIDL 。深：Binder 原理），framework 等。\n\n大公司一般不会问你很花哨的东西，原理，基础理论居多。小公司会问一些稍微应用层多一些的东西，例如 recyclerview 或者是瀑布流什么的。但是作为开发者来说，不断的学习，重复，记在脑子里比什么都重要。"]],[870,870],[1206,1206]]],[1512456232747,["gengmei_pxf@gengmei123.local",[[1,146,"## "]],[146,146],[149,149]]],[1512456236735,["gengmei_pxf@gengmei123.local",[[1,489,"## "]],[489,489],[492,492]]],[1512456240437,["gengmei_pxf@gengmei123.local",[[1,754,"## "]],[754,754],[757,757]]],[1512456256459,["gengmei_pxf@gengmei123.local",[[1,879,"\n"]],[878,878],[879,879]]],[1512456268319,["gengmei_pxf@gengmei123.local",[[1,879,"## 其他技术问题总结"]],[879,879],[890,890]]],[1512456270875,["gengmei_pxf@gengmei123.local",[[1,891,"\n"]],[890,890],[891,891]]],[1512456280190,["gengmei_pxf@gengmei123.local",[[1,882,"**"]],[882,882],[884,884]]],[1512456281630,["gengmei_pxf@gengmei123.local",[[1,892,"**"]],[892,892],[894,894]]],[1512456296373,["gengmei_pxf@gengmei123.local",[[1,2,"**"]],[2,2],[4,4]]],[1512456297821,["gengmei_pxf@gengmei123.local",[[1,9,"**"]],[9,9],[11,11]]],[1512456299277,["gengmei_pxf@gengmei123.local",[[1,137,"**"]],[137,137],[139,139]]],[1512456300381,["gengmei_pxf@gengmei123.local",[[1,150,"**"]],[150,150],[152,152]]],[1512459032024,["gengmei_pxf@gengmei123.local",[[1,1241,"\n"]],[1240,1240],[1241,1241]]],[1512459032344,["gengmei_pxf@gengmei123.local",[[1,1242,"\n"]],[1241,1241],[1242,1242]]],[1512459033345,["gengmei_pxf@gengmei123.local",[[1,1242,"找工作的过程就是解决一个相对复杂问题的过程。可以按照以下四部进行准备：\n\n1.  定义问题\n\n2.  划分问题\n\n3.  逐个突破\n\n4.  系统化\n\n接下来一步步的看一下具体细节。\n\n##### 1\\. 定义问题\n\n首先，定义一下我们解决的是什么问题。在这里，因为我们是Android方向，所以可以简单定义为：“我们要找到一个Android方向的工作（或相关的工作），工作要尽量好”。\n\n> 这个定义很模糊，什么是尽量的好呢？有的人看中薪资，有的人看中五险一金，各种福利等等。在这里，我们不考虑个人主观因素占比较大的问题。我们只考虑更加可控的东西。就是通过个人努力可以获得效果的问题。\n\n我们再思考一下“找到一个Android方向的工作”起决定性的因素是哪一个呢？\n\n答案是面试。当然一个人过去做过的项目，拿过的奖也至关重要。但是到了这个马上就要面试的时间节点，过去的已经过去，无法改变，能控制的只有现在。没有项目无关紧要，关键的是现在如何准备面试。\n\n目标：我要通过面试，拿到offer（或者我要通过多家公司面试，拿到多家公司的offer，选择最合心意的公司去工作）。当然，这句话表达的太宽泛，并没有什么指导意义。定义问题很重要，而更重要的是如何划分问题，这一步才是具有指导意义，能够落到实践中去的内容。\n\n##### 2\\. 划分问题\n\nAndroid面试需要准备内容的大致划分：（括号内为重要程度，最多5颗星）\n\n*   Android相关知识、Java相关知识、设计模式（5）\n\n*   算法、数据结构（5）\n\n*   如何写简历、如何面试（4）\n\n*   项目、比赛获奖（4）\n\n*   操作系统、网络、数据库（3）\n\n###### 细分\n\n以下细分内容，网络等计算机基础方面还不是很全面，持续更新中。\n\n我会逐步更新各个知识点相关博客或资源，如果需要，建议关注。\n\n###### Android\n\n*   Context的理解\n\n*   [Activity生命周期、启动模式、IntentFilter匹配规则](http://www.jianshu.com/p/3b675e85f78a)\n\n*   IPC：Serialzable、Parcelable、Binder、Socket\n\n*   View事件体系\n\n*   View绘制流程\n\n*   RemoteViews（不重要）\n\n*   Drawable（不重要）\n\n*   动画、绘图\n\n*   window、wm、wms\n\n*   四大组件启动、工作流程（Activity至少看一下，AMS）\n\n*   消息机制：looper、handler、MQ\n\n*   线程、线程池、多线程\n\n*   bitmap加载、缓存：LRUCache、DiskLruCache、LinkHashMap\n\n*   CrashHandler（一般）\n\n*   multidex（一般）\n\n*   Fragment、Service、SQLite、Webview\n\n*   [Android内存泄漏场景及解决方法](http://www.jianshu.com/p/f35ca324c285)\n\n*   ANR的原因、解决方法\n\n*   开源库（一般要求看过源码，知道原理）：Retrofit、RxAndroid、EventBus、Picasso（优点）、OKhttp3\n\n*   持续集成Jenkins（不重要）\n\n*   单元测试、测试用例（一般）\n\n*   插件化：Atlas、OSGI（一般）\n\n###### Java\n\n*   Java基础：比如接口和抽象类的区别等\n\n*   Java内存管理：工作内存和主内存等\n\n*   垃圾回收：回收算法、如何判断对象可以回收、新生代老年代等\n\n*   并发\n\n    锁：sychronized、lock（CAS）；volatile；并发集合：CopyOnWriteArrayList、ConcurrentHashMap、RemoteCallbackList（Android的IPC用到）、LinkedHashMap；\n\n*   集合\n\n    Map、Set、List\n\n    Queue、Stack\n\n    HashMap、HashTable、ConcurrentHashMap：实现原理，区别等\n\n    LinkedHashMap\n\n###### 设计模式（六大原则：SOLID + 迪米特）\n\n*   单例模式：获取各种service\n\n*   工厂方法：activity、service（onStart）\n\n*   责任链：Android事件分发\n\n*   builder：dialog、Picasso\n\n*   观察者：listview更新、EventBus\n\n*   适配器：listview adapter\n\n###### 算法、数据结构\n\n排序\n\n*   冒泡排序\n\n*   选择排序\n\n*   归并\n\n*   堆排序\n\n*   插入排序\n\n*   快速排序\n\n*   希尔排序\n\n*   桶排序\n\n*   基数排序\n\n字符匹配：KMP算法\n\n二分查找\n\n二叉树遍历、翻转、重构；二叉查找树\n\n红黑树\n\nAVL树、哈夫曼树、B树（一般）\n\n###### 网络\n\n[已整理博客，点击查看网络相关问题及其解答](http://www.jianshu.com/p/97f77927db0f)\n\n基本是围绕OSI七层模型展开，首先是各层的功能、每层有哪些协议。\n\n深入主要考察应用层和传输层：\n\n应用层：\n\n*   HTTP报文格式、头部有哪些字段\n\n*   HTTP状态码\n\n*   HTTP和HTTPS的区别\n\n*   HTTPS中SSL/TLS加密的握手过程\n\n*   HTTP一次连接的具体过程\n\n*   GET、POST的区别\n\n*   DNS解析过程\n\n*   Cookie、Session原理\n\n传输层：\n\n*   TCP/IP四层模型（和OSI的层次对应关系）\n\n*   TCP三次握手、四次握手的过程，状态变化和原因\n\n*   TCP、UDP区别\n\n*   TCP拥控、流控原理\n\n*   Socket原理\n\n###### 操作系统、数据库\n\n线程状态及其切换\n\n线程、进程区别\n\n（数据库重要程度相对低一些，正在整理中，后续会更新）\n\n###### 简历、面试、项目\n\n篇幅较大，会有另外博客进行探讨，敬请关注\n\n##### 3\\. 逐个突破\n\n可以自己去网上找一些博客、书籍，进行各个知识点的突破，要有耐心，找到一个心仪的工作非一日之功。\n\n一方面，我会陆续更新一些专业知识和面试相关的博客。\n\n另一方面，把我自己的一些资源分享给大家。\n\n*   博客\n\n    GitYuan（gityuan.com）、罗升阳（CSDN）、邓凡平（CSDN）、任玉刚（CSDN）\n\n*   书籍\n\n    Android 4高级编程、Android开发艺术探索、Android源码设计模式、Android 50 hacks、Android应用性能优化最佳实践、Efficient Java、深入Java虚拟机、Java并发编程、Think in Java\n\n*   刷题\n\n    牛客网、LeetCode\n\n##### 4\\. 系统化\n\n系统化其实就是当你把一整个相关的知识都看过看懂之后，进行总结和建立各模块之间关系的过程。\n\n每个人大脑“操作系统”是由概念和概念之间的联系的过程。系统化一方面可以加深知识的记忆，另一方面提供了另一个角度去理解这些概念，加大了概念的深入程度。\n\n建议多做记录、总结，多在各模块、各学科之间建立联系，抽取统一适用的知识和智慧。\n\n作者：QinGeneral\n链接：http://www.jianshu.com/p/5c92689c9be2\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[1242,1242],[4531,4531]]],[1512459043218,["gengmei_pxf@gengmei123.local",[[1,1242,"## **"]],[1242,1242],[1247,1247]]],[1512459045851,["gengmei_pxf@gengmei123.local",[[1,1281,"**"]],[1281,1281],[1283,1283]]],[1512459063772,["gengmei_pxf@gengmei123.local",[[-1,1344,"###"]],[1347,1347],[1344,1344]]],[1512459065579,["gengmei_pxf@gengmei123.local",[[1,1344,"#"]],[1344,1344],[1345,1345]]],[1512459069272,["gengmei_pxf@gengmei123.local",[[-1,1347,"\\."]],[1349,1349],[1347,1347]]],[1512459076681,["gengmei_pxf@gengmei123.local",[[-1,1804,"##"]],[1806,1806],[1804,1804]]],[1512459078975,["gengmei_pxf@gengmei123.local",[[-1,1806,"\\."]],[1808,1808],[1806,1806]]],[1512459084039,["gengmei_pxf@gengmei123.local",[[-1,1961,"##"]],[1963,1963],[1961,1961]]],[1512459087623,["gengmei_pxf@gengmei123.local",[[-1,2033,"##"]],[2035,2035],[2033,2033]]],[1512459110911,["gengmei_pxf@gengmei123.local",[[-1,2716,"##"]],[2718,2718],[2716,2716]]],[1512459115671,["gengmei_pxf@gengmei123.local",[[-1,3254,"##"]],[3256,3256],[3254,3254]]],[1512459121685,["gengmei_pxf@gengmei123.local",[[-1,3061,"##"]],[3063,3063],[3061,3061]]],[1512459127406,["gengmei_pxf@gengmei123.local",[[-1,3416,"##"]],[3418,3418],[3416,3416]]],[1512459131419,["gengmei_pxf@gengmei123.local",[[-1,3804,"##"]],[3806,3806],[3804,3804]]],[1512459134407,["gengmei_pxf@gengmei123.local",[[-1,3866,"##"]],[3868,3868],[3866,3866]]],[1512459143846,["gengmei_pxf@gengmei123.local",[[-1,3902,"##"]],[3904,3904],[3902,3902]]],[1512459150038,["gengmei_pxf@gengmei123.local",[[-1,3904,"\\."]],[3906,3906],[3904,3904]]],[1512459156367,["gengmei_pxf@gengmei123.local",[[-1,4240,"##"]],[4242,4242],[4240,4240]]],[1512459158942,["gengmei_pxf@gengmei123.local",[[-1,4242,"\\."]],[4244,4244],[4242,4242]]],[1512459197797,["gengmei_pxf@gengmei123.local",[[-1,4411,"作者：QinGeneral\n链接：http://www.jianshu.com/p/5c92689c9be2\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[4411,4506],[4411,4411]]],[1512459197997,["gengmei_pxf@gengmei123.local",[[-1,4411,"\n"]],[4411,4411],[4410,4410]]],[1512459537798,["gengmei_pxf@gengmei123.local",[[1,4411,"\n"]],[4410,4410],[4411,4411]]],[1512459538556,["gengmei_pxf@gengmei123.local",[[1,4411,"面试官：说说Java的HashMap吧。\n\n我：首先HashMap是由数组+链表的方式实现的，是无序，非线程安全的数据结构。\n\n如果想使用有序的Map，可以使用TreeMap跟LinkedHashMap，其中TreeMap使用红黑树实现，排序规则由重写compare方法决定。LinkedHashMap则是维护了一个链表，根据构造参数选择在put或者get操作的时候进行顺序调整。\n\n如果想使用线程安全的Map，可以使用HashTable跟ConcurrentHashMap，由于HashTable性能较低，重点说下ConcurrentHashMap。ConcurrentHashMap在Java7跟Java8中实现方式有较大不同。\n\nJava7三要素：Segment，Lock，HashEntry。\n\nJava8三要素：Node，CAS，Synchronized。\n\n作者：凌风郎少\n链接：http://www.jianshu.com/p/7da5ec7a59e3\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[4411,4411],[4885,4885]]],[1512459545392,["gengmei_pxf@gengmei123.local",[[1,4411,"## **"]],[4411,4411],[4416,4416]]],[1512459548432,["gengmei_pxf@gengmei123.local",[[1,4436,"**"]],[4436,4436],[4438,4438]]],[1512459561070,["gengmei_pxf@gengmei123.local",[[-1,4803,"作者：凌风郎少\n链接：http://www.jianshu.com/p/7da5ec7a59e3\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n"]],[4802,4892],[4802,4802]]]]],["fb5e31ea-9385-41be-b24d-de5fcd6f5541",1516964575285,"# **电话面试题**\n\n 1.ArrayList 和 Hashmap 简单说一些,区别,底层的数据结构.\n\n2.Handler 消息机制\n\n3.引起内存泄漏的场景\n\n4.多线程的使用场景?\n\n5.常用的线程池有哪几种?\n\n6.在公司做了什么?团队规模?为什么离职?\n\n# **面试中实际涉及到的问题**\n\n## **第一轮**\n\n1.知道哪些单例模式,写一个线程安全的单例,并分析为什么是线程安全的?\n\n2.Java中的集合有哪些?解释一下HashMap?底部的数据结构?散列表冲突的处理方法,散列表是一个什么样的数据结构?HashMap是采用什么方法处理冲突的?\n\n3.解释一下什么是MVP架构,画出图解,一句话解释MVP和MVC的区别?\n\n4.Handle消息机制?在使用Handler的时候要注意哪些东西,是否会引起内存泄漏?画一下Handler机制的图解?\n\n5.是否做过性能优化?已经采取了哪些措施进行优化?\n\n6.引起内存泄漏的原因是什么?以及你是怎么解决的?\n\n这些问题应该都是比较基础的问题,每个开发者都应该是非常熟悉并能详细叙述的.这一轮的面试官问的技术都是平时用到的.\n\n## **第二轮**\n\n1.关于并发理解多少?说几个并发的集合?\n\n2.Handler 消息机制图解?\n\n3.在项目中做了哪些东西?\n\n4.画图说明View 事件传递机制?并举一个例子阐述\n\n5.类加载机制,如何换肤,换肤插件中存在的问题?hotfix是否用过,原理是否了解?\n\n6.说说项目中用到了哪些设计模式,说了一下策略模式和观察者模式?\n\n7.会JS么?有Hybid开发经验么?\n\n8.说一下快排的思想?手写代码\n\n9.堆有哪些数据结构?\n\n对于这轮米那是明显感觉到压力,知识的纵向了解也比较深,应该是个leader.\n\n## **第三轮**\n\n1.介绍一下在项目中的角色?\n\n2.遇到困难是怎么解决的?\n\n3.如何与人相处,与别人意见相左的时候是怎么解决的,并举生活中的一个例子.\n\n4.有没有压力特别大的时候?\n\n这个应该是项目经理了,问的问题偏向于生活性格方面.\n\n## **其他技术问题总结**\n\n**必问点**：Handler，多线程，http 与 https 的区别，事件分发与冲突，内存优化，内存泄漏等。\n\n**选问点**：设计模式，Fragment 与 Activity之间的通信，自定义 View，组件化架构等。\n\n几乎不怎么问的：MVP，屏幕适配，动画等。\n\n以后的一些面试方向：网络原理（五层模型的实现等），热更新，增量更新，JNI NDK（硬件公司重点之重点），跨进程通信（浅：广播，AIDL 。深：Binder 原理），framework 等。\n\n大公司一般不会问你很花哨的东西，原理，基础理论居多。小公司会问一些稍微应用层多一些的东西，例如 recyclerview 或者是瀑布流什么的。但是作为开发者来说，不断的学习，重复，记在脑子里比什么都重要。\n\n## **找工作的过程就是解决一个相对复杂问题的过程。可以按照以下四部进行准备**：\n\n1.  定义问题\n\n2.  划分问题\n\n3.  逐个突破\n\n4.  系统化\n\n接下来一步步的看一下具体细节。\n\n### 1 定义问题\n\n首先，定义一下我们解决的是什么问题。在这里，因为我们是Android方向，所以可以简单定义为：“我们要找到一个Android方向的工作（或相关的工作），工作要尽量好”。\n\n> 这个定义很模糊，什么是尽量的好呢？有的人看中薪资，有的人看中五险一金，各种福利等等。在这里，我们不考虑个人主观因素占比较大的问题。我们只考虑更加可控的东西。就是通过个人努力可以获得效果的问题。\n\n我们再思考一下“找到一个Android方向的工作”起决定性的因素是哪一个呢？\n\n答案是面试。当然一个人过去做过的项目，拿过的奖也至关重要。但是到了这个马上就要面试的时间节点，过去的已经过去，无法改变，能控制的只有现在。没有项目无关紧要，关键的是现在如何准备面试。\n\n目标：我要通过面试，拿到offer（或者我要通过多家公司面试，拿到多家公司的offer，选择最合心意的公司去工作）。当然，这句话表达的太宽泛，并没有什么指导意义。定义问题很重要，而更重要的是如何划分问题，这一步才是具有指导意义，能够落到实践中去的内容。\n\n### 2 划分问题\n\nAndroid面试需要准备内容的大致划分：（括号内为重要程度，最多5颗星）\n\n*   Android相关知识、Java相关知识、设计模式（5）\n\n*   算法、数据结构（5）\n\n*   如何写简历、如何面试（4）\n\n*   项目、比赛获奖（4）\n\n*   操作系统、网络、数据库（3）\n\n#### 细分\n\n以下细分内容，网络等计算机基础方面还不是很全面，持续更新中。\n\n我会逐步更新各个知识点相关博客或资源，如果需要，建议关注。\n\n#### Android\n\n*   Context的理解\n\n*   [Activity生命周期、启动模式、IntentFilter匹配规则](http://www.jianshu.com/p/3b675e85f78a)\n\n*   IPC：Serialzable、Parcelable、Binder、Socket\n\n*   View事件体系\n\n*   View绘制流程\n\n*   RemoteViews（不重要）\n\n*   Drawable（不重要）\n\n*   动画、绘图\n\n*   window、wm、wms\n\n*   四大组件启动、工作流程（Activity至少看一下，AMS）\n\n*   消息机制：looper、handler、MQ\n\n*   线程、线程池、多线程\n\n*   bitmap加载、缓存：LRUCache、DiskLruCache、LinkHashMap\n\n*   CrashHandler（一般）\n\n*   multidex（一般）\n\n*   Fragment、Service、SQLite、Webview\n\n*   [Android内存泄漏场景及解决方法](http://www.jianshu.com/p/f35ca324c285)\n\n*   ANR的原因、解决方法\n\n*   开源库（一般要求看过源码，知道原理）：Retrofit、RxAndroid、EventBus、Picasso（优点）、OKhttp3\n\n*   持续集成Jenkins（不重要）\n\n*   单元测试、测试用例（一般）\n\n*   插件化：Atlas、OSGI（一般）\n\n#### Java\n\n*   Java基础：比如接口和抽象类的区别等\n\n*   Java内存管理：工作内存和主内存等\n\n*   垃圾回收：回收算法、如何判断对象可以回收、新生代老年代等\n\n*   并发\n\n    锁：sychronized、lock（CAS）；volatile；并发集合：CopyOnWriteArrayList、ConcurrentHashMap、RemoteCallbackList（Android的IPC用到）、LinkedHashMap；\n\n*   集合\n\n    Map、Set、List\n\n    Queue、Stack\n\n    HashMap、HashTable、ConcurrentHashMap：实现原理，区别等\n\n    LinkedHashMap\n\n#### 设计模式（六大原则：SOLID + 迪米特）\n\n*   单例模式：获取各种service\n\n*   工厂方法：activity、service（onStart）\n\n*   责任链：Android事件分发\n\n*   builder：dialog、Picasso\n\n*   观察者：listview更新、EventBus\n\n*   适配器：listview adapter\n\n#### 算法、数据结构\n\n排序\n\n*   冒泡排序\n\n*   选择排序\n\n*   归并\n\n*   堆排序\n\n*   插入排序\n\n*   快速排序\n\n*   希尔排序\n\n*   桶排序\n\n*   基数排序\n\n字符匹配：KMP算法\n\n二分查找\n\n二叉树遍历、翻转、重构；二叉查找树\n\n红黑树\n\nAVL树、哈夫曼树、B树（一般）\n\n#### 网络\n\n[已整理博客，点击查看网络相关问题及其解答](http://www.jianshu.com/p/97f77927db0f)\n\n基本是围绕OSI七层模型展开，首先是各层的功能、每层有哪些协议。\n\n深入主要考察应用层和传输层：\n\n应用层：\n\n*   HTTP报文格式、头部有哪些字段\n\n*   HTTP状态码\n\n*   HTTP和HTTPS的区别\n\n*   HTTPS中SSL/TLS加密的握手过程\n\n*   HTTP一次连接的具体过程\n\n*   GET、POST的区别\n\n*   DNS解析过程\n\n*   Cookie、Session原理\n\n传输层：\n\n*   TCP/IP四层模型（和OSI的层次对应关系）\n\n*   TCP三次握手、四次握手的过程，状态变化和原因\n\n*   TCP、UDP区别\n\n*   TCP拥控、流控原理\n\n*   Socket原理\n\n#### 操作系统、数据库\n\n线程状态及其切换\n\n线程、进程区别\n\n（数据库重要程度相对低一些，正在整理中，后续会更新）\n\n#### 简历、面试、项目\n\n篇幅较大，会有另外博客进行探讨，敬请关注\n\n### 3 逐个突破\n\n可以自己去网上找一些博客、书籍，进行各个知识点的突破，要有耐心，找到一个心仪的工作非一日之功。\n\n一方面，我会陆续更新一些专业知识和面试相关的博客。\n\n另一方面，把我自己的一些资源分享给大家。\n\n*   博客\n\n    GitYuan（gityuan.com）、罗升阳（CSDN）、邓凡平（CSDN）、任玉刚（CSDN）\n\n*   书籍\n\n    Android 4高级编程、Android开发艺术探索、Android源码设计模式、Android 50 hacks、Android应用性能优化最佳实践、Efficient Java、深入Java虚拟机、Java并发编程、Think in Java\n\n*   刷题\n\n    牛客网、LeetCode\n\n### 4 系统化\n\n系统化其实就是当你把一整个相关的知识都看过看懂之后，进行总结和建立各模块之间关系的过程。\n\n每个人大脑“操作系统”是由概念和概念之间的联系的过程。系统化一方面可以加深知识的记忆，另一方面提供了另一个角度去理解这些概念，加大了概念的深入程度。\n\n建议多做记录、总结，多在各模块、各学科之间建立联系，抽取统一适用的知识和智慧。\n\n## **面试官：说说Java的HashMap吧。**\n\n我：首先HashMap是由数组+链表的方式实现的，是无序，非线程安全的数据结构。\n\n如果想使用有序的Map，可以使用TreeMap跟LinkedHashMap，其中TreeMap使用红黑树实现，排序规则由重写compare方法决定。LinkedHashMap则是维护了一个链表，根据构造参数选择在put或者get操作的时候进行顺序调整。\n\n如果想使用线程安全的Map，可以使用HashTable跟ConcurrentHashMap，由于HashTable性能较低，重点说下ConcurrentHashMap。ConcurrentHashMap在Java7跟Java8中实现方式有较大不同。\n\nJava7三要素：Segment，Lock，HashEntry。\n\nJava8三要素：Node，CAS，Synchronized。\n\n",[[1516964553841,["gengmei_pxf@gengmei123.local",[[1,202,"·"]],[202,202],[203,203]]],[1516964555052,["gengmei_pxf@gengmei123.local",[[-1,202,"·"]],[203,203],[202,202]]],[1516964556292,["gengmei_pxf@gengmei123.local",[[1,202,"```"]],[202,202],[205,205]]],[1516964556714,["gengmei_pxf@gengmei123.local",[[1,206,"\n"]],[205,205],[206,206]]],[1516964557148,["gengmei_pxf@gengmei123.local",[[1,207,"\n"]],[206,206],[207,207]]],[1516964557853,["gengmei_pxf@gengmei123.local",[[1,207,"```"]],[207,207],[210,210]]],[1516964559553,["gengmei_pxf@gengmei123.local",[[1,206,"public  class Singleton { // Private constructor prevents instantiation from other classes  private Singleton() { } /** * SingletonHolder is loaded on the first execution of Singleton.getInstance() * or the first access to SingletonHolder.INSTANCE, not before. */  private  static  class SingletonHolder { public  static  final Singleton INSTANCE = new Singleton(); } public static Singleton getInstance() { return SingletonHolder.INSTANCE; } }"]],[206,206],[650,650]]],[1516964563338,["gengmei_pxf@gengmei123.local",[[-1,206,"public  class Singleton { // Private constructor prevents instantiation from other classes  private Singleton() { } /** * SingletonHolder is loaded on the first execution of Singleton.getInstance() * or the first access to SingletonHolder.INSTANCE, not before. */  private  static  class SingletonHolder { public  static  final Singleton INSTANCE = new Singleton(); } public static Singleton getInstance() { return SingletonHolder.INSTANCE; } }"]],[650,650],[206,206]]]]],["8ddc3fe5-dea8-48c7-8c2b-12b44c970665",1516964598141,"# **电话面试题**\n\n 1.ArrayList 和 Hashmap 简单说一些,区别,底层的数据结构.\n\n2.Handler 消息机制\n\n3.引起内存泄漏的场景\n\n4.多线程的使用场景?\n\n5.常用的线程池有哪几种?\n\n6.在公司做了什么?团队规模?为什么离职?\n\n# **面试中实际涉及到的问题**\n\n## **第一轮**\n\n1.知道哪些单例模式,写一个线程安全的单例,并分析为什么是线程安全的?\n```\n\n```\n2.Java中的集合有哪些?解释一下HashMap?底部的数据结构?散列表冲突的处理方法,散列表是一个什么样的数据结构?HashMap是采用什么方法处理冲突的?\n\n3.解释一下什么是MVP架构,画出图解,一句话解释MVP和MVC的区别?\n\n4.Handle消息机制?在使用Handler的时候要注意哪些东西,是否会引起内存泄漏?画一下Handler机制的图解?\n\n5.是否做过性能优化?已经采取了哪些措施进行优化?\n\n6.引起内存泄漏的原因是什么?以及你是怎么解决的?\n\n这些问题应该都是比较基础的问题,每个开发者都应该是非常熟悉并能详细叙述的.这一轮的面试官问的技术都是平时用到的.\n\n## **第二轮**\n\n1.关于并发理解多少?说几个并发的集合?\n\n2.Handler 消息机制图解?\n\n3.在项目中做了哪些东西?\n\n4.画图说明View 事件传递机制?并举一个例子阐述\n\n5.类加载机制,如何换肤,换肤插件中存在的问题?hotfix是否用过,原理是否了解?\n\n6.说说项目中用到了哪些设计模式,说了一下策略模式和观察者模式?\n\n7.会JS么?有Hybid开发经验么?\n\n8.说一下快排的思想?手写代码\n\n9.堆有哪些数据结构?\n\n对于这轮米那是明显感觉到压力,知识的纵向了解也比较深,应该是个leader.\n\n## **第三轮**\n\n1.介绍一下在项目中的角色?\n\n2.遇到困难是怎么解决的?\n\n3.如何与人相处,与别人意见相左的时候是怎么解决的,并举生活中的一个例子.\n\n4.有没有压力特别大的时候?\n\n这个应该是项目经理了,问的问题偏向于生活性格方面.\n\n## **其他技术问题总结**\n\n**必问点**：Handler，多线程，http 与 https 的区别，事件分发与冲突，内存优化，内存泄漏等。\n\n**选问点**：设计模式，Fragment 与 Activity之间的通信，自定义 View，组件化架构等。\n\n几乎不怎么问的：MVP，屏幕适配，动画等。\n\n以后的一些面试方向：网络原理（五层模型的实现等），热更新，增量更新，JNI NDK（硬件公司重点之重点），跨进程通信（浅：广播，AIDL 。深：Binder 原理），framework 等。\n\n大公司一般不会问你很花哨的东西，原理，基础理论居多。小公司会问一些稍微应用层多一些的东西，例如 recyclerview 或者是瀑布流什么的。但是作为开发者来说，不断的学习，重复，记在脑子里比什么都重要。\n\n## **找工作的过程就是解决一个相对复杂问题的过程。可以按照以下四部进行准备**：\n\n1.  定义问题\n\n2.  划分问题\n\n3.  逐个突破\n\n4.  系统化\n\n接下来一步步的看一下具体细节。\n\n### 1 定义问题\n\n首先，定义一下我们解决的是什么问题。在这里，因为我们是Android方向，所以可以简单定义为：“我们要找到一个Android方向的工作（或相关的工作），工作要尽量好”。\n\n> 这个定义很模糊，什么是尽量的好呢？有的人看中薪资，有的人看中五险一金，各种福利等等。在这里，我们不考虑个人主观因素占比较大的问题。我们只考虑更加可控的东西。就是通过个人努力可以获得效果的问题。\n\n我们再思考一下“找到一个Android方向的工作”起决定性的因素是哪一个呢？\n\n答案是面试。当然一个人过去做过的项目，拿过的奖也至关重要。但是到了这个马上就要面试的时间节点，过去的已经过去，无法改变，能控制的只有现在。没有项目无关紧要，关键的是现在如何准备面试。\n\n目标：我要通过面试，拿到offer（或者我要通过多家公司面试，拿到多家公司的offer，选择最合心意的公司去工作）。当然，这句话表达的太宽泛，并没有什么指导意义。定义问题很重要，而更重要的是如何划分问题，这一步才是具有指导意义，能够落到实践中去的内容。\n\n### 2 划分问题\n\nAndroid面试需要准备内容的大致划分：（括号内为重要程度，最多5颗星）\n\n*   Android相关知识、Java相关知识、设计模式（5）\n\n*   算法、数据结构（5）\n\n*   如何写简历、如何面试（4）\n\n*   项目、比赛获奖（4）\n\n*   操作系统、网络、数据库（3）\n\n#### 细分\n\n以下细分内容，网络等计算机基础方面还不是很全面，持续更新中。\n\n我会逐步更新各个知识点相关博客或资源，如果需要，建议关注。\n\n#### Android\n\n*   Context的理解\n\n*   [Activity生命周期、启动模式、IntentFilter匹配规则](http://www.jianshu.com/p/3b675e85f78a)\n\n*   IPC：Serialzable、Parcelable、Binder、Socket\n\n*   View事件体系\n\n*   View绘制流程\n\n*   RemoteViews（不重要）\n\n*   Drawable（不重要）\n\n*   动画、绘图\n\n*   window、wm、wms\n\n*   四大组件启动、工作流程（Activity至少看一下，AMS）\n\n*   消息机制：looper、handler、MQ\n\n*   线程、线程池、多线程\n\n*   bitmap加载、缓存：LRUCache、DiskLruCache、LinkHashMap\n\n*   CrashHandler（一般）\n\n*   multidex（一般）\n\n*   Fragment、Service、SQLite、Webview\n\n*   [Android内存泄漏场景及解决方法](http://www.jianshu.com/p/f35ca324c285)\n\n*   ANR的原因、解决方法\n\n*   开源库（一般要求看过源码，知道原理）：Retrofit、RxAndroid、EventBus、Picasso（优点）、OKhttp3\n\n*   持续集成Jenkins（不重要）\n\n*   单元测试、测试用例（一般）\n\n*   插件化：Atlas、OSGI（一般）\n\n#### Java\n\n*   Java基础：比如接口和抽象类的区别等\n\n*   Java内存管理：工作内存和主内存等\n\n*   垃圾回收：回收算法、如何判断对象可以回收、新生代老年代等\n\n*   并发\n\n    锁：sychronized、lock（CAS）；volatile；并发集合：CopyOnWriteArrayList、ConcurrentHashMap、RemoteCallbackList（Android的IPC用到）、LinkedHashMap；\n\n*   集合\n\n    Map、Set、List\n\n    Queue、Stack\n\n    HashMap、HashTable、ConcurrentHashMap：实现原理，区别等\n\n    LinkedHashMap\n\n#### 设计模式（六大原则：SOLID + 迪米特）\n\n*   单例模式：获取各种service\n\n*   工厂方法：activity、service（onStart）\n\n*   责任链：Android事件分发\n\n*   builder：dialog、Picasso\n\n*   观察者：listview更新、EventBus\n\n*   适配器：listview adapter\n\n#### 算法、数据结构\n\n排序\n\n*   冒泡排序\n\n*   选择排序\n\n*   归并\n\n*   堆排序\n\n*   插入排序\n\n*   快速排序\n\n*   希尔排序\n\n*   桶排序\n\n*   基数排序\n\n字符匹配：KMP算法\n\n二分查找\n\n二叉树遍历、翻转、重构；二叉查找树\n\n红黑树\n\nAVL树、哈夫曼树、B树（一般）\n\n#### 网络\n\n[已整理博客，点击查看网络相关问题及其解答](http://www.jianshu.com/p/97f77927db0f)\n\n基本是围绕OSI七层模型展开，首先是各层的功能、每层有哪些协议。\n\n深入主要考察应用层和传输层：\n\n应用层：\n\n*   HTTP报文格式、头部有哪些字段\n\n*   HTTP状态码\n\n*   HTTP和HTTPS的区别\n\n*   HTTPS中SSL/TLS加密的握手过程\n\n*   HTTP一次连接的具体过程\n\n*   GET、POST的区别\n\n*   DNS解析过程\n\n*   Cookie、Session原理\n\n传输层：\n\n*   TCP/IP四层模型（和OSI的层次对应关系）\n\n*   TCP三次握手、四次握手的过程，状态变化和原因\n\n*   TCP、UDP区别\n\n*   TCP拥控、流控原理\n\n*   Socket原理\n\n#### 操作系统、数据库\n\n线程状态及其切换\n\n线程、进程区别\n\n（数据库重要程度相对低一些，正在整理中，后续会更新）\n\n#### 简历、面试、项目\n\n篇幅较大，会有另外博客进行探讨，敬请关注\n\n### 3 逐个突破\n\n可以自己去网上找一些博客、书籍，进行各个知识点的突破，要有耐心，找到一个心仪的工作非一日之功。\n\n一方面，我会陆续更新一些专业知识和面试相关的博客。\n\n另一方面，把我自己的一些资源分享给大家。\n\n*   博客\n\n    GitYuan（gityuan.com）、罗升阳（CSDN）、邓凡平（CSDN）、任玉刚（CSDN）\n\n*   书籍\n\n    Android 4高级编程、Android开发艺术探索、Android源码设计模式、Android 50 hacks、Android应用性能优化最佳实践、Efficient Java、深入Java虚拟机、Java并发编程、Think in Java\n\n*   刷题\n\n    牛客网、LeetCode\n\n### 4 系统化\n\n系统化其实就是当你把一整个相关的知识都看过看懂之后，进行总结和建立各模块之间关系的过程。\n\n每个人大脑“操作系统”是由概念和概念之间的联系的过程。系统化一方面可以加深知识的记忆，另一方面提供了另一个角度去理解这些概念，加大了概念的深入程度。\n\n建议多做记录、总结，多在各模块、各学科之间建立联系，抽取统一适用的知识和智慧。\n\n## **面试官：说说Java的HashMap吧。**\n\n我：首先HashMap是由数组+链表的方式实现的，是无序，非线程安全的数据结构。\n\n如果想使用有序的Map，可以使用TreeMap跟LinkedHashMap，其中TreeMap使用红黑树实现，排序规则由重写compare方法决定。LinkedHashMap则是维护了一个链表，根据构造参数选择在put或者get操作的时候进行顺序调整。\n\n如果想使用线程安全的Map，可以使用HashTable跟ConcurrentHashMap，由于HashTable性能较低，重点说下ConcurrentHashMap。ConcurrentHashMap在Java7跟Java8中实现方式有较大不同。\n\nJava7三要素：Segment，Lock，HashEntry。\n\nJava8三要素：Node，CAS，Synchronized。\n\n",[[1516964588884,["gengmei_pxf@gengmei123.local",[[1,205,"java"],[1,206,"public class Singleton {\n\t// Private constructor prevents instantiation from other classes\n\tprivate Singleton() { }\n\n\t/**\n\t* SingletonHolder is loaded on the first execution of Singleton.getInstance() \n\t* or the first access to SingletonHolder.INSTANCE, not before.\n\t*/\n\tprivate static class SingletonHolder { \n\t\t\tpublic static final Singleton INSTANCE = new Singleton();\n\t}\n\n\tpublic static Singleton getInstance() {\n\t\t\treturn SingletonHolder.INSTANCE;\n\t}\n}"]],[202,210],[671,671]]],[1516964708065,["gengmei_pxf@gengmei123.local",[[1,54,"ArrayListshuyu"]],[54,54],[68,68]]],[1516964709446,["gengmei_pxf@gengmei123.local",[[-1,63,"shuyu"]],[68,68],[63,63]]],[1516964715290,["gengmei_pxf@gengmei123.local",[[1,63,"属于List集合，"]],[63,63],[72,72]]],[1516964761255,["gengmei_pxf@gengmei123.local",[[1,72,"有序的，元素可重复，有索引，"]],[72,72],[86,86]]],[1516964762197,["gengmei_pxf@gengmei123.local",[[1,87,"\n"]],[86,86],[87,87]]],[1516964775464,["gengmei_pxf@gengmei123.local",[[1,87,"Hashmap属于Map集合"]],[87,87],[101,101]]],[1516964777596,["gengmei_pxf@gengmei123.local",[[1,102,"\n"]],[101,101],[102,102]]],[1516964788620,["gengmei_pxf@gengmei123.local",[[1,102,"**ArrayList**：底层是数组结构，查询快，增删慢，不同步。"]],[102,102],[136,136]]],[1516964808828,["gengmei_pxf@gengmei123.local",[[1,137,"\n"]],[136,136],[137,137]]],[1516964809190,["gengmei_pxf@gengmei123.local",[[1,137,"**HashMap**：底层数据结构是哈希表；允许使用null键和null值，不同步，效率高"]],[137,137],[183,183]]],[1516964817852,["gengmei_pxf@gengmei123.local",[[1,54,"**"]],[54,54],[56,56]]],[1516964818957,["gengmei_pxf@gengmei123.local",[[1,65,"**"]],[65,65],[67,67]]],[1516964820222,["gengmei_pxf@gengmei123.local",[[1,91,"**"]],[91,91],[93,93]]],[1516964821949,["gengmei_pxf@gengmei123.local",[[1,100,"**"]],[100,100],[102,102]]],[1516964825122,["gengmei_pxf@gengmei123.local",[[-1,97,"m"]],[98,98],[97,97]]],[1516964876315,["gengmei_pxf@gengmei123.local",[[1,90,"单列集合，一次存一个元素"],[1,97,"M"]],[90,90],[102,102]]],[1516964883445,["gengmei_pxf@gengmei123.local",[[1,90,"属于collection"]],[90,90],[102,102]]],[1516964892755,["gengmei_pxf@gengmei123.local",[[-1,92,"c"],[1,93,"C"]],[92,102],[102,102]]],[1516964904495,["gengmei_pxf@gengmei123.local",[[1,133,"，Map：双列集合，一次存一对集合，两个元素（对象）存在着映射关系"]],[133,133],[166,166]]],[1516964908432,["gengmei_pxf@gengmei123.local",[[-1,134,"Map："]],[134,138],[134,134]]],[1516965824835,["gengmei_pxf@gengmei123.local",[[1,260,"* 首先Looper.prepare()会在当前线程保存一个looper对象，并且会维护一个消息队列messageQueue，而且规定了messageQueue在每个线程中只会存在唯一的一个\n* Looper.loop()方法会使线程进入一个无限循环，不断地从消息队列中获取消息，之后回调msg.target.disPatchMessage方法。\n* 我们在实例化handler的过程中，会先得到当前所在线程的looper对象，之后得到与该looper对象相对应的消息队列。（代码见handler的构造方法）\n* 当我们发送消息的时候，即handler.sendMessage或者handler.post，会将msg中的target赋值为handler自身，之后加入到消息队列中。\n* 在第三步实现实例化handler的过程中，我们一般会重写handlerMessage方法（使用post方法需要实现run方法），而这些方法将会在第二步中的msg.target.disPatchMessage方法中被回调，从而实现了message从一个线程到另外一个线程的传递。"]],[260,260],[741,741]]],[1516965830822,["gengmei_pxf@gengmei123.local",[[1,742,"\n"]],[742,742],[743,743]]],[1516965836270,["gengmei_pxf@gengmei123.local",[[1,245,"\n"]],[245,245],[246,246]]],[1516965839535,["gengmei_pxf@gengmei123.local",[[1,115,"\n"]],[115,115],[116,116]]],[1516965841110,["gengmei_pxf@gengmei123.local",[[1,164,"\n"]],[164,164],[165,165]]],[1516965842191,["gengmei_pxf@gengmei123.local",[[1,200,"\n"]],[200,200],[201,201]]],[1516965846925,["gengmei_pxf@gengmei123.local",[[1,54,"\n"]],[54,54],[55,55]]],[1516965849608,["gengmei_pxf@gengmei123.local",[[1,265,"\n"]],[265,265],[266,266]]],[1516965850869,["gengmei_pxf@gengmei123.local",[[1,362,"\n"]],[362,362],[363,363]]],[1516965852110,["gengmei_pxf@gengmei123.local",[[1,441,"\n"]],[441,441],[442,442]]],[1516965853719,["gengmei_pxf@gengmei123.local",[[1,523,"\n"]],[523,523],[524,524]]],[1516965855086,["gengmei_pxf@gengmei123.local",[[1,610,"\n"]],[610,610],[611,611]]],[1516966620715,["gengmei_pxf@gengmei123.local",[[1,753,"\n"]],[751,751],[752,752]]],[1516966621186,["gengmei_pxf@gengmei123.local",[[1,754,"\n"]],[752,752],[753,753]]],[1516966622982,["gengmei_pxf@gengmei123.local",[[1,753,"【】"]],[753,753],[755,755]]],[1516966623642,["gengmei_pxf@gengmei123.local",[[-1,753,"【】"]],[755,755],[753,753]]],[1516966625397,["gengmei_pxf@gengmei123.local",[[1,753,"[]()"]],[753,753],[757,757]]],[1516966626414,["gengmei_pxf@gengmei123.local",[[1,756,"https://github.com/pxfile/note_accumulate/blob/master/Interview-Q-A/Handler%E6%9C%BA%E5%88%B6%EF%BC%9F%20MessageQueue%EF%BC%8CLooper%E7%AD%89/Handler%E6%9C%BA%E5%88%B6%EF%BC%9F%20MessageQueue%EF%BC%8CLooper%E7%AD%89.md"]],[756,756],[974,974]]],[1516966637747,["gengmei_pxf@gengmei123.local",[[1,754,"**Handler机制？ MessageQueue，Looper等**"]],[754,754],[789,789]]]]]]}